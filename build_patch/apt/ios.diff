diff -urN apt-2.1.5/apt-pkg/acquire.cc apt/apt-pkg/acquire.cc
--- apt-2.1.5/apt-pkg/acquire.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/acquire.cc	2020-06-09 02:03:04.027546411 -0400
@@ -1263,7 +1263,7 @@
    auto const Time = std::chrono::steady_clock::now().time_since_epoch();
    auto const Time_sec = std::chrono::duration_cast<std::chrono::seconds>(Time);
    auto const Time_usec = std::chrono::duration_cast<std::chrono::microseconds>(Time - Time_sec);
-   return { Time_sec.count(), Time_usec.count() };
+   return { static_cast<__darwin_time_t>(Time_sec.count()), static_cast<__darwin_suseconds_t>(Time_usec.count()) };
 }
 bool pkgAcquireStatus::Pulse(pkgAcquire *Owner)
 {
diff -urN apt-2.1.5/apt-pkg/algorithms.cc apt/apt-pkg/algorithms.cc
--- apt-2.1.5/apt-pkg/algorithms.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/algorithms.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,1407 +0,0 @@
-// -*- mode: cpp; mode: fold -*-
-// Description								/*{{{*/
-/* ######################################################################
-
-   Algorithms - A set of misc algorithms
-
-   The pkgProblemResolver class has become insanely complex and
-   very sophisticated, it handles every test case I have thrown at it
-   to my satisfaction. Understanding exactly why all the steps the class
-   does are required is difficult and changing though not very risky
-   may result in other cases not working.
-   
-   ##################################################################### */
-									/*}}}*/
-// Include Files							/*{{{*/
-#include <config.h>
-
-#include <apt-pkg/algorithms.h>
-#include <apt-pkg/configuration.h>
-#include <apt-pkg/depcache.h>
-#include <apt-pkg/dpkgpm.h>
-#include <apt-pkg/edsp.h>
-#include <apt-pkg/error.h>
-#include <apt-pkg/packagemanager.h>
-#include <apt-pkg/pkgcache.h>
-#include <apt-pkg/prettyprinters.h>
-
-#include <cstdlib>
-#include <iostream>
-#include <string>
-#include <utility>
-#include <string.h>
-
-#include <apti18n.h>
-									/*}}}*/
-using namespace std;
-
-class APT_HIDDEN pkgSimulatePrivate
-{
-public:
-   std::vector<pkgDPkgPM::Item> List;
-};
-// Simulate::Simulate - Constructor					/*{{{*/
-// ---------------------------------------------------------------------
-/* The legacy translations here of input Pkg iterators is obsolete, 
-   this is not necessary since the pkgCaches are fully shared now. */
-pkgSimulate::pkgSimulate(pkgDepCache *Cache) : pkgPackageManager(Cache),
-		            d(new pkgSimulatePrivate()), iPolicy(Cache),
-			    Sim(&Cache->GetCache(),&iPolicy),
-			    group(Sim)
-{
-   Sim.Init(0);
-   auto PackageCount = Cache->Head().PackageCount;
-   Flags = new unsigned char[PackageCount];
-   memset(Flags,0,sizeof(*Flags)*PackageCount);
-
-   // Fake a filename so as not to activate the media swapping
-   string Jnk = "SIMULATE";
-   for (decltype(PackageCount) I = 0; I != PackageCount; ++I)
-      FileNames[I] = Jnk;
-
-   Cache->CheckConsistency("simulate");
-}
-									/*}}}*/
-// Simulate::~Simulate - Destructor					/*{{{*/
-pkgSimulate::~pkgSimulate()
-{
-   delete[] Flags;
-   delete d;
-}
-									/*}}}*/
-// Simulate::Describe - Describe a package				/*{{{*/
-// ---------------------------------------------------------------------
-/* Parameter Current == true displays the current package version,
-   Parameter Candidate == true displays the candidate package version */
-void pkgSimulate::Describe(PkgIterator Pkg,ostream &out,bool Current,bool Candidate)
-{
-   VerIterator Ver(Sim);
- 
-   out << Pkg.FullName(true);
-
-   if (Current == true)
-   {
-      Ver = Pkg.CurrentVer();
-      if (Ver.end() == false)
-         out << " [" << Ver.VerStr() << ']';
-   }
-
-   if (Candidate == true)
-   {
-      Ver = Sim[Pkg].CandidateVerIter(Sim);
-      if (Ver.end() == true)
-         return;
-   
-      out << " (" << Ver.VerStr() << ' ' << Ver.RelStr() << ')';
-   }
-}
-									/*}}}*/
-// Simulate::Install - Simulate unpacking of a package			/*{{{*/
-// ---------------------------------------------------------------------
-/* */
-bool pkgSimulate::Install(PkgIterator iPkg,string File)
-{
-   if (iPkg.end() || File.empty())
-      return false;
-   d->List.emplace_back(pkgDPkgPM::Item::Install, iPkg, File);
-   return true;
-}
-bool pkgSimulate::RealInstall(PkgIterator iPkg,string /*File*/)
-{
-   // Adapt the iterator
-   PkgIterator Pkg = Sim.FindPkg(iPkg.Name(), iPkg.Arch());
-   Flags[Pkg->ID] = 1;
-   
-   cout << "Inst ";
-   Describe(Pkg,cout,true,true);
-   Sim.MarkInstall(Pkg,false);
-
-   // Look for broken conflicts+predepends.
-   for (PkgIterator I = Sim.PkgBegin(); I.end() == false; ++I)
-   {
-      if (Sim[I].InstallVer == 0)
-	 continue;
-      
-      for (DepIterator D = Sim[I].InstVerIter(Sim).DependsList(); D.end() == false;)
-      {
-	 DepIterator Start;
-	 DepIterator End;
-	 D.GlobOr(Start,End);
-	 if (Start.IsNegative() == true ||
-	     End->Type == pkgCache::Dep::PreDepends)
-         {
-	    if ((Sim[End] & pkgDepCache::DepGInstall) == 0)
-	    {
-	       cout << " [" << I.FullName(false) << " on " << Start.TargetPkg().FullName(false) << ']';
-	       if (Start->Type == pkgCache::Dep::Conflicts)
-		  _error->Error("Fatal, conflicts violated %s",I.FullName(false).c_str());
-	    }	    
-	 }
-      }      
-   }
-
-   if (Sim.BrokenCount() != 0)
-      ShortBreaks();
-   else
-      cout << endl;
-   return true;
-}
-									/*}}}*/
-// Simulate::Configure - Simulate configuration of a Package		/*{{{*/
-// ---------------------------------------------------------------------
-/* This is not an accurate simulation of relatity, we should really not
-   install the package.. For some investigations it may be necessary 
-   however. */
-bool pkgSimulate::Configure(PkgIterator iPkg)
-{
-   if (iPkg.end())
-      return false;
-   d->List.emplace_back(pkgDPkgPM::Item::Configure, iPkg);
-   return true;
-}
-bool pkgSimulate::RealConfigure(PkgIterator iPkg)
-{
-   // Adapt the iterator
-   PkgIterator Pkg = Sim.FindPkg(iPkg.Name(), iPkg.Arch());
-   
-   Flags[Pkg->ID] = 2;
-
-   if (Sim[Pkg].InstBroken() == true)
-   {
-      cout << "Conf " << Pkg.FullName(false) << " broken" << endl;
-
-      Sim.Update();
-      
-      // Print out each package and the failed dependencies
-      for (pkgCache::DepIterator D = Sim[Pkg].InstVerIter(Sim).DependsList(); D.end() == false; ++D)
-      {
-	 if (Sim.IsImportantDep(D) == false || 
-	     (Sim[D] & pkgDepCache::DepInstall) != 0)
-	    continue;
-	 
-	 if (D->Type == pkgCache::Dep::Obsoletes)
-	    cout << " Obsoletes:" << D.TargetPkg().FullName(false);
-	 else if (D->Type == pkgCache::Dep::Conflicts)
-	    cout << " Conflicts:" << D.TargetPkg().FullName(false);
-	 else if (D->Type == pkgCache::Dep::DpkgBreaks)
-	    cout << " Breaks:" << D.TargetPkg().FullName(false);
-	 else
-	    cout << " Depends:" << D.TargetPkg().FullName(false);
-      }	    
-      cout << endl;
-
-      _error->Error("Conf Broken %s",Pkg.FullName(false).c_str());
-   }   
-   else
-   {
-      cout << "Conf "; 
-      Describe(Pkg,cout,false,true);
-   }
-
-   if (Sim.BrokenCount() != 0)
-      ShortBreaks();
-   else
-      cout << endl;
-   
-   return true;
-}
-									/*}}}*/
-// Simulate::Remove - Simulate the removal of a package			/*{{{*/
-// ---------------------------------------------------------------------
-/* */
-bool pkgSimulate::Remove(PkgIterator iPkg,bool Purge)
-{
-   if (iPkg.end())
-      return false;
-   d->List.emplace_back(Purge ? pkgDPkgPM::Item::Purge : pkgDPkgPM::Item::Remove, iPkg);
-   return true;
-}
-bool pkgSimulate::RealRemove(PkgIterator iPkg,bool Purge)
-{
-   // Adapt the iterator
-   PkgIterator Pkg = Sim.FindPkg(iPkg.Name(), iPkg.Arch());
-   if (Pkg.end() == true)
-   {
-      std::cerr << (Purge ? "Purg" : "Remv") << " invalid package " << iPkg.FullName() << std::endl;
-      return false;
-   }
-
-   Flags[Pkg->ID] = 3;
-   Sim.MarkDelete(Pkg);
-
-   if (Purge == true)
-      cout << "Purg ";
-   else
-      cout << "Remv ";
-   Describe(Pkg,cout,true,false);
-
-   if (Sim.BrokenCount() != 0)
-      ShortBreaks();
-   else
-      cout << endl;
-
-   return true;
-}
-									/*}}}*/
-// Simulate::ShortBreaks - Print out a short line describing all breaks	/*{{{*/
-// ---------------------------------------------------------------------
-/* */
-void pkgSimulate::ShortBreaks()
-{
-   cout << " [";
-   for (PkgIterator I = Sim.PkgBegin(); I.end() == false; ++I)
-   {
-      if (Sim[I].InstBroken() == true)
-      {
-	 if (Flags[I->ID] == 0)
-	    cout << I.FullName(false) << ' ';
-/*	 else
-	    cout << I.Name() << "! ";*/
-      }      
-   }
-   cout << ']' << endl;
-}
-									/*}}}*/
-bool pkgSimulate::Go(APT::Progress::PackageManager *)			/*{{{*/
-{
-   if (pkgDPkgPM::ExpandPendingCalls(d->List, Cache) == false)
-      return false;
-   for (auto && I : d->List)
-      switch (I.Op)
-      {
-	 case pkgDPkgPM::Item::Install:
-	    if (RealInstall(I.Pkg, I.File) == false)
-	       return false;
-	    break;
-	 case pkgDPkgPM::Item::Configure:
-	    if (RealConfigure(I.Pkg) == false)
-	       return false;
-	    break;
-	 case pkgDPkgPM::Item::Remove:
-	    if (RealRemove(I.Pkg, false) == false)
-	       return false;
-	    break;
-	 case pkgDPkgPM::Item::Purge:
-	    if (RealRemove(I.Pkg, true) == false)
-	       return false;
-	    break;
-	 case pkgDPkgPM::Item::ConfigurePending:
-	 case pkgDPkgPM::Item::TriggersPending:
-	 case pkgDPkgPM::Item::RemovePending:
-	 case pkgDPkgPM::Item::PurgePending:
-	    return _error->Error("Internal error, simulation encountered unexpected pending item");
-      }
-   return true;
-}
-									/*}}}*/
-// ApplyStatus - Adjust for non-ok packages				/*{{{*/
-// ---------------------------------------------------------------------
-/* We attempt to change the state of the all packages that have failed
-   installation toward their real state. The ordering code will perform 
-   the necessary calculations to deal with the problems. */
-bool pkgApplyStatus(pkgDepCache &Cache)
-{
-   pkgDepCache::ActionGroup group(Cache);
-
-   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
-   {
-      if (I->VersionList == 0)
-	 continue;
-	 
-      // Only choice for a ReInstReq package is to reinstall
-      if (I->InstState == pkgCache::State::ReInstReq ||
-	  I->InstState == pkgCache::State::HoldReInstReq)
-      {
-	 if (I->CurrentVer != 0 && I.CurrentVer().Downloadable() == true)
-	    Cache.MarkKeep(I, false, false);
-	 else
-	 {
-	    // Is this right? Will dpkg choke on an upgrade?
-	    if (Cache[I].CandidateVer != 0 &&
-		 Cache[I].CandidateVerIter(Cache).Downloadable() == true)
-	       Cache.MarkInstall(I, false, 0, false);
-	    else
-	       return _error->Error(_("The package %s needs to be reinstalled, "
-				    "but I can't find an archive for it."),I.FullName(true).c_str());
-	 }
-	 
-	 continue;
-      }
-      
-      switch (I->CurrentState)
-      {
-	 /* This means installation failed somehow - it does not need to be
-	    re-unpacked (probably) */
-	 case pkgCache::State::UnPacked:
-	 case pkgCache::State::HalfConfigured:
-	 case pkgCache::State::TriggersAwaited:
-	 case pkgCache::State::TriggersPending:
-	 if ((I->CurrentVer != 0 && I.CurrentVer().Downloadable() == true) ||
-	     I.State() != pkgCache::PkgIterator::NeedsUnpack)
-	    Cache.MarkKeep(I, false, false);
-	 else
-	 {
-	    if (Cache[I].CandidateVer != 0 &&
-		 Cache[I].CandidateVerIter(Cache).Downloadable() == true)
-	       Cache.MarkInstall(I, true, 0, false);
-	    else
-	       Cache.MarkDelete(I, false, 0, false);
-	 }
-	 break;
-
-	 // This means removal failed
-	 case pkgCache::State::HalfInstalled:
-	 Cache.MarkDelete(I, false, 0, false);
-	 break;
-	 
-	 default:
-	 if (I->InstState != pkgCache::State::Ok)
-	    return _error->Error("The package %s is not ok and I "
-				 "don't know how to fix it!",I.FullName(false).c_str());
-      }
-   }
-   return true;
-}
-									/*}}}*/
-// FixBroken - Fix broken packages					/*{{{*/
-// ---------------------------------------------------------------------
-/* This autoinstalls every broken package and then runs the problem resolver
-   on the result. */
-bool pkgFixBroken(pkgDepCache &Cache)
-{
-   pkgDepCache::ActionGroup group(Cache);
-
-   // Auto upgrade all broken packages
-   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
-      if (Cache[I].NowBroken() == true)
-	 Cache.MarkInstall(I, true, 0, false);
-   
-   /* Fix packages that are in a NeedArchive state but don't have a
-      downloadable install version */
-   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
-   {
-      if (I.State() != pkgCache::PkgIterator::NeedsUnpack ||
-	  Cache[I].Delete() == true)
-	 continue;
-      
-      if (Cache[I].InstVerIter(Cache).Downloadable() == false)
-	 continue;
-
-      Cache.MarkInstall(I, true, 0, false);
-   }
-   
-   pkgProblemResolver Fix(&Cache);
-   return Fix.Resolve(true);
-}
-									/*}}}*/
-// ProblemResolver::pkgProblemResolver - Constructor			/*{{{*/
-// ---------------------------------------------------------------------
-/* */
-pkgProblemResolver::pkgProblemResolver(pkgDepCache *pCache) : d(NULL), Cache(*pCache)
-{
-   // Allocate memory
-   auto const Size = Cache.Head().PackageCount;
-   Scores = new int[Size];
-   Flags = new unsigned char[Size];
-   memset(Flags,0,sizeof(*Flags)*Size);
-   
-   // Set debug to true to see its decision logic
-   Debug = _config->FindB("Debug::pkgProblemResolver",false);
-}
-									/*}}}*/
-// ProblemResolver::~pkgProblemResolver - Destructor			/*{{{*/
-// ---------------------------------------------------------------------
-/* */
-pkgProblemResolver::~pkgProblemResolver()
-{
-   delete [] Scores;
-   delete [] Flags;
-}
-									/*}}}*/
-// ProblemResolver::ScoreSort - Sort the list by score			/*{{{*/
-// ---------------------------------------------------------------------
-/* */
-int pkgProblemResolver::ScoreSort(Package const *A,Package const *B)
-{
-   if (Scores[A->ID] > Scores[B->ID])
-      return -1;
-   if (Scores[A->ID] < Scores[B->ID])
-      return 1;
-   return 0;
-}
-									/*}}}*/
-// ProblemResolver::MakeScores - Make the score table			/*{{{*/
-// ---------------------------------------------------------------------
-/* */
-void pkgProblemResolver::MakeScores()
-{
-   auto const Size = Cache.Head().PackageCount;
-   memset(Scores,0,sizeof(*Scores)*Size);
-
-   // maps to pkgCache::State::VerPriority: 
-   //    Required Important Standard Optional Extra
-   int PrioMap[] = {
-      0,
-      _config->FindI("pkgProblemResolver::Scores::Required",3),
-      _config->FindI("pkgProblemResolver::Scores::Important",2),
-      _config->FindI("pkgProblemResolver::Scores::Standard",1),
-      _config->FindI("pkgProblemResolver::Scores::Optional",-1),
-      _config->FindI("pkgProblemResolver::Scores::Extra",-2)
-   };
-   int PrioEssentials = _config->FindI("pkgProblemResolver::Scores::Essentials",100);
-   int PrioInstalledAndNotObsolete = _config->FindI("pkgProblemResolver::Scores::NotObsolete",1);
-   int DepMap[] = {
-      0,
-      _config->FindI("pkgProblemResolver::Scores::Depends",1),
-      _config->FindI("pkgProblemResolver::Scores::PreDepends",1),
-      _config->FindI("pkgProblemResolver::Scores::Suggests",0),
-      _config->FindI("pkgProblemResolver::Scores::Recommends",1),
-      _config->FindI("pkgProblemResolver::Scores::Conflicts",-1),
-      _config->FindI("pkgProblemResolver::Scores::Replaces",0),
-      _config->FindI("pkgProblemResolver::Scores::Obsoletes",0),
-      _config->FindI("pkgProblemResolver::Scores::Breaks",-1),
-      _config->FindI("pkgProblemResolver::Scores::Enhances",0)
-   };
-   int AddProtected = _config->FindI("pkgProblemResolver::Scores::AddProtected",10000);
-   int AddEssential = _config->FindI("pkgProblemResolver::Scores::AddEssential",5000);
-
-   if (_config->FindB("Debug::pkgProblemResolver::ShowScores",false) == true)
-      clog << "Settings used to calculate pkgProblemResolver::Scores::" << endl
-         << "  Required => " << PrioMap[pkgCache::State::Required] << endl
-         << "  Important => " << PrioMap[pkgCache::State::Important] << endl
-         << "  Standard => " << PrioMap[pkgCache::State::Standard] << endl
-         << "  Optional => " << PrioMap[pkgCache::State::Optional] << endl
-         << "  Extra => " << PrioMap[pkgCache::State::Extra] << endl
-         << "  Essentials => " << PrioEssentials << endl
-         << "  InstalledAndNotObsolete => " << PrioInstalledAndNotObsolete << endl
-         << "  Pre-Depends => " << DepMap[pkgCache::Dep::PreDepends] << endl
-         << "  Depends => " << DepMap[pkgCache::Dep::Depends] << endl
-         << "  Recommends => " << DepMap[pkgCache::Dep::Recommends] << endl
-         << "  Suggests => " << DepMap[pkgCache::Dep::Suggests] << endl
-         << "  Conflicts => " << DepMap[pkgCache::Dep::Conflicts] << endl
-         << "  Breaks => " << DepMap[pkgCache::Dep::DpkgBreaks] << endl
-         << "  Replaces => " << DepMap[pkgCache::Dep::Replaces] << endl
-         << "  Obsoletes => " << DepMap[pkgCache::Dep::Obsoletes] << endl
-         << "  Enhances => " << DepMap[pkgCache::Dep::Enhances] << endl
-         << "  AddProtected => " << AddProtected << endl
-         << "  AddEssential => " << AddEssential << endl;
-
-   // Generate the base scores for a package based on its properties
-   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
-   {
-      if (Cache[I].InstallVer == 0)
-	 continue;
-      
-      int &Score = Scores[I->ID];
-      
-      /* This is arbitrary, it should be high enough to elevate an
-         essantial package above most other packages but low enough
-	 to allow an obsolete essential packages to be removed by
-	 a conflicts on a powerful normal package (ie libc6) */
-      if ((I->Flags & pkgCache::Flag::Essential) == pkgCache::Flag::Essential
-	  || (I->Flags & pkgCache::Flag::Important) == pkgCache::Flag::Important)
-	 Score += PrioEssentials;
-
-      pkgCache::VerIterator const InstVer = Cache[I].InstVerIter(Cache);
-      // We apply priorities only to downloadable packages, all others are prio:extra
-      // as an obsolete prio:standard package can't be that standard anymore…
-      if (InstVer->Priority <= pkgCache::State::Extra && InstVer.Downloadable() == true)
-	 Score += PrioMap[InstVer->Priority];
-      else
-	 Score += PrioMap[pkgCache::State::Extra];
-
-      /* This helps to fix oddball problems with conflicting packages
-	 on the same level. We enhance the score of installed packages
-	 if those are not obsolete */
-      if (I->CurrentVer != 0 && Cache[I].CandidateVer != 0 && Cache[I].CandidateVerIter(Cache).Downloadable())
-	 Score += PrioInstalledAndNotObsolete;
-
-      // propagate score points along dependencies
-      for (pkgCache::DepIterator D = InstVer.DependsList(); D.end() == false; ++D)
-      {
-	 if (DepMap[D->Type] == 0)
-	    continue;
-	 pkgCache::PkgIterator const T = D.TargetPkg();
-	 if (D->Version != 0)
-	 {
-	    pkgCache::VerIterator const IV = Cache[T].InstVerIter(Cache);
-	    if (IV.end() == true || D.IsSatisfied(IV) == false)
-	       continue;
-	 }
-	 Scores[T->ID] += DepMap[D->Type];
-      }
-   }
-
-   // Copy the scores to advoid additive looping
-   std::unique_ptr<int[]> OldScores(new int[Size]);
-   memcpy(OldScores.get(),Scores,sizeof(*Scores)*Size);
-      
-   /* Now we cause 1 level of dependency inheritance, that is we add the 
-      score of the packages that depend on the target Package. This 
-      fortifies high scoring packages */
-   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
-   {
-      if (Cache[I].InstallVer == 0)
-	 continue;
-      
-      for (pkgCache::DepIterator D = I.RevDependsList(); D.end() == false; ++D)
-      {
-	 // Only do it for the install version
-	 if ((pkgCache::Version *)D.ParentVer() != Cache[D.ParentPkg()].InstallVer ||
-	     (D->Type != pkgCache::Dep::Depends && 
-	      D->Type != pkgCache::Dep::PreDepends &&
-	      D->Type != pkgCache::Dep::Recommends))
-	    continue;	 
-	 
-	 // Do not propagate negative scores otherwise
-	 // an extra (-2) package might score better than an optional (-1)
-	 if (OldScores[D.ParentPkg()->ID] > 0)
-	     Scores[I->ID] += OldScores[D.ParentPkg()->ID];
-      }      
-   }
-
-   /* Now we propagate along provides. This makes the packages that
-      provide important packages extremely important */
-   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
-   {
-      for (pkgCache::PrvIterator P = I.ProvidesList(); P.end() == false; ++P)
-      {
-	 // Only do it once per package
-	 if ((pkgCache::Version *)P.OwnerVer() != Cache[P.OwnerPkg()].InstallVer)
-	    continue;
-	 Scores[P.OwnerPkg()->ID] += abs(Scores[I->ID] - OldScores[I->ID]);
-      }
-   }
-
-   /* Protected things are pushed really high up. This number should put them
-      ahead of everything */
-   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
-   {
-      if ((Flags[I->ID] & Protected) != 0)
-	 Scores[I->ID] += AddProtected;
-      if ((I->Flags & pkgCache::Flag::Essential) == pkgCache::Flag::Essential ||
-          (I->Flags & pkgCache::Flag::Important) == pkgCache::Flag::Important)
-	 Scores[I->ID] += AddEssential;
-   }
-}
-									/*}}}*/
-// ProblemResolver::DoUpgrade - Attempt to upgrade this package		/*{{{*/
-// ---------------------------------------------------------------------
-/* This goes through and tries to reinstall packages to make this package
-   installable */
-bool pkgProblemResolver::DoUpgrade(pkgCache::PkgIterator Pkg)
-{
-   pkgDepCache::ActionGroup group(Cache);
-
-   if ((Flags[Pkg->ID] & Upgradable) == 0 || Cache[Pkg].Upgradable() == false)
-      return false;
-   if ((Flags[Pkg->ID] & Protected) == Protected)
-      return false;
-   
-   Flags[Pkg->ID] &= ~Upgradable;
-   
-   bool WasKept = Cache[Pkg].Keep();
-   if (not Cache.MarkInstall(Pkg, false, 0, false))
-     return false;
-
-   // This must be a virtual package or something like that.
-   if (Cache[Pkg].InstVerIter(Cache).end() == true)
-      return false;
-   
-   // Isolate the problem dependency
-   bool Fail = false;
-   for (pkgCache::DepIterator D = Cache[Pkg].InstVerIter(Cache).DependsList(); D.end() == false;)
-   {
-      // Compute a single dependency element (glob or)
-      pkgCache::DepIterator Start = D;
-      pkgCache::DepIterator End = D;
-      for (bool LastOR = true; D.end() == false && LastOR == true;)
-      {
-	 LastOR = (D->CompareOp & pkgCache::Dep::Or) == pkgCache::Dep::Or;
-	 ++D;
-	 if (LastOR == true)
-	    End = D;
-      }
-      
-      // We only worry about critical deps.
-      if (End.IsCritical() != true)
-	 continue;
-            
-      // Iterate over all the members in the or group
-      while (1)
-      {
-	 // Dep is ok now
-	 if ((Cache[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
-	    break;
-	 
-	 // Do not change protected packages
-	 PkgIterator P = Start.SmartTargetPkg();
-	 if (Cache[P].Protect())
-	 {
-	    if (Debug == true)
-	       clog << "    Reinst Failed because of protected " << P.FullName(false) << endl;
-	    Fail = true;
-	 }      
-	 else
-	 {
-	    // Upgrade the package if the candidate version will fix the problem.
-	    if ((Cache[Start] & pkgDepCache::DepCVer) == pkgDepCache::DepCVer)
-	    {
-	       if (DoUpgrade(P) == false)
-	       {
-		  if (Debug == true)
-		     clog << "    Reinst Failed because of " << P.FullName(false) << endl;
-		  Fail = true;
-	       }
-	       else
-	       {
-		  Fail = false;
-		  break;
-	       }	    
-	    }
-	    else
-	    {
-	       /* We let the algorithm deal with conflicts on its next iteration,
-		it is much smarter than us */
-	       if (Start.IsNegative() == true)
-		   break;
-	       
-	       if (Debug == true)
-		  clog << "    Reinst Failed early because of " << Start.TargetPkg().FullName(false) << endl;
-	       Fail = true;
-	    }     
-	 }
-	 
-	 if (Start == End)
-	    break;
-	 ++Start;
-      }
-      if (Fail == true)
-	 break;
-   }
-   
-   // Undo our operations - it might be smart to undo everything this did..
-   if (Fail == true)
-   {
-      if (WasKept == true)
-	 Cache.MarkKeep(Pkg, false, false);
-      else
-	 Cache.MarkDelete(Pkg, false, 0, false);
-      return false;
-   }	 
-   
-   if (Debug == true)
-      clog << "  Re-Instated " << Pkg.FullName(false) << endl;
-   return true;
-}
-									/*}}}*/
-// ProblemResolver::Resolve - calls a resolver to fix the situation	/*{{{*/
-bool pkgProblemResolver::Resolve(bool BrokenFix, OpProgress * const Progress)
-{
-   std::string const solver = _config->Find("APT::Solver", "internal");
-   auto const ret = EDSP::ResolveExternal(solver.c_str(), Cache, 0, Progress);
-   if (solver != "internal")
-      return ret;
-   return ResolveInternal(BrokenFix);
-}
-									/*}}}*/
-// ProblemResolver::ResolveInternal - Run the resolution pass		/*{{{*/
-// ---------------------------------------------------------------------
-/* This routines works by calculating a score for each package. The score
-   is derived by considering the package's priority and all reverse 
-   dependents giving an integer that reflects the amount of breakage that
-   adjusting the package will inflict. 
-      
-   It goes from highest score to lowest and corrects all of the breaks by 
-   keeping or removing the dependent packages. If that fails then it removes
-   the package itself and goes on. The routine should be able to intelligently
-   go from any broken state to a fixed state. 
- 
-   The BrokenFix flag enables a mode where the algorithm tries to 
-   upgrade packages to advoid problems. */
-bool pkgProblemResolver::ResolveInternal(bool const BrokenFix)
-{
-   pkgDepCache::ActionGroup group(Cache);
-
-   if (Debug)
-      Cache.CheckConsistency("resolve start");
-
-   // Record which packages are marked for install
-   bool Again = false;
-   do
-   {
-      Again = false;
-      for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
-      {
-	 if (Cache[I].Install() == true)
-	    Flags[I->ID] |= PreInstalled;
-	 else
-	 {
-	    if (Cache[I].InstBroken() == true && BrokenFix == true)
-	    {
-	       Cache.MarkInstall(I, false, 0, false);
-	       if (Cache[I].Install() == true)
-		  Again = true;
-	    }
-	    
-	    Flags[I->ID] &= ~PreInstalled;
-	 }
-	 Flags[I->ID] |= Upgradable;
-      }
-   }
-   while (Again == true);
-
-   if (Debug == true) {
-      clog << "Starting pkgProblemResolver with broken count: " 
-           << Cache.BrokenCount() << endl;
-   }
-   
-   MakeScores();
-
-   auto const Size = Cache.Head().PackageCount;
-
-   /* We have to order the packages so that the broken fixing pass 
-      operates from highest score to lowest. This prevents problems when
-      high score packages cause the removal of lower score packages that
-      would cause the removal of even lower score packages. */
-   std::unique_ptr<pkgCache::Package *[]> PList(new pkgCache::Package *[Size]);
-   pkgCache::Package **PEnd = PList.get();
-   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
-      *PEnd++ = I;
-
-   std::sort(PList.get(), PEnd, [this](Package *a, Package *b) { return ScoreSort(a, b) < 0; });
-
-   if (_config->FindB("Debug::pkgProblemResolver::ShowScores",false) == true)
-   {
-      clog << "Show Scores" << endl;
-      for (pkgCache::Package **K = PList.get(); K != PEnd; K++)
-         if (Scores[(*K)->ID] != 0)
-         {
-           pkgCache::PkgIterator Pkg(Cache,*K);
-           clog << Scores[(*K)->ID] << ' ' << APT::PrettyPkg(&Cache, Pkg) << std::endl;
-         }
-   }
-
-   if (Debug == true) {
-      clog << "Starting 2 pkgProblemResolver with broken count: " 
-           << Cache.BrokenCount() << endl;
-   }
-
-   /* Now consider all broken packages. For each broken package we either
-      remove the package or fix it's problem. We do this once, it should
-      not be possible for a loop to form (that is a < b < c and fixing b by
-      changing a breaks c) */
-   bool Change = true;
-   bool const TryFixByInstall = _config->FindB("pkgProblemResolver::FixByInstall", true);
-   std::vector<PackageKill> KillList;
-   for (int Counter = 0; Counter != 10 && Change == true; Counter++)
-   {
-      Change = false;
-      for (pkgCache::Package **K = PList.get(); K != PEnd; K++)
-      {
-	 pkgCache::PkgIterator I(Cache,*K);
-
-	 /* We attempt to install this and see if any breaks result,
-	    this takes care of some strange cases */
-	 if (Cache[I].CandidateVer != Cache[I].InstallVer &&
-	     I->CurrentVer != 0 && Cache[I].InstallVer != 0 &&
-	     (Flags[I->ID] & PreInstalled) != 0 &&
-	     not Cache[I].Protect() &&
-	     (Flags[I->ID] & ReInstateTried) == 0)
-	 {
-	    if (Debug == true)
-	       clog << " Try to Re-Instate (" << Counter << ") " << I.FullName(false) << endl;
-	    auto const OldBreaks = Cache.BrokenCount();
-	    pkgCache::Version *OldVer = Cache[I].InstallVer;
-	    Flags[I->ID] &= ReInstateTried;
-	    
-	    Cache.MarkInstall(I, false, 0, false);
-	    if (Cache[I].InstBroken() == true || 
-		OldBreaks < Cache.BrokenCount())
-	    {
-	       if (OldVer == 0)
-		  Cache.MarkDelete(I, false, 0, false);
-	       else
-		  Cache.MarkKeep(I, false, false);
-	    }	    
-	    else
-	       if (Debug == true)
-		  clog << "Re-Instated " << I.FullName(false) << " (" << OldBreaks << " vs " << Cache.BrokenCount() << ')' << endl;
-	 }
-	    
-	 if (Cache[I].InstallVer == 0 || Cache[I].InstBroken() == false)
-	    continue;
-	 
-	 if (Debug == true)
-	    clog << "Investigating (" << Counter << ") " << APT::PrettyPkg(&Cache, I) << endl;
-	 
-	 // Isolate the problem dependency
-	 bool InOr = false;
-	 pkgCache::DepIterator Start;
-	 pkgCache::DepIterator End;
-	 size_t OldSize = 0;
-
-	 KillList.resize(0);
-	 
-	 enum {OrRemove,OrKeep} OrOp = OrRemove;
-	 for (pkgCache::DepIterator D = Cache[I].InstVerIter(Cache).DependsList();
-	      D.end() == false || InOr == true;)
-	 {
-	    // Compute a single dependency element (glob or)
-	    if (Start == End)
-	    {
-	       // Decide what to do
-	       if (InOr == true && OldSize == KillList.size())
-	       {
-		  if (OrOp == OrRemove)
-		  {
-		     if (not Cache[I].Protect())
-		     {
-			if (Debug == true)
-			   clog << "  Or group remove for " << I.FullName(false) << endl;
-			Cache.MarkDelete(I, false, 0, false);
-			Change = true;
-		     }
-		  }
-		  else if (OrOp == OrKeep)
-		  {
-		     if (Debug == true)
-			clog << "  Or group keep for " << I.FullName(false) << endl;
-		     Cache.MarkKeep(I, false, false);
-		     Change = true;
-		  }
-	       }
-	       
-	       /* We do an extra loop (as above) to finalize the or group
-		  processing */
-	       InOr = false;
-	       OrOp = OrRemove;
-	       D.GlobOr(Start,End);
-	       if (Start.end() == true)
-		  break;
-
-	       // We only worry about critical deps.
-	       if (End.IsCritical() != true)
-		  continue;
-
-	       InOr = Start != End;
-	       OldSize = KillList.size();
-	    }
-	    else
-            {
-	       ++Start;
-	       // We only worry about critical deps.
-	       if (Start.IsCritical() != true)
-                  continue;
-            }
-
-	    // Dep is ok
-	    if ((Cache[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
-	    {
-	       InOr = false;
-	       continue;
-	    }
-	    
-	    if (Debug == true)
-	       clog << "Broken " << APT::PrettyDep(&Cache, Start) << endl;
-
-	    /* Look across the version list. If there are no possible
-	       targets then we keep the package and bail. This is necessary
-	       if a package has a dep on another package that can't be found */
-	    std::unique_ptr<pkgCache::Version *[]> VList(Start.AllTargets());
-	    if (VList[0] == 0 && not Cache[I].Protect() &&
-		Start.IsNegative() == false &&
-		Cache[I].NowBroken() == false)
-	    {	       
-	       if (InOr == true)
-	       {
-		  /* No keep choice because the keep being OK could be the
-		     result of another element in the OR group! */
-		  continue;
-	       }
-	       
-	       Change = true;
-	       Cache.MarkKeep(I, false, false);
-	       break;
-	    }
-	    
-	    bool Done = false;
-	    for (pkgCache::Version **V = VList.get(); *V != 0; V++)
-	    {
-	       pkgCache::VerIterator Ver(Cache,*V);
-	       pkgCache::PkgIterator Pkg = Ver.ParentPkg();
-
-               /* This is a conflicts, and the version we are looking
-                  at is not the currently selected version of the 
-                  package, which means it is not necessary to 
-                  remove/keep */
-               if (Cache[Pkg].InstallVer != Ver && Start.IsNegative() == true)
-               {
-                  if (Debug) 
-                     clog << "  Conflicts//Breaks against version " 
-                          << Ver.VerStr() << " for " << Pkg.Name() 
-                          << " but that is not InstVer, ignoring"
-                          << endl;
-                  continue;
-               }
-
-	       if (Debug == true)
-		  clog << "  Considering " << Pkg.FullName(false) << ' ' << Scores[Pkg->ID] <<
-		  " as a solution to " << I.FullName(false) << ' ' << Scores[I->ID] << endl;
-
-	       /* Try to fix the package under consideration rather than
-	          fiddle with the VList package */
-	       if (Scores[I->ID] <= Scores[Pkg->ID] ||
-		   ((Cache[Start] & pkgDepCache::DepNow) == 0 &&
-		    End.IsNegative() == false))
-	       {
-		  // Try a little harder to fix protected packages..
-		  if (Cache[I].Protect())
-		  {
-		     if (DoUpgrade(Pkg) == true)
-		     {
-			if (Scores[Pkg->ID] > Scores[I->ID])
-			   Scores[Pkg->ID] = Scores[I->ID];
-			break;
-		     }
-		     
-		     continue;
-		  }
-		  
-		  /* See if a keep will do, unless the package is protected,
-		     then installing it will be necessary */
-		  bool Installed = Cache[I].Install();
-		  Cache.MarkKeep(I, false, false);
-		  if (Cache[I].InstBroken() == false)
-		  {
-		     // Unwind operation will be keep now
-		     if (OrOp == OrRemove)
-			OrOp = OrKeep;
-		     
-		     // Restore
-		     if (InOr == true && Installed == true)
-			Cache.MarkInstall(I, false, 0, false);
-		     
-		     if (Debug == true)
-			clog << "  Holding Back " << I.FullName(false) << " rather than change " << Start.TargetPkg().FullName(false) << endl;
-		  }		  
-		  else
-		  {		     
-		     if (BrokenFix == false || DoUpgrade(I) == false)
-		     {
-			// Consider other options
-			if (InOr == false || Cache[I].Garbage == true)
-			{
-			   if (Debug == true)
-			      clog << "  Removing " << I.FullName(false) << " rather than change " << Start.TargetPkg().FullName(false) << endl;
-			   Cache.MarkDelete(I, false, 0, false);
-			   if (Counter > 1 && Scores[Pkg->ID] > Scores[I->ID])
-			      Scores[I->ID] = Scores[Pkg->ID];
-			}
-			else if (TryFixByInstall == true &&
-				 Start.TargetPkg()->CurrentVer == 0 &&
-				 Cache[Start.TargetPkg()].Delete() == false &&
-				 (Flags[Start.TargetPkg()->ID] & ToRemove) != ToRemove &&
-				 Cache.GetCandidateVersion(Start.TargetPkg()).end() == false)
-			{
-			   /* Before removing or keeping the package with the broken dependency
-			      try instead to install the first not previously installed package
-			      solving this dependency. This helps every time a previous solver
-			      is removed by the resolver because of a conflict or alike but it is
-			      dangerous as it could trigger new breaks/conflicts… */
-			   if (Debug == true)
-			      clog << "  Try Installing " << APT::PrettyPkg(&Cache, Start.TargetPkg()) << " before changing " << I.FullName(false) << std::endl;
-			   auto const OldBroken = Cache.BrokenCount();
-			   Cache.MarkInstall(Start.TargetPkg(), true, 1, false);
-			   // FIXME: we should undo the complete MarkInstall process here
-			   if (Cache[Start.TargetPkg()].InstBroken() == true || Cache.BrokenCount() > OldBroken)
-			      Cache.MarkDelete(Start.TargetPkg(), false, 1, false);
-			}
-		     }
-		  }
-		  		  
-		  Change = true;
-		  Done = true;
-		  break;
-	       }
-	       else
-	       {
-		  if (Start->Type == pkgCache::Dep::DpkgBreaks)
-		  {
-		     // first, try upgradring the package, if that
-		     // does not help, the breaks goes onto the
-		     // kill list
-                     //
-		     // FIXME: use DoUpgrade(Pkg) instead?
-		     if (Cache[End] & pkgDepCache::DepGCVer)
-		     {
-			if (Debug)
-			   clog << "  Upgrading " << Pkg.FullName(false) << " due to Breaks field in " << I.FullName(false) << endl;
-			Cache.MarkInstall(Pkg, false, 0, false);
-			continue;
-		     }
-		  }
-
-		  // Skip adding to the kill list if it is protected
-		  if (Cache[Pkg].Protect())
-		     continue;
-		
-		  if (Debug == true)
-		     clog << "  Added " << Pkg.FullName(false) << " to the remove list" << endl;
-
-		  KillList.push_back({Pkg, End});
-		  
-		  if (Start.IsNegative() == false)
-		     break;
-	       }
-	    }
-
-	    // Hm, nothing can possibly satisfy this dep. Nuke it.
-	    if (VList[0] == 0 &&
-		Start.IsNegative() == false &&
-		not Cache[I].Protect())
-	    {
-	       bool Installed = Cache[I].Install();
-	       Cache.MarkKeep(I);
-	       if (Cache[I].InstBroken() == false)
-	       {
-		  // Unwind operation will be keep now
-		  if (OrOp == OrRemove)
-		     OrOp = OrKeep;
-		  
-		  // Restore
-		  if (InOr == true && Installed == true)
-		     Cache.MarkInstall(I, false, 0, false);
-		  
-		  if (Debug == true)
-		     clog << "  Holding Back " << I.FullName(false) << " because I can't find " << Start.TargetPkg().FullName(false) << endl;
-	       }	       
-	       else
-	       {
-		  if (Debug == true)
-		     clog << "  Removing " << I.FullName(false) << " because I can't find " << Start.TargetPkg().FullName(false) << endl;
-		  if (InOr == false)
-		     Cache.MarkDelete(I, false, 0, false);
-	       }
-
-	       Change = true;
-	       Done = true;
-	    }
-	    
-	    // Try some more
-	    if (InOr == true)
-	       continue;
-	    
-	    if (Done == true)
-	       break;
-	 }
-	 
-	 // Apply the kill list now
-	 if (Cache[I].InstallVer != 0)
-	 {
-	    for (auto J = KillList.begin(); J != KillList.end(); J++)
-	    {
-	       Change = true;
-	       if ((Cache[J->Dep] & pkgDepCache::DepGNow) == 0)
-	       {
-		  if (J->Dep.IsNegative() == true)
-		  {
-		     if (Debug == true)
-			clog << "  Fixing " << I.FullName(false) << " via remove of " << J->Pkg.FullName(false) << endl;
-		     Cache.MarkDelete(J->Pkg, false, 0, false);
-		  }
-	       }
-	       else
-	       {
-		  if (Debug == true)
-		     clog << "  Fixing " << I.FullName(false) << " via keep of " << J->Pkg.FullName(false) << endl;
-		  Cache.MarkKeep(J->Pkg, false, false);
-	       }
-
-	       if (Counter > 1)
-	       {
-		  if (Scores[I->ID] > Scores[J->Pkg->ID])		  
-		     Scores[J->Pkg->ID] = Scores[I->ID];
-	       }	       
-	    }      
-	 }
-      }      
-   }
-
-   if (Debug == true)
-      clog << "Done" << endl;
-      
-   if (Cache.BrokenCount() != 0)
-   {
-      // See if this is the result of a hold
-      pkgCache::PkgIterator I = Cache.PkgBegin();
-      for (;I.end() != true; ++I)
-      {
-	 if (Cache[I].InstBroken() == false)
-	    continue;
-	 if (not Cache[I].Protect())
-	    return _error->Error(_("Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages."));
-      }
-      return _error->Error(_("Unable to correct problems, you have held broken packages."));
-   }
-   
-   // set the auto-flags (mvo: I'm not sure if we _really_ need this)
-   pkgCache::PkgIterator I = Cache.PkgBegin();
-   for (;I.end() != true; ++I) {
-      if (Cache[I].NewInstall() && !(Flags[I->ID] & PreInstalled)) {
-	 if(_config->FindB("Debug::pkgAutoRemove",false)) {
-	    std::clog << "Resolve installed new pkg: " << I.FullName(false) 
-		      << " (now marking it as auto)" << std::endl;
-	 }
-	 Cache[I].Flags |= pkgCache::Flag::Auto;
-      }
-   }
-
-   if (Debug)
-      Cache.CheckConsistency("resolve done");
-
-   return true;
-}
-									/*}}}*/
-// ProblemResolver::BreaksInstOrPolicy - Check if the given pkg is broken/*{{{*/
-// ---------------------------------------------------------------------
-/* This checks if the given package is broken either by a hard dependency
-   (InstBroken()) or by introducing a new policy breakage e.g. new
-   unsatisfied recommends for a package that was in "policy-good" state
-
-   Note that this is not perfect as it will ignore further breakage
-   for already broken policy (recommends)
-*/
-bool pkgProblemResolver::InstOrNewPolicyBroken(pkgCache::PkgIterator I)
-{
-   // a broken install is always a problem
-   if (Cache[I].InstBroken() == true)
-   {
-      if (Debug == true)
-	 std::clog << "  Dependencies are not satisfied for " << APT::PrettyPkg(&Cache, I) << std::endl;
-      return true;
-   }
-
-   // a newly broken policy (recommends/suggests) is a problem
-   if (Cache[I].NowPolicyBroken() == false &&
-       Cache[I].InstPolicyBroken() == true)
-   {
-      if (Debug == true)
-	 std::clog << "  Policy breaks with upgrade of " << APT::PrettyPkg(&Cache, I) << std::endl;
-      return true;
-   }
-
-   return false;
-}
-									/*}}}*/
-// ProblemResolver::ResolveByKeep - Resolve problems using keep		/*{{{*/
-// ---------------------------------------------------------------------
-/* This is the work horse of the soft upgrade routine. It is very gentle
-   in that it does not install or remove any packages. It is assumed that the
-   system was non-broken previously. */
-bool pkgProblemResolver::ResolveByKeep(OpProgress * const Progress)
-{
-   std::string const solver = _config->Find("APT::Solver", "internal");
-   constexpr auto flags = EDSP::Request::UPGRADE_ALL | EDSP::Request::FORBID_NEW_INSTALL | EDSP::Request::FORBID_REMOVE;
-   auto const ret = EDSP::ResolveExternal(solver.c_str(), Cache, flags, Progress);
-   if (solver != "internal")
-      return ret;
-   return ResolveByKeepInternal();
-}
-									/*}}}*/
-// ProblemResolver::ResolveByKeepInternal - Resolve problems using keep	/*{{{*/
-// ---------------------------------------------------------------------
-/* This is the work horse of the soft upgrade routine. It is very gentle
-   in that it does not install or remove any packages. It is assumed that the
-   system was non-broken previously. */
-bool pkgProblemResolver::ResolveByKeepInternal()
-{
-   pkgDepCache::ActionGroup group(Cache);
-
-   if (Debug)
-      Cache.CheckConsistency("keep start");
-
-   MakeScores();
-
-   /* We have to order the packages so that the broken fixing pass 
-      operates from highest score to lowest. This prevents problems when
-      high score packages cause the removal of lower score packages that
-      would cause the removal of even lower score packages. */
-   auto Size = Cache.Head().PackageCount;
-   pkgCache::Package **PList = new pkgCache::Package *[Size];
-   pkgCache::Package **PEnd = PList;
-   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
-      *PEnd++ = I;
-
-   std::sort(PList,PEnd,[this](Package *a, Package *b) { return ScoreSort(a, b) < 0; });
-
-
-   if (_config->FindB("Debug::pkgProblemResolver::ShowScores",false) == true)
-   {
-      clog << "Show Scores" << endl;
-      for (pkgCache::Package **K = PList; K != PEnd; K++)
-         if (Scores[(*K)->ID] != 0)
-         {
-           pkgCache::PkgIterator Pkg(Cache,*K);
-           clog << Scores[(*K)->ID] << ' ' << APT::PrettyPkg(&Cache, Pkg) << std::endl;
-         }
-   }
-
-   if (Debug == true)
-      clog << "Entering ResolveByKeep" << endl;
-
-   // Consider each broken package 
-   pkgCache::Package **LastStop = 0;
-   for (pkgCache::Package **K = PList; K != PEnd; K++)
-   {
-      pkgCache::PkgIterator I(Cache,*K);
-
-      if (Cache[I].InstallVer == 0)
-	 continue;
-
-      if (InstOrNewPolicyBroken(I) == false)
-         continue;
-
-      /* Keep the package. If this works then great, otherwise we have
-	 to be significantly more aggressive and manipulate its dependencies */
-      if (not Cache[I].Protect())
-      {
-	 if (Debug == true)
-	    clog << "Keeping package " << I.FullName(false) << endl;
-	 Cache.MarkKeep(I, false, false);
-	 if (InstOrNewPolicyBroken(I) == false)
-	 {
-	    K = PList - 1;
-	    continue;
-	 }
-      }
-      
-      // Isolate the problem dependencies
-      for (pkgCache::DepIterator D = Cache[I].InstVerIter(Cache).DependsList(); D.end() == false;)
-      {
-	 DepIterator Start;
-	 DepIterator End;
-	 D.GlobOr(Start,End);
-
-	 // We only worry about critical deps.
-	 if (End.IsCritical() != true)
-	    continue;
-	 
-	 // Dep is ok
-	 if ((Cache[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
-	    continue;
-
-	 /* Hm, the group is broken.. I suppose the best thing to do is to
-	    is to try every combination of keep/not-keep for the set, but that's
-	    slow, and this never happens, just be conservative and assume the
-	    list of ors is in preference and keep till it starts to work. */
-	 while (true)
-	 {
-	    if (Debug == true)
-	       clog << "Package " << I.FullName(false) << " " << APT::PrettyDep(&Cache, Start) << endl;
-
-	    // Look at all the possible provides on this package
-	    std::unique_ptr<pkgCache::Version *[]> VList(Start.AllTargets());
-	    for (pkgCache::Version **V = VList.get(); *V != 0; V++)
-	    {
-	       pkgCache::VerIterator Ver(Cache,*V);
-	       pkgCache::PkgIterator Pkg = Ver.ParentPkg();
-	       
-	       // It is not keepable
-	       if (Cache[Pkg].InstallVer == 0 ||
-		   Pkg->CurrentVer == 0)
-		  continue;
-	       
-	       if (not Cache[I].Protect())
-	       {
-		  if (Debug == true)
-		     clog << "  Keeping Package " << Pkg.FullName(false) << " due to " << Start.DepType() << endl;
-		  Cache.MarkKeep(Pkg, false, false);
-	       }
-	       
-	       if (InstOrNewPolicyBroken(I) == false)
-		  break;
-	    }
-	    
-	    if (InstOrNewPolicyBroken(I) == false)
-	       break;
-
-	    if (Start == End)
-	       break;
-	    ++Start;
-	 }
-	      
-	 if (InstOrNewPolicyBroken(I) == false)
-	    break;
-      }
-
-      if (InstOrNewPolicyBroken(I) == true)
-	 continue;
-      
-      // Restart again.
-      if (K == LastStop) {
-          // I is an iterator based off our temporary package list,
-          // so copy the name we need before deleting the temporary list
-          std::string const LoopingPackage = I.FullName(false);
-          delete[] PList;
-          return _error->Error("Internal Error, pkgProblemResolver::ResolveByKeep is looping on package %s.", LoopingPackage.c_str());
-      }
-      LastStop = K;
-      K = PList - 1;
-   }
-
-   delete[] PList;
-
-   if (Debug)
-      Cache.CheckConsistency("keep done");
-
-   return true;
-}
-									/*}}}*/
-// PrioSortList - Sort a list of versions by priority			/*{{{*/
-// ---------------------------------------------------------------------
-/* This is meant to be used in conjunction with AllTargets to get a list 
-   of versions ordered by preference. */
-
-struct PrioComp {
-   pkgCache &PrioCache;
-
-   explicit PrioComp(pkgCache &PrioCache) : PrioCache(PrioCache) {
-   }
-
-   bool operator() (pkgCache::Version * const &A, pkgCache::Version * const &B) {
-      return compare(A, B) < 0;
-   }
-
-   int compare(pkgCache::Version * const &A, pkgCache::Version * const &B) {
-      pkgCache::VerIterator L(PrioCache,A);
-      pkgCache::VerIterator R(PrioCache,B);
-
-      if ((L.ParentPkg()->Flags & pkgCache::Flag::Essential) == pkgCache::Flag::Essential &&
-	  (R.ParentPkg()->Flags & pkgCache::Flag::Essential) != pkgCache::Flag::Essential)
-	return 1;
-      if ((L.ParentPkg()->Flags & pkgCache::Flag::Essential) != pkgCache::Flag::Essential &&
-	  (R.ParentPkg()->Flags & pkgCache::Flag::Essential) == pkgCache::Flag::Essential)
-	return -1;
-
-      if ((L.ParentPkg()->Flags & pkgCache::Flag::Important) == pkgCache::Flag::Important &&
-	  (R.ParentPkg()->Flags & pkgCache::Flag::Important) != pkgCache::Flag::Important)
-	return 1;
-      if ((L.ParentPkg()->Flags & pkgCache::Flag::Important) != pkgCache::Flag::Important &&
-	  (R.ParentPkg()->Flags & pkgCache::Flag::Important) == pkgCache::Flag::Important)
-	return -1;
-
-      if (L->Priority != R->Priority)
-	 return R->Priority - L->Priority;
-      return strcmp(L.ParentPkg().Name(),R.ParentPkg().Name());
-   }
-};
-
-void pkgPrioSortList(pkgCache &Cache,pkgCache::Version **List)
-{
-   unsigned long Count = 0;
-   for (pkgCache::Version **I = List; *I != 0; I++)
-      Count++;
-   std::sort(List,List+Count,PrioComp(Cache));
-}
-									/*}}}*/
diff -urN apt-2.1.5/apt-pkg/algorithms.h apt/apt-pkg/algorithms.h
--- apt-2.1.5/apt-pkg/algorithms.h	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/algorithms.h	2020-06-02 23:06:58.398093103 -0400
@@ -77,6 +77,9 @@
 private:
    APT_HIDDEN void ShortBreaks();
    APT_HIDDEN void Describe(PkgIterator iPkg,std::ostream &out,bool Current,bool Candidate);
+#if ENABLE_SILEO
+   APT_HIDDEN NSMutableDictionary * DescribeSileo(PkgIterator iPkg,bool Current,bool Candidate);
+#endif
    APT_HIDDEN bool RealInstall(PkgIterator Pkg,std::string File);
    APT_HIDDEN bool RealConfigure(PkgIterator Pkg);
    APT_HIDDEN bool RealRemove(PkgIterator Pkg,bool Purge);
diff -urN apt-2.1.5/apt-pkg/algorithms.mm apt/apt-pkg/algorithms.mm
--- apt-2.1.5/apt-pkg/algorithms.mm	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/algorithms.mm	2020-06-02 23:06:58.398093103 -0400
@@ -0,0 +1,1506 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+/* ######################################################################
+
+   Algorithms - A set of misc algorithms
+
+   The pkgProblemResolver class has become insanely complex and
+   very sophisticated, it handles every test case I have thrown at it
+   to my satisfaction. Understanding exactly why all the steps the class
+   does are required is difficult and changing though not very risky
+   may result in other cases not working.
+   
+   ##################################################################### */
+									/*}}}*/
+// Include Files							/*{{{*/
+#include <config.h>
+
+#define ENABLE_SILEO 1
+#include <Foundation/Foundation.h>
+
+#include <apt-pkg/algorithms.h>
+#include <apt-pkg/configuration.h>
+#include <apt-pkg/depcache.h>
+#include <apt-pkg/dpkgpm.h>
+#include <apt-pkg/edsp.h>
+#include <apt-pkg/error.h>
+#include <apt-pkg/packagemanager.h>
+#include <apt-pkg/pkgcache.h>
+#include <apt-pkg/prettyprinters.h>
+
+#include <cstdlib>
+#include <iostream>
+#include <string>
+#include <utility>
+#include <string.h>
+
+#include <apti18n.h>
+									/*}}}*/
+using namespace std;
+
+class APT_HIDDEN pkgSimulatePrivate
+{
+public:
+   std::vector<pkgDPkgPM::Item> List;
+};
+// Simulate::Simulate - Constructor					/*{{{*/
+// ---------------------------------------------------------------------
+/* The legacy translations here of input Pkg iterators is obsolete, 
+   this is not necessary since the pkgCaches are fully shared now. */
+pkgSimulate::pkgSimulate(pkgDepCache *Cache) : pkgPackageManager(Cache),
+		            d(new pkgSimulatePrivate()), iPolicy(Cache),
+			    Sim(&Cache->GetCache(),&iPolicy),
+			    group(Sim)
+{
+   Sim.Init(0);
+   auto PackageCount = Cache->Head().PackageCount;
+   Flags = new unsigned char[PackageCount];
+   memset(Flags,0,sizeof(*Flags)*PackageCount);
+
+   // Fake a filename so as not to activate the media swapping
+   string Jnk = "SIMULATE";
+   for (decltype(PackageCount) I = 0; I != PackageCount; ++I)
+      FileNames[I] = Jnk;
+
+   Cache->CheckConsistency("simulate");
+}
+									/*}}}*/
+// Simulate::~Simulate - Destructor					/*{{{*/
+pkgSimulate::~pkgSimulate()
+{
+   delete[] Flags;
+   delete d;
+}
+									/*}}}*/
+// Simulate::Describe - Describe a package				/*{{{*/
+// ---------------------------------------------------------------------
+/* Parameter Current == true displays the current package version,
+   Parameter Candidate == true displays the candidate package version */
+void pkgSimulate::Describe(PkgIterator Pkg,ostream &out,bool Current,bool Candidate)
+{
+   VerIterator Ver(Sim);
+ 
+   out << Pkg.FullName(true);
+
+   if (Current == true)
+   {
+      Ver = Pkg.CurrentVer();
+      if (Ver.end() == false)
+         out << " [" << Ver.VerStr() << ']';
+   }
+
+   if (Candidate == true)
+   {
+      Ver = Sim[Pkg].CandidateVerIter(Sim);
+      if (Ver.end() == true)
+         return;
+   
+      out << " (" << Ver.VerStr() << ' ' << Ver.RelStr() << ')';
+   }
+}
+									/*}}}*/
+// Simulate::DescribeSileo - Describe a package            /*{{{*/
+// ---------------------------------------------------------------------
+/* Parameter Current == true displays the current package version,
+   Parameter Candidate == true displays the candidate package version */
+NSMutableDictionary * pkgSimulate::DescribeSileo(PkgIterator Pkg,bool Current,bool Candidate)
+{
+   VerIterator Ver(Sim);
+
+   NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];
+   [dictionary setObject:[NSString stringWithUTF8String:Pkg.FullName(true).c_str()] forKey:@"Package"];
+
+   if (Current == true)
+   {
+      Ver = Pkg.CurrentVer();
+      if (Ver.end() == false){
+         [dictionary setObject:[NSString stringWithUTF8String:Ver.VerStr()] forKey:@"Version"];
+      }
+   }
+
+   if (Candidate == true)
+   {
+      Ver = Sim[Pkg].CandidateVerIter(Sim);
+      if (Ver.end() == true)
+         return dictionary;
+      [dictionary setObject:[NSString stringWithUTF8String:Ver.VerStr()] forKey:@"Version"];
+      [dictionary setObject:[NSString stringWithUTF8String:Ver.RelStr().c_str()] forKey:@"Release"];
+   }
+
+   return dictionary;
+}
+                           /*}}}*/
+// Simulate::Install - Simulate unpacking of a package			/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool pkgSimulate::Install(PkgIterator iPkg,string File)
+{
+   if (iPkg.end() || File.empty())
+      return false;
+   d->List.emplace_back(pkgDPkgPM::Item::Install, iPkg, File);
+   return true;
+}
+bool pkgSimulate::RealInstall(PkgIterator iPkg,string /*File*/)
+{
+   bool forSileo = _config->FindB("APT::Format::for-sileo", false);
+   if (forSileo){
+      // Adapt the iterator
+      PkgIterator Pkg = Sim.FindPkg(iPkg.Name(), iPkg.Arch());
+      Flags[Pkg->ID] = 1;
+
+      NSMutableDictionary *package = DescribeSileo(Pkg, true, true);
+      [package setObject:@"Inst" forKey:@"Type"];
+
+      cout << flush;
+
+      NSData *data = [NSJSONSerialization dataWithJSONObject:package options:0 error:nil];
+      NSFileHandle *stdout = [NSFileHandle fileHandleWithStandardOutput];
+      [stdout writeData:data];
+
+      cout << endl;
+
+      Sim.MarkInstall(Pkg,false);
+
+      // Look for broken conflicts+predepends.
+      for (PkgIterator I = Sim.PkgBegin(); I.end() == false; ++I)
+      {
+         if (Sim[I].InstallVer == 0)
+            continue;
+
+         for (DepIterator D = Sim[I].InstVerIter(Sim).DependsList(); D.end() == false;)
+         {
+            DepIterator Start;
+            DepIterator End;
+            D.GlobOr(Start,End);
+            if (Start.IsNegative() == true || End->Type == pkgCache::Dep::PreDepends)
+            {
+               if ((Sim[End] & pkgDepCache::DepGInstall) == 0)
+               {
+                  if (Start->Type == pkgCache::Dep::Conflicts)
+                     _error->Error("Fatal, conflicts violated %s",I.FullName(false).c_str());
+               }     
+            }
+         }      
+      }
+      return true;
+   }
+
+   // Adapt the iterator
+   PkgIterator Pkg = Sim.FindPkg(iPkg.Name(), iPkg.Arch());
+   Flags[Pkg->ID] = 1;
+   
+   cout << "Inst ";
+   Describe(Pkg,cout,true,true);
+   Sim.MarkInstall(Pkg,false);
+
+   // Look for broken conflicts+predepends.
+   for (PkgIterator I = Sim.PkgBegin(); I.end() == false; ++I)
+   {
+      if (Sim[I].InstallVer == 0)
+	 continue;
+      
+      for (DepIterator D = Sim[I].InstVerIter(Sim).DependsList(); D.end() == false;)
+      {
+	 DepIterator Start;
+	 DepIterator End;
+	 D.GlobOr(Start,End);
+	 if (Start.IsNegative() == true ||
+	     End->Type == pkgCache::Dep::PreDepends)
+         {
+	    if ((Sim[End] & pkgDepCache::DepGInstall) == 0)
+	    {
+	       cout << " [" << I.FullName(false) << " on " << Start.TargetPkg().FullName(false) << ']';
+	       if (Start->Type == pkgCache::Dep::Conflicts)
+		  _error->Error("Fatal, conflicts violated %s",I.FullName(false).c_str());
+	    }	    
+	 }
+      }      
+   }
+
+   if (Sim.BrokenCount() != 0)
+      ShortBreaks();
+   else
+      cout << endl;
+   return true;
+}
+									/*}}}*/
+// Simulate::Configure - Simulate configuration of a Package		/*{{{*/
+// ---------------------------------------------------------------------
+/* This is not an accurate simulation of relatity, we should really not
+   install the package.. For some investigations it may be necessary 
+   however. */
+bool pkgSimulate::Configure(PkgIterator iPkg)
+{
+   if (iPkg.end())
+      return false;
+   d->List.emplace_back(pkgDPkgPM::Item::Configure, iPkg);
+   return true;
+}
+bool pkgSimulate::RealConfigure(PkgIterator iPkg)
+{
+   bool forSileo = _config->FindB("APT::Format::for-sileo", false);
+
+   // Adapt the iterator
+   PkgIterator Pkg = Sim.FindPkg(iPkg.Name(), iPkg.Arch());
+   
+   Flags[Pkg->ID] = 2;
+
+   if (!forSileo){
+      if (Sim[Pkg].InstBroken() == true)
+      {
+         cout << "Conf " << Pkg.FullName(false) << " broken" << endl;
+
+         Sim.Update();
+         
+         // Print out each package and the failed dependencies
+         for (pkgCache::DepIterator D = Sim[Pkg].InstVerIter(Sim).DependsList(); D.end() == false; ++D)
+         {
+   	 if (Sim.IsImportantDep(D) == false || 
+   	     (Sim[D] & pkgDepCache::DepInstall) != 0)
+   	    continue;
+   	 
+   	 if (D->Type == pkgCache::Dep::Obsoletes)
+   	    cout << " Obsoletes:" << D.TargetPkg().FullName(false);
+   	 else if (D->Type == pkgCache::Dep::Conflicts)
+   	    cout << " Conflicts:" << D.TargetPkg().FullName(false);
+   	 else if (D->Type == pkgCache::Dep::DpkgBreaks)
+   	    cout << " Breaks:" << D.TargetPkg().FullName(false);
+   	 else
+   	    cout << " Depends:" << D.TargetPkg().FullName(false);
+         }	    
+         cout << endl;
+
+         _error->Error("Conf Broken %s",Pkg.FullName(false).c_str());
+      }   
+      else
+      {
+         cout << "Conf "; 
+         Describe(Pkg,cout,false,true);
+      }
+
+      if (Sim.BrokenCount() != 0)
+         ShortBreaks();
+      else
+         cout << endl;
+   }
+   
+   return true;
+}
+									/*}}}*/
+// Simulate::Remove - Simulate the removal of a package			/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool pkgSimulate::Remove(PkgIterator iPkg,bool Purge)
+{
+   if (iPkg.end())
+      return false;
+   d->List.emplace_back(Purge ? pkgDPkgPM::Item::Purge : pkgDPkgPM::Item::Remove, iPkg);
+   return true;
+}
+bool pkgSimulate::RealRemove(PkgIterator iPkg,bool Purge)
+{
+   bool forSileo = _config->FindB("APT::Format::for-sileo", false);
+
+   // Adapt the iterator
+   PkgIterator Pkg = Sim.FindPkg(iPkg.Name(), iPkg.Arch());
+   if (Pkg.end() == true)
+   {
+      std::cerr << (Purge ? "Purg" : "Remv") << " invalid package " << iPkg.FullName() << std::endl;
+      return false;
+   }
+
+   Flags[Pkg->ID] = 3;
+   Sim.MarkDelete(Pkg);
+
+   if (forSileo){
+      NSMutableDictionary *package = DescribeSileo(Pkg, true, false);
+      if (Purge == true)
+         [package setObject:@"Purg" forKey:@"Type"];
+      else
+         [package setObject:@"Remv" forKey:@"Type"];
+
+      cout << flush;
+
+      NSData *data = [NSJSONSerialization dataWithJSONObject:package options:0 error:nil];
+      NSFileHandle *stdout = [NSFileHandle fileHandleWithStandardOutput];
+      [stdout writeData:data];
+
+      cout << endl;
+   } else {
+      if (Purge == true)
+         cout << "Purg ";
+      else
+         cout << "Remv ";
+      Describe(Pkg,cout,true,false);
+
+      if (Sim.BrokenCount() != 0)
+         ShortBreaks();
+      else
+         cout << endl;
+   }
+
+   return true;
+}
+									/*}}}*/
+// Simulate::ShortBreaks - Print out a short line describing all breaks	/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void pkgSimulate::ShortBreaks()
+{
+   cout << " [";
+   for (PkgIterator I = Sim.PkgBegin(); I.end() == false; ++I)
+   {
+      if (Sim[I].InstBroken() == true)
+      {
+	 if (Flags[I->ID] == 0)
+	    cout << I.FullName(false) << ' ';
+/*	 else
+	    cout << I.Name() << "! ";*/
+      }      
+   }
+   cout << ']' << endl;
+}
+									/*}}}*/
+bool pkgSimulate::Go(APT::Progress::PackageManager *)			/*{{{*/
+{
+   if (pkgDPkgPM::ExpandPendingCalls(d->List, Cache) == false)
+      return false;
+   for (auto && I : d->List)
+      switch (I.Op)
+      {
+	 case pkgDPkgPM::Item::Install:
+	    if (RealInstall(I.Pkg, I.File) == false)
+	       return false;
+	    break;
+	 case pkgDPkgPM::Item::Configure:
+	    if (RealConfigure(I.Pkg) == false)
+	       return false;
+	    break;
+	 case pkgDPkgPM::Item::Remove:
+	    if (RealRemove(I.Pkg, false) == false)
+	       return false;
+	    break;
+	 case pkgDPkgPM::Item::Purge:
+	    if (RealRemove(I.Pkg, true) == false)
+	       return false;
+	    break;
+	 case pkgDPkgPM::Item::ConfigurePending:
+	 case pkgDPkgPM::Item::TriggersPending:
+	 case pkgDPkgPM::Item::RemovePending:
+	 case pkgDPkgPM::Item::PurgePending:
+	    return _error->Error("Internal error, simulation encountered unexpected pending item");
+      }
+   return true;
+}
+									/*}}}*/
+// ApplyStatus - Adjust for non-ok packages				/*{{{*/
+// ---------------------------------------------------------------------
+/* We attempt to change the state of the all packages that have failed
+   installation toward their real state. The ordering code will perform 
+   the necessary calculations to deal with the problems. */
+bool pkgApplyStatus(pkgDepCache &Cache)
+{
+   pkgDepCache::ActionGroup group(Cache);
+
+   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
+   {
+      if (I->VersionList == 0)
+	 continue;
+	 
+      // Only choice for a ReInstReq package is to reinstall
+      if (I->InstState == pkgCache::State::ReInstReq ||
+	  I->InstState == pkgCache::State::HoldReInstReq)
+      {
+	 if (I->CurrentVer != 0 && I.CurrentVer().Downloadable() == true)
+	    Cache.MarkKeep(I, false, false);
+	 else
+	 {
+	    // Is this right? Will dpkg choke on an upgrade?
+	    if (Cache[I].CandidateVer != 0 &&
+		 Cache[I].CandidateVerIter(Cache).Downloadable() == true)
+	       Cache.MarkInstall(I, false, 0, false);
+	    else
+	       return _error->Error(_("The package %s needs to be reinstalled, "
+				    "but I can't find an archive for it."),I.FullName(true).c_str());
+	 }
+	 
+	 continue;
+      }
+      
+      switch (I->CurrentState)
+      {
+	 /* This means installation failed somehow - it does not need to be
+	    re-unpacked (probably) */
+	 case pkgCache::State::UnPacked:
+	 case pkgCache::State::HalfConfigured:
+	 case pkgCache::State::TriggersAwaited:
+	 case pkgCache::State::TriggersPending:
+	 if ((I->CurrentVer != 0 && I.CurrentVer().Downloadable() == true) ||
+	     I.State() != pkgCache::PkgIterator::NeedsUnpack)
+	    Cache.MarkKeep(I, false, false);
+	 else
+	 {
+	    if (Cache[I].CandidateVer != 0 &&
+		 Cache[I].CandidateVerIter(Cache).Downloadable() == true)
+	       Cache.MarkInstall(I, true, 0, false);
+	    else
+	       Cache.MarkDelete(I, false, 0, false);
+	 }
+	 break;
+
+	 // This means removal failed
+	 case pkgCache::State::HalfInstalled:
+	 Cache.MarkDelete(I, false, 0, false);
+	 break;
+	 
+	 default:
+	 if (I->InstState != pkgCache::State::Ok)
+	    return _error->Error("The package %s is not ok and I "
+				 "don't know how to fix it!",I.FullName(false).c_str());
+      }
+   }
+   return true;
+}
+									/*}}}*/
+// FixBroken - Fix broken packages					/*{{{*/
+// ---------------------------------------------------------------------
+/* This autoinstalls every broken package and then runs the problem resolver
+   on the result. */
+bool pkgFixBroken(pkgDepCache &Cache)
+{
+   pkgDepCache::ActionGroup group(Cache);
+
+   // Auto upgrade all broken packages
+   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
+      if (Cache[I].NowBroken() == true)
+	 Cache.MarkInstall(I, true, 0, false);
+   
+   /* Fix packages that are in a NeedArchive state but don't have a
+      downloadable install version */
+   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
+   {
+      if (I.State() != pkgCache::PkgIterator::NeedsUnpack ||
+	  Cache[I].Delete() == true)
+	 continue;
+      
+      if (Cache[I].InstVerIter(Cache).Downloadable() == false)
+	 continue;
+
+      Cache.MarkInstall(I, true, 0, false);
+   }
+   
+   pkgProblemResolver Fix(&Cache);
+   return Fix.Resolve(true);
+}
+									/*}}}*/
+// ProblemResolver::pkgProblemResolver - Constructor			/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+pkgProblemResolver::pkgProblemResolver(pkgDepCache *pCache) : d(NULL), Cache(*pCache)
+{
+   // Allocate memory
+   auto const Size = Cache.Head().PackageCount;
+   Scores = new int[Size];
+   Flags = new unsigned char[Size];
+   memset(Flags,0,sizeof(*Flags)*Size);
+   
+   // Set debug to true to see its decision logic
+   Debug = _config->FindB("Debug::pkgProblemResolver",false);
+}
+									/*}}}*/
+// ProblemResolver::~pkgProblemResolver - Destructor			/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+pkgProblemResolver::~pkgProblemResolver()
+{
+   delete [] Scores;
+   delete [] Flags;
+}
+									/*}}}*/
+// ProblemResolver::ScoreSort - Sort the list by score			/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+int pkgProblemResolver::ScoreSort(Package const *A,Package const *B)
+{
+   if (Scores[A->ID] > Scores[B->ID])
+      return -1;
+   if (Scores[A->ID] < Scores[B->ID])
+      return 1;
+   return 0;
+}
+									/*}}}*/
+// ProblemResolver::MakeScores - Make the score table			/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void pkgProblemResolver::MakeScores()
+{
+   auto const Size = Cache.Head().PackageCount;
+   memset(Scores,0,sizeof(*Scores)*Size);
+
+   // maps to pkgCache::State::VerPriority: 
+   //    Required Important Standard Optional Extra
+   int PrioMap[] = {
+      0,
+      _config->FindI("pkgProblemResolver::Scores::Required",3),
+      _config->FindI("pkgProblemResolver::Scores::Important",2),
+      _config->FindI("pkgProblemResolver::Scores::Standard",1),
+      _config->FindI("pkgProblemResolver::Scores::Optional",-1),
+      _config->FindI("pkgProblemResolver::Scores::Extra",-2)
+   };
+   int PrioEssentials = _config->FindI("pkgProblemResolver::Scores::Essentials",100);
+   int PrioInstalledAndNotObsolete = _config->FindI("pkgProblemResolver::Scores::NotObsolete",1);
+   int DepMap[] = {
+      0,
+      _config->FindI("pkgProblemResolver::Scores::Depends",1),
+      _config->FindI("pkgProblemResolver::Scores::PreDepends",1),
+      _config->FindI("pkgProblemResolver::Scores::Suggests",0),
+      _config->FindI("pkgProblemResolver::Scores::Recommends",1),
+      _config->FindI("pkgProblemResolver::Scores::Conflicts",-1),
+      _config->FindI("pkgProblemResolver::Scores::Replaces",0),
+      _config->FindI("pkgProblemResolver::Scores::Obsoletes",0),
+      _config->FindI("pkgProblemResolver::Scores::Breaks",-1),
+      _config->FindI("pkgProblemResolver::Scores::Enhances",0)
+   };
+   int AddProtected = _config->FindI("pkgProblemResolver::Scores::AddProtected",10000);
+   int AddEssential = _config->FindI("pkgProblemResolver::Scores::AddEssential",5000);
+
+   if (_config->FindB("Debug::pkgProblemResolver::ShowScores",false) == true)
+      clog << "Settings used to calculate pkgProblemResolver::Scores::" << endl
+         << "  Required => " << PrioMap[pkgCache::State::Required] << endl
+         << "  Important => " << PrioMap[pkgCache::State::Important] << endl
+         << "  Standard => " << PrioMap[pkgCache::State::Standard] << endl
+         << "  Optional => " << PrioMap[pkgCache::State::Optional] << endl
+         << "  Extra => " << PrioMap[pkgCache::State::Extra] << endl
+         << "  Essentials => " << PrioEssentials << endl
+         << "  InstalledAndNotObsolete => " << PrioInstalledAndNotObsolete << endl
+         << "  Pre-Depends => " << DepMap[pkgCache::Dep::PreDepends] << endl
+         << "  Depends => " << DepMap[pkgCache::Dep::Depends] << endl
+         << "  Recommends => " << DepMap[pkgCache::Dep::Recommends] << endl
+         << "  Suggests => " << DepMap[pkgCache::Dep::Suggests] << endl
+         << "  Conflicts => " << DepMap[pkgCache::Dep::Conflicts] << endl
+         << "  Breaks => " << DepMap[pkgCache::Dep::DpkgBreaks] << endl
+         << "  Replaces => " << DepMap[pkgCache::Dep::Replaces] << endl
+         << "  Obsoletes => " << DepMap[pkgCache::Dep::Obsoletes] << endl
+         << "  Enhances => " << DepMap[pkgCache::Dep::Enhances] << endl
+         << "  AddProtected => " << AddProtected << endl
+         << "  AddEssential => " << AddEssential << endl;
+
+   // Generate the base scores for a package based on its properties
+   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
+   {
+      if (Cache[I].InstallVer == 0)
+	 continue;
+      
+      int &Score = Scores[I->ID];
+      
+      /* This is arbitrary, it should be high enough to elevate an
+         essantial package above most other packages but low enough
+	 to allow an obsolete essential packages to be removed by
+	 a conflicts on a powerful normal package (ie libc6) */
+      if ((I->Flags & pkgCache::Flag::Essential) == pkgCache::Flag::Essential
+	  || (I->Flags & pkgCache::Flag::Important) == pkgCache::Flag::Important)
+	 Score += PrioEssentials;
+
+      pkgCache::VerIterator const InstVer = Cache[I].InstVerIter(Cache);
+      // We apply priorities only to downloadable packages, all others are prio:extra
+      // as an obsolete prio:standard package can't be that standard anymore…
+      if (InstVer->Priority <= pkgCache::State::Extra && InstVer.Downloadable() == true)
+	 Score += PrioMap[InstVer->Priority];
+      else
+	 Score += PrioMap[pkgCache::State::Extra];
+
+      /* This helps to fix oddball problems with conflicting packages
+	 on the same level. We enhance the score of installed packages
+	 if those are not obsolete */
+      if (I->CurrentVer != 0 && Cache[I].CandidateVer != 0 && Cache[I].CandidateVerIter(Cache).Downloadable())
+	 Score += PrioInstalledAndNotObsolete;
+
+      // propagate score points along dependencies
+      for (pkgCache::DepIterator D = InstVer.DependsList(); D.end() == false; ++D)
+      {
+	 if (DepMap[D->Type] == 0)
+	    continue;
+	 pkgCache::PkgIterator const T = D.TargetPkg();
+	 if (D->Version != 0)
+	 {
+	    pkgCache::VerIterator const IV = Cache[T].InstVerIter(Cache);
+	    if (IV.end() == true || D.IsSatisfied(IV) == false)
+	       continue;
+	 }
+	 Scores[T->ID] += DepMap[D->Type];
+      }
+   }
+
+   // Copy the scores to advoid additive looping
+   std::unique_ptr<int[]> OldScores(new int[Size]);
+   memcpy(OldScores.get(),Scores,sizeof(*Scores)*Size);
+      
+   /* Now we cause 1 level of dependency inheritance, that is we add the 
+      score of the packages that depend on the target Package. This 
+      fortifies high scoring packages */
+   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
+   {
+      if (Cache[I].InstallVer == 0)
+	 continue;
+      
+      for (pkgCache::DepIterator D = I.RevDependsList(); D.end() == false; ++D)
+      {
+	 // Only do it for the install version
+	 if ((pkgCache::Version *)D.ParentVer() != Cache[D.ParentPkg()].InstallVer ||
+	     (D->Type != pkgCache::Dep::Depends && 
+	      D->Type != pkgCache::Dep::PreDepends &&
+	      D->Type != pkgCache::Dep::Recommends))
+	    continue;	 
+	 
+	 // Do not propagate negative scores otherwise
+	 // an extra (-2) package might score better than an optional (-1)
+	 if (OldScores[D.ParentPkg()->ID] > 0)
+	     Scores[I->ID] += OldScores[D.ParentPkg()->ID];
+      }      
+   }
+
+   /* Now we propagate along provides. This makes the packages that
+      provide important packages extremely important */
+   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
+   {
+      for (pkgCache::PrvIterator P = I.ProvidesList(); P.end() == false; ++P)
+      {
+	 // Only do it once per package
+	 if ((pkgCache::Version *)P.OwnerVer() != Cache[P.OwnerPkg()].InstallVer)
+	    continue;
+	 Scores[P.OwnerPkg()->ID] += abs(Scores[I->ID] - OldScores[I->ID]);
+      }
+   }
+
+   /* Protected things are pushed really high up. This number should put them
+      ahead of everything */
+   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
+   {
+      if ((Flags[I->ID] & Protected) != 0)
+	 Scores[I->ID] += AddProtected;
+      if ((I->Flags & pkgCache::Flag::Essential) == pkgCache::Flag::Essential ||
+          (I->Flags & pkgCache::Flag::Important) == pkgCache::Flag::Important)
+	 Scores[I->ID] += AddEssential;
+   }
+}
+									/*}}}*/
+// ProblemResolver::DoUpgrade - Attempt to upgrade this package		/*{{{*/
+// ---------------------------------------------------------------------
+/* This goes through and tries to reinstall packages to make this package
+   installable */
+bool pkgProblemResolver::DoUpgrade(pkgCache::PkgIterator Pkg)
+{
+   pkgDepCache::ActionGroup group(Cache);
+
+   if ((Flags[Pkg->ID] & Upgradable) == 0 || Cache[Pkg].Upgradable() == false)
+      return false;
+   if ((Flags[Pkg->ID] & Protected) == Protected)
+      return false;
+   
+   Flags[Pkg->ID] &= ~Upgradable;
+   
+   bool WasKept = Cache[Pkg].Keep();
+   if (not Cache.MarkInstall(Pkg, false, 0, false))
+     return false;
+
+   // This must be a virtual package or something like that.
+   if (Cache[Pkg].InstVerIter(Cache).end() == true)
+      return false;
+   
+   // Isolate the problem dependency
+   bool Fail = false;
+   for (pkgCache::DepIterator D = Cache[Pkg].InstVerIter(Cache).DependsList(); D.end() == false;)
+   {
+      // Compute a single dependency element (glob or)
+      pkgCache::DepIterator Start = D;
+      pkgCache::DepIterator End = D;
+      for (bool LastOR = true; D.end() == false && LastOR == true;)
+      {
+	 LastOR = (D->CompareOp & pkgCache::Dep::Or) == pkgCache::Dep::Or;
+	 ++D;
+	 if (LastOR == true)
+	    End = D;
+      }
+      
+      // We only worry about critical deps.
+      if (End.IsCritical() != true)
+	 continue;
+            
+      // Iterate over all the members in the or group
+      while (1)
+      {
+	 // Dep is ok now
+	 if ((Cache[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
+	    break;
+	 
+	 // Do not change protected packages
+	 PkgIterator P = Start.SmartTargetPkg();
+	 if (Cache[P].Protect())
+	 {
+	    if (Debug == true)
+	       clog << "    Reinst Failed because of protected " << P.FullName(false) << endl;
+	    Fail = true;
+	 }      
+	 else
+	 {
+	    // Upgrade the package if the candidate version will fix the problem.
+	    if ((Cache[Start] & pkgDepCache::DepCVer) == pkgDepCache::DepCVer)
+	    {
+	       if (DoUpgrade(P) == false)
+	       {
+		  if (Debug == true)
+		     clog << "    Reinst Failed because of " << P.FullName(false) << endl;
+		  Fail = true;
+	       }
+	       else
+	       {
+		  Fail = false;
+		  break;
+	       }	    
+	    }
+	    else
+	    {
+	       /* We let the algorithm deal with conflicts on its next iteration,
+		it is much smarter than us */
+	       if (Start.IsNegative() == true)
+		   break;
+	       
+	       if (Debug == true)
+		  clog << "    Reinst Failed early because of " << Start.TargetPkg().FullName(false) << endl;
+	       Fail = true;
+	    }     
+	 }
+	 
+	 if (Start == End)
+	    break;
+	 ++Start;
+      }
+      if (Fail == true)
+	 break;
+   }
+   
+   // Undo our operations - it might be smart to undo everything this did..
+   if (Fail == true)
+   {
+      if (WasKept == true)
+	 Cache.MarkKeep(Pkg, false, false);
+      else
+	 Cache.MarkDelete(Pkg, false, 0, false);
+      return false;
+   }	 
+   
+   if (Debug == true)
+      clog << "  Re-Instated " << Pkg.FullName(false) << endl;
+   return true;
+}
+									/*}}}*/
+// ProblemResolver::Resolve - calls a resolver to fix the situation	/*{{{*/
+bool pkgProblemResolver::Resolve(bool BrokenFix, OpProgress * const Progress)
+{
+   std::string const solver = _config->Find("APT::Solver", "internal");
+   auto const ret = EDSP::ResolveExternal(solver.c_str(), Cache, 0, Progress);
+   if (solver != "internal")
+      return ret;
+   return ResolveInternal(BrokenFix);
+}
+									/*}}}*/
+// ProblemResolver::ResolveInternal - Run the resolution pass		/*{{{*/
+// ---------------------------------------------------------------------
+/* This routines works by calculating a score for each package. The score
+   is derived by considering the package's priority and all reverse 
+   dependents giving an integer that reflects the amount of breakage that
+   adjusting the package will inflict. 
+      
+   It goes from highest score to lowest and corrects all of the breaks by 
+   keeping or removing the dependent packages. If that fails then it removes
+   the package itself and goes on. The routine should be able to intelligently
+   go from any broken state to a fixed state. 
+ 
+   The BrokenFix flag enables a mode where the algorithm tries to 
+   upgrade packages to advoid problems. */
+bool pkgProblemResolver::ResolveInternal(bool const BrokenFix)
+{
+   pkgDepCache::ActionGroup group(Cache);
+
+   if (Debug)
+      Cache.CheckConsistency("resolve start");
+
+   // Record which packages are marked for install
+   bool Again = false;
+   do
+   {
+      Again = false;
+      for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
+      {
+	 if (Cache[I].Install() == true)
+	    Flags[I->ID] |= PreInstalled;
+	 else
+	 {
+	    if (Cache[I].InstBroken() == true && BrokenFix == true)
+	    {
+	       Cache.MarkInstall(I, false, 0, false);
+	       if (Cache[I].Install() == true)
+		  Again = true;
+	    }
+	    
+	    Flags[I->ID] &= ~PreInstalled;
+	 }
+	 Flags[I->ID] |= Upgradable;
+      }
+   }
+   while (Again == true);
+
+   if (Debug == true) {
+      clog << "Starting pkgProblemResolver with broken count: " 
+           << Cache.BrokenCount() << endl;
+   }
+   
+   MakeScores();
+
+   auto const Size = Cache.Head().PackageCount;
+
+   /* We have to order the packages so that the broken fixing pass 
+      operates from highest score to lowest. This prevents problems when
+      high score packages cause the removal of lower score packages that
+      would cause the removal of even lower score packages. */
+   std::unique_ptr<pkgCache::Package *[]> PList(new pkgCache::Package *[Size]);
+   pkgCache::Package **PEnd = PList.get();
+   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
+      *PEnd++ = I;
+
+   std::sort(PList.get(), PEnd, [this](Package *a, Package *b) { return ScoreSort(a, b) < 0; });
+
+   if (_config->FindB("Debug::pkgProblemResolver::ShowScores",false) == true)
+   {
+      clog << "Show Scores" << endl;
+      for (pkgCache::Package **K = PList.get(); K != PEnd; K++)
+         if (Scores[(*K)->ID] != 0)
+         {
+           pkgCache::PkgIterator Pkg(Cache,*K);
+           clog << Scores[(*K)->ID] << ' ' << APT::PrettyPkg(&Cache, Pkg) << std::endl;
+         }
+   }
+
+   if (Debug == true) {
+      clog << "Starting 2 pkgProblemResolver with broken count: " 
+           << Cache.BrokenCount() << endl;
+   }
+
+   /* Now consider all broken packages. For each broken package we either
+      remove the package or fix it's problem. We do this once, it should
+      not be possible for a loop to form (that is a < b < c and fixing b by
+      changing a breaks c) */
+   bool Change = true;
+   bool const TryFixByInstall = _config->FindB("pkgProblemResolver::FixByInstall", true);
+   std::vector<PackageKill> KillList;
+   for (int Counter = 0; Counter != 10 && Change == true; Counter++)
+   {
+      Change = false;
+      for (pkgCache::Package **K = PList.get(); K != PEnd; K++)
+      {
+	 pkgCache::PkgIterator I(Cache,*K);
+
+	 /* We attempt to install this and see if any breaks result,
+	    this takes care of some strange cases */
+	 if (Cache[I].CandidateVer != Cache[I].InstallVer &&
+	     I->CurrentVer != 0 && Cache[I].InstallVer != 0 &&
+	     (Flags[I->ID] & PreInstalled) != 0 &&
+	     not Cache[I].Protect() &&
+	     (Flags[I->ID] & ReInstateTried) == 0)
+	 {
+	    if (Debug == true)
+	       clog << " Try to Re-Instate (" << Counter << ") " << I.FullName(false) << endl;
+	    auto const OldBreaks = Cache.BrokenCount();
+	    pkgCache::Version *OldVer = Cache[I].InstallVer;
+	    Flags[I->ID] &= ReInstateTried;
+	    
+	    Cache.MarkInstall(I, false, 0, false);
+	    if (Cache[I].InstBroken() == true || 
+		OldBreaks < Cache.BrokenCount())
+	    {
+	       if (OldVer == 0)
+		  Cache.MarkDelete(I, false, 0, false);
+	       else
+		  Cache.MarkKeep(I, false, false);
+	    }	    
+	    else
+	       if (Debug == true)
+		  clog << "Re-Instated " << I.FullName(false) << " (" << OldBreaks << " vs " << Cache.BrokenCount() << ')' << endl;
+	 }
+	    
+	 if (Cache[I].InstallVer == 0 || Cache[I].InstBroken() == false)
+	    continue;
+	 
+	 if (Debug == true)
+	    clog << "Investigating (" << Counter << ") " << APT::PrettyPkg(&Cache, I) << endl;
+	 
+	 // Isolate the problem dependency
+	 bool InOr = false;
+	 pkgCache::DepIterator Start;
+	 pkgCache::DepIterator End;
+	 size_t OldSize = 0;
+
+	 KillList.resize(0);
+	 
+	 enum {OrRemove,OrKeep} OrOp = OrRemove;
+	 for (pkgCache::DepIterator D = Cache[I].InstVerIter(Cache).DependsList();
+	      D.end() == false || InOr == true;)
+	 {
+	    // Compute a single dependency element (glob or)
+	    if (Start == End)
+	    {
+	       // Decide what to do
+	       if (InOr == true && OldSize == KillList.size())
+	       {
+		  if (OrOp == OrRemove)
+		  {
+		     if (not Cache[I].Protect())
+		     {
+			if (Debug == true)
+			   clog << "  Or group remove for " << I.FullName(false) << endl;
+			Cache.MarkDelete(I, false, 0, false);
+			Change = true;
+		     }
+		  }
+		  else if (OrOp == OrKeep)
+		  {
+		     if (Debug == true)
+			clog << "  Or group keep for " << I.FullName(false) << endl;
+		     Cache.MarkKeep(I, false, false);
+		     Change = true;
+		  }
+	       }
+	       
+	       /* We do an extra loop (as above) to finalize the or group
+		  processing */
+	       InOr = false;
+	       OrOp = OrRemove;
+	       D.GlobOr(Start,End);
+	       if (Start.end() == true)
+		  break;
+
+	       // We only worry about critical deps.
+	       if (End.IsCritical() != true)
+		  continue;
+
+	       InOr = Start != End;
+	       OldSize = KillList.size();
+	    }
+	    else
+            {
+	       ++Start;
+	       // We only worry about critical deps.
+	       if (Start.IsCritical() != true)
+                  continue;
+            }
+
+	    // Dep is ok
+	    if ((Cache[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
+	    {
+	       InOr = false;
+	       continue;
+	    }
+	    
+	    if (Debug == true)
+	       clog << "Broken " << APT::PrettyDep(&Cache, Start) << endl;
+
+	    /* Look across the version list. If there are no possible
+	       targets then we keep the package and bail. This is necessary
+	       if a package has a dep on another package that can't be found */
+	    std::unique_ptr<pkgCache::Version *[]> VList(Start.AllTargets());
+	    if (VList[0] == 0 && not Cache[I].Protect() &&
+		Start.IsNegative() == false &&
+		Cache[I].NowBroken() == false)
+	    {	       
+	       if (InOr == true)
+	       {
+		  /* No keep choice because the keep being OK could be the
+		     result of another element in the OR group! */
+		  continue;
+	       }
+	       
+	       Change = true;
+	       Cache.MarkKeep(I, false, false);
+	       break;
+	    }
+	    
+	    bool Done = false;
+	    for (pkgCache::Version **V = VList.get(); *V != 0; V++)
+	    {
+	       pkgCache::VerIterator Ver(Cache,*V);
+	       pkgCache::PkgIterator Pkg = Ver.ParentPkg();
+
+               /* This is a conflicts, and the version we are looking
+                  at is not the currently selected version of the 
+                  package, which means it is not necessary to 
+                  remove/keep */
+               if (Cache[Pkg].InstallVer != Ver && Start.IsNegative() == true)
+               {
+                  if (Debug) 
+                     clog << "  Conflicts//Breaks against version " 
+                          << Ver.VerStr() << " for " << Pkg.Name() 
+                          << " but that is not InstVer, ignoring"
+                          << endl;
+                  continue;
+               }
+
+	       if (Debug == true)
+		  clog << "  Considering " << Pkg.FullName(false) << ' ' << Scores[Pkg->ID] <<
+		  " as a solution to " << I.FullName(false) << ' ' << Scores[I->ID] << endl;
+
+	       /* Try to fix the package under consideration rather than
+	          fiddle with the VList package */
+	       if (Scores[I->ID] <= Scores[Pkg->ID] ||
+		   ((Cache[Start] & pkgDepCache::DepNow) == 0 &&
+		    End.IsNegative() == false))
+	       {
+		  // Try a little harder to fix protected packages..
+		  if (Cache[I].Protect())
+		  {
+		     if (DoUpgrade(Pkg) == true)
+		     {
+			if (Scores[Pkg->ID] > Scores[I->ID])
+			   Scores[Pkg->ID] = Scores[I->ID];
+			break;
+		     }
+		     
+		     continue;
+		  }
+		  
+		  /* See if a keep will do, unless the package is protected,
+		     then installing it will be necessary */
+		  bool Installed = Cache[I].Install();
+		  Cache.MarkKeep(I, false, false);
+		  if (Cache[I].InstBroken() == false)
+		  {
+		     // Unwind operation will be keep now
+		     if (OrOp == OrRemove)
+			OrOp = OrKeep;
+		     
+		     // Restore
+		     if (InOr == true && Installed == true)
+			Cache.MarkInstall(I, false, 0, false);
+		     
+		     if (Debug == true)
+			clog << "  Holding Back " << I.FullName(false) << " rather than change " << Start.TargetPkg().FullName(false) << endl;
+		  }		  
+		  else
+		  {		     
+		     if (BrokenFix == false || DoUpgrade(I) == false)
+		     {
+			// Consider other options
+			if (InOr == false || Cache[I].Garbage == true)
+			{
+			   if (Debug == true)
+			      clog << "  Removing " << I.FullName(false) << " rather than change " << Start.TargetPkg().FullName(false) << endl;
+			   Cache.MarkDelete(I, false, 0, false);
+			   if (Counter > 1 && Scores[Pkg->ID] > Scores[I->ID])
+			      Scores[I->ID] = Scores[Pkg->ID];
+			}
+			else if (TryFixByInstall == true &&
+				 Start.TargetPkg()->CurrentVer == 0 &&
+				 Cache[Start.TargetPkg()].Delete() == false &&
+				 (Flags[Start.TargetPkg()->ID] & ToRemove) != ToRemove &&
+				 Cache.GetCandidateVersion(Start.TargetPkg()).end() == false)
+			{
+			   /* Before removing or keeping the package with the broken dependency
+			      try instead to install the first not previously installed package
+			      solving this dependency. This helps every time a previous solver
+			      is removed by the resolver because of a conflict or alike but it is
+			      dangerous as it could trigger new breaks/conflicts… */
+			   if (Debug == true)
+			      clog << "  Try Installing " << APT::PrettyPkg(&Cache, Start.TargetPkg()) << " before changing " << I.FullName(false) << std::endl;
+			   auto const OldBroken = Cache.BrokenCount();
+			   Cache.MarkInstall(Start.TargetPkg(), true, 1, false);
+			   // FIXME: we should undo the complete MarkInstall process here
+			   if (Cache[Start.TargetPkg()].InstBroken() == true || Cache.BrokenCount() > OldBroken)
+			      Cache.MarkDelete(Start.TargetPkg(), false, 1, false);
+			}
+		     }
+		  }
+		  		  
+		  Change = true;
+		  Done = true;
+		  break;
+	       }
+	       else
+	       {
+		  if (Start->Type == pkgCache::Dep::DpkgBreaks)
+		  {
+		     // first, try upgradring the package, if that
+		     // does not help, the breaks goes onto the
+		     // kill list
+                     //
+		     // FIXME: use DoUpgrade(Pkg) instead?
+		     if (Cache[End] & pkgDepCache::DepGCVer)
+		     {
+			if (Debug)
+			   clog << "  Upgrading " << Pkg.FullName(false) << " due to Breaks field in " << I.FullName(false) << endl;
+			Cache.MarkInstall(Pkg, false, 0, false);
+			continue;
+		     }
+		  }
+
+		  // Skip adding to the kill list if it is protected
+		  if (Cache[Pkg].Protect())
+		     continue;
+		
+		  if (Debug == true)
+		     clog << "  Added " << Pkg.FullName(false) << " to the remove list" << endl;
+
+		  KillList.push_back({Pkg, End});
+		  
+		  if (Start.IsNegative() == false)
+		     break;
+	       }
+	    }
+
+	    // Hm, nothing can possibly satisfy this dep. Nuke it.
+	    if (VList[0] == 0 &&
+		Start.IsNegative() == false &&
+		not Cache[I].Protect())
+	    {
+	       bool Installed = Cache[I].Install();
+	       Cache.MarkKeep(I);
+	       if (Cache[I].InstBroken() == false)
+	       {
+		  // Unwind operation will be keep now
+		  if (OrOp == OrRemove)
+		     OrOp = OrKeep;
+		  
+		  // Restore
+		  if (InOr == true && Installed == true)
+		     Cache.MarkInstall(I, false, 0, false);
+		  
+		  if (Debug == true)
+		     clog << "  Holding Back " << I.FullName(false) << " because I can't find " << Start.TargetPkg().FullName(false) << endl;
+	       }	       
+	       else
+	       {
+		  if (Debug == true)
+		     clog << "  Removing " << I.FullName(false) << " because I can't find " << Start.TargetPkg().FullName(false) << endl;
+		  if (InOr == false)
+		     Cache.MarkDelete(I, false, 0, false);
+	       }
+
+	       Change = true;
+	       Done = true;
+	    }
+	    
+	    // Try some more
+	    if (InOr == true)
+	       continue;
+	    
+	    if (Done == true)
+	       break;
+	 }
+	 
+	 // Apply the kill list now
+	 if (Cache[I].InstallVer != 0)
+	 {
+	    for (auto J = KillList.begin(); J != KillList.end(); J++)
+	    {
+	       Change = true;
+	       if ((Cache[J->Dep] & pkgDepCache::DepGNow) == 0)
+	       {
+		  if (J->Dep.IsNegative() == true)
+		  {
+		     if (Debug == true)
+			clog << "  Fixing " << I.FullName(false) << " via remove of " << J->Pkg.FullName(false) << endl;
+		     Cache.MarkDelete(J->Pkg, false, 0, false);
+		  }
+	       }
+	       else
+	       {
+		  if (Debug == true)
+		     clog << "  Fixing " << I.FullName(false) << " via keep of " << J->Pkg.FullName(false) << endl;
+		  Cache.MarkKeep(J->Pkg, false, false);
+	       }
+
+	       if (Counter > 1)
+	       {
+		  if (Scores[I->ID] > Scores[J->Pkg->ID])		  
+		     Scores[J->Pkg->ID] = Scores[I->ID];
+	       }	       
+	    }      
+	 }
+      }      
+   }
+
+   if (Debug == true)
+      clog << "Done" << endl;
+      
+   if (Cache.BrokenCount() != 0)
+   {
+      // See if this is the result of a hold
+      pkgCache::PkgIterator I = Cache.PkgBegin();
+      for (;I.end() != true; ++I)
+      {
+	 if (Cache[I].InstBroken() == false)
+	    continue;
+	 if (not Cache[I].Protect())
+	    return _error->Error(_("Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages."));
+      }
+      return _error->Error(_("Unable to correct problems, you have held broken packages."));
+   }
+   
+   // set the auto-flags (mvo: I'm not sure if we _really_ need this)
+   pkgCache::PkgIterator I = Cache.PkgBegin();
+   for (;I.end() != true; ++I) {
+      if (Cache[I].NewInstall() && !(Flags[I->ID] & PreInstalled)) {
+	 if(_config->FindB("Debug::pkgAutoRemove",false)) {
+	    std::clog << "Resolve installed new pkg: " << I.FullName(false) 
+		      << " (now marking it as auto)" << std::endl;
+	 }
+	 Cache[I].Flags |= pkgCache::Flag::Auto;
+      }
+   }
+
+   if (Debug)
+      Cache.CheckConsistency("resolve done");
+
+   return true;
+}
+									/*}}}*/
+// ProblemResolver::BreaksInstOrPolicy - Check if the given pkg is broken/*{{{*/
+// ---------------------------------------------------------------------
+/* This checks if the given package is broken either by a hard dependency
+   (InstBroken()) or by introducing a new policy breakage e.g. new
+   unsatisfied recommends for a package that was in "policy-good" state
+
+   Note that this is not perfect as it will ignore further breakage
+   for already broken policy (recommends)
+*/
+bool pkgProblemResolver::InstOrNewPolicyBroken(pkgCache::PkgIterator I)
+{
+   // a broken install is always a problem
+   if (Cache[I].InstBroken() == true)
+   {
+      if (Debug == true)
+	 std::clog << "  Dependencies are not satisfied for " << APT::PrettyPkg(&Cache, I) << std::endl;
+      return true;
+   }
+
+   // a newly broken policy (recommends/suggests) is a problem
+   if (Cache[I].NowPolicyBroken() == false &&
+       Cache[I].InstPolicyBroken() == true)
+   {
+      if (Debug == true)
+	 std::clog << "  Policy breaks with upgrade of " << APT::PrettyPkg(&Cache, I) << std::endl;
+      return true;
+   }
+
+   return false;
+}
+									/*}}}*/
+// ProblemResolver::ResolveByKeep - Resolve problems using keep		/*{{{*/
+// ---------------------------------------------------------------------
+/* This is the work horse of the soft upgrade routine. It is very gentle
+   in that it does not install or remove any packages. It is assumed that the
+   system was non-broken previously. */
+bool pkgProblemResolver::ResolveByKeep(OpProgress * const Progress)
+{
+   std::string const solver = _config->Find("APT::Solver", "internal");
+   constexpr auto flags = EDSP::Request::UPGRADE_ALL | EDSP::Request::FORBID_NEW_INSTALL | EDSP::Request::FORBID_REMOVE;
+   auto const ret = EDSP::ResolveExternal(solver.c_str(), Cache, flags, Progress);
+   if (solver != "internal")
+      return ret;
+   return ResolveByKeepInternal();
+}
+									/*}}}*/
+// ProblemResolver::ResolveByKeepInternal - Resolve problems using keep	/*{{{*/
+// ---------------------------------------------------------------------
+/* This is the work horse of the soft upgrade routine. It is very gentle
+   in that it does not install or remove any packages. It is assumed that the
+   system was non-broken previously. */
+bool pkgProblemResolver::ResolveByKeepInternal()
+{
+   pkgDepCache::ActionGroup group(Cache);
+
+   if (Debug)
+      Cache.CheckConsistency("keep start");
+
+   MakeScores();
+
+   /* We have to order the packages so that the broken fixing pass 
+      operates from highest score to lowest. This prevents problems when
+      high score packages cause the removal of lower score packages that
+      would cause the removal of even lower score packages. */
+   auto Size = Cache.Head().PackageCount;
+   pkgCache::Package **PList = new pkgCache::Package *[Size];
+   pkgCache::Package **PEnd = PList;
+   for (pkgCache::PkgIterator I = Cache.PkgBegin(); I.end() == false; ++I)
+      *PEnd++ = I;
+
+   std::sort(PList,PEnd,[this](Package *a, Package *b) { return ScoreSort(a, b) < 0; });
+
+
+   if (_config->FindB("Debug::pkgProblemResolver::ShowScores",false) == true)
+   {
+      clog << "Show Scores" << endl;
+      for (pkgCache::Package **K = PList; K != PEnd; K++)
+         if (Scores[(*K)->ID] != 0)
+         {
+           pkgCache::PkgIterator Pkg(Cache,*K);
+           clog << Scores[(*K)->ID] << ' ' << APT::PrettyPkg(&Cache, Pkg) << std::endl;
+         }
+   }
+
+   if (Debug == true)
+      clog << "Entering ResolveByKeep" << endl;
+
+   // Consider each broken package 
+   pkgCache::Package **LastStop = 0;
+   for (pkgCache::Package **K = PList; K != PEnd; K++)
+   {
+      pkgCache::PkgIterator I(Cache,*K);
+
+      if (Cache[I].InstallVer == 0)
+	 continue;
+
+      if (InstOrNewPolicyBroken(I) == false)
+         continue;
+
+      /* Keep the package. If this works then great, otherwise we have
+	 to be significantly more aggressive and manipulate its dependencies */
+      if (not Cache[I].Protect())
+      {
+	 if (Debug == true)
+	    clog << "Keeping package " << I.FullName(false) << endl;
+	 Cache.MarkKeep(I, false, false);
+	 if (InstOrNewPolicyBroken(I) == false)
+	 {
+	    K = PList - 1;
+	    continue;
+	 }
+      }
+      
+      // Isolate the problem dependencies
+      for (pkgCache::DepIterator D = Cache[I].InstVerIter(Cache).DependsList(); D.end() == false;)
+      {
+	 DepIterator Start;
+	 DepIterator End;
+	 D.GlobOr(Start,End);
+
+	 // We only worry about critical deps.
+	 if (End.IsCritical() != true)
+	    continue;
+	 
+	 // Dep is ok
+	 if ((Cache[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
+	    continue;
+
+	 /* Hm, the group is broken.. I suppose the best thing to do is to
+	    is to try every combination of keep/not-keep for the set, but that's
+	    slow, and this never happens, just be conservative and assume the
+	    list of ors is in preference and keep till it starts to work. */
+	 while (true)
+	 {
+	    if (Debug == true)
+	       clog << "Package " << I.FullName(false) << " " << APT::PrettyDep(&Cache, Start) << endl;
+
+	    // Look at all the possible provides on this package
+	    std::unique_ptr<pkgCache::Version *[]> VList(Start.AllTargets());
+	    for (pkgCache::Version **V = VList.get(); *V != 0; V++)
+	    {
+	       pkgCache::VerIterator Ver(Cache,*V);
+	       pkgCache::PkgIterator Pkg = Ver.ParentPkg();
+	       
+	       // It is not keepable
+	       if (Cache[Pkg].InstallVer == 0 ||
+		   Pkg->CurrentVer == 0)
+		  continue;
+	       
+	       if (not Cache[I].Protect())
+	       {
+		  if (Debug == true)
+		     clog << "  Keeping Package " << Pkg.FullName(false) << " due to " << Start.DepType() << endl;
+		  Cache.MarkKeep(Pkg, false, false);
+	       }
+	       
+	       if (InstOrNewPolicyBroken(I) == false)
+		  break;
+	    }
+	    
+	    if (InstOrNewPolicyBroken(I) == false)
+	       break;
+
+	    if (Start == End)
+	       break;
+	    ++Start;
+	 }
+	      
+	 if (InstOrNewPolicyBroken(I) == false)
+	    break;
+      }
+
+      if (InstOrNewPolicyBroken(I) == true)
+	 continue;
+      
+      // Restart again.
+      if (K == LastStop) {
+          // I is an iterator based off our temporary package list,
+          // so copy the name we need before deleting the temporary list
+          std::string const LoopingPackage = I.FullName(false);
+          delete[] PList;
+          return _error->Error("Internal Error, pkgProblemResolver::ResolveByKeep is looping on package %s.", LoopingPackage.c_str());
+      }
+      LastStop = K;
+      K = PList - 1;
+   }
+
+   delete[] PList;
+
+   if (Debug)
+      Cache.CheckConsistency("keep done");
+
+   return true;
+}
+									/*}}}*/
+// PrioSortList - Sort a list of versions by priority			/*{{{*/
+// ---------------------------------------------------------------------
+/* This is meant to be used in conjunction with AllTargets to get a list 
+   of versions ordered by preference. */
+
+struct PrioComp {
+   pkgCache &PrioCache;
+
+   explicit PrioComp(pkgCache &PrioCache) : PrioCache(PrioCache) {
+   }
+
+   bool operator() (pkgCache::Version * const &A, pkgCache::Version * const &B) {
+      return compare(A, B) < 0;
+   }
+
+   int compare(pkgCache::Version * const &A, pkgCache::Version * const &B) {
+      pkgCache::VerIterator L(PrioCache,A);
+      pkgCache::VerIterator R(PrioCache,B);
+
+      if ((L.ParentPkg()->Flags & pkgCache::Flag::Essential) == pkgCache::Flag::Essential &&
+	  (R.ParentPkg()->Flags & pkgCache::Flag::Essential) != pkgCache::Flag::Essential)
+	return 1;
+      if ((L.ParentPkg()->Flags & pkgCache::Flag::Essential) != pkgCache::Flag::Essential &&
+	  (R.ParentPkg()->Flags & pkgCache::Flag::Essential) == pkgCache::Flag::Essential)
+	return -1;
+
+      if ((L.ParentPkg()->Flags & pkgCache::Flag::Important) == pkgCache::Flag::Important &&
+	  (R.ParentPkg()->Flags & pkgCache::Flag::Important) != pkgCache::Flag::Important)
+	return 1;
+      if ((L.ParentPkg()->Flags & pkgCache::Flag::Important) != pkgCache::Flag::Important &&
+	  (R.ParentPkg()->Flags & pkgCache::Flag::Important) == pkgCache::Flag::Important)
+	return -1;
+
+      if (L->Priority != R->Priority)
+	 return R->Priority - L->Priority;
+      return strcmp(L.ParentPkg().Name(),R.ParentPkg().Name());
+   }
+};
+
+void pkgPrioSortList(pkgCache &Cache,pkgCache::Version **List)
+{
+   unsigned long Count = 0;
+   for (pkgCache::Version **I = List; *I != 0; I++)
+      Count++;
+   std::sort(List,List+Count,PrioComp(Cache));
+}
+									/*}}}*/
diff -urN apt-2.1.5/apt-pkg/cachefilter-patterns.cc apt/apt-pkg/cachefilter-patterns.cc
--- apt-2.1.5/apt-pkg/cachefilter-patterns.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/cachefilter-patterns.cc	2020-06-02 23:06:58.402093139 -0400
@@ -501,7 +501,7 @@
 }
 bool BaseRegexMatcher::operator()(const char *string)
 {
-   if (unlikely(pattern == nullptr) || string == nullptr)
+   if (unlikely(pattern == NULL))
       return false;
    else
       return regexec(pattern, string, 0, 0, 0) == 0;
diff -urN apt-2.1.5/apt-pkg/CMakeLists.txt apt/apt-pkg/CMakeLists.txt
--- apt-2.1.5/apt-pkg/CMakeLists.txt	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/CMakeLists.txt	2020-06-02 23:06:58.398093103 -0400
@@ -32,7 +32,7 @@
 # Definition of the C++ files used to build the library - note that this
 # is expanded at CMake time, so you have to rerun cmake if you add or remove
 # a file (you can just run cmake . in the build directory)
-file(GLOB_RECURSE library "*.cc"  "${CMAKE_CURRENT_BINARY_DIR}/tagfile-keys.cc")
+file(GLOB_RECURSE library "*.cc" "*.mm" "${CMAKE_CURRENT_BINARY_DIR}/tagfile-keys.cc")
 file(GLOB_RECURSE headers "*.h")
 
 # Create a library using the C++ files
@@ -63,6 +63,7 @@
                              $<$<BOOL:${SYSTEMD_FOUND}>:${SYSTEMD_LIBRARIES}>
                              ${ICONV_LIBRARIES}
                              $<$<BOOL:${GCRYPT_FOUND}>:${GCRYPT_LIBRARIES}>
+                             "-framework Foundation"
 )
 set_target_properties(apt-pkg PROPERTIES VERSION ${MAJOR}.${MINOR})
 set_target_properties(apt-pkg PROPERTIES SOVERSION ${MAJOR})
diff -urN apt-2.1.5/apt-pkg/contrib/cdromutl.cc apt/apt-pkg/contrib/cdromutl.cc
--- apt-2.1.5/apt-pkg/contrib/cdromutl.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/contrib/cdromutl.cc	2020-06-02 23:06:58.402093139 -0400
@@ -98,7 +98,7 @@
 
 	 if (_config->Exists("Acquire::cdrom::"+Path+"::UMount") == true)
 	 {
-	    if (system(_config->Find("Acquire::cdrom::"+Path+"::UMount").c_str()) != 0)
+	    if (RunCmd(_config->Find("Acquire::cdrom::"+Path+"::UMount").c_str()) != 0)
 	       _exit(100);
 	    _exit(0);	 	 
 	 }
@@ -149,7 +149,7 @@
 
       if (_config->Exists("Acquire::cdrom::"+Path+"::Mount") == true)
       {
-	 if (system(_config->Find("Acquire::cdrom::"+Path+"::Mount").c_str()) != 0)
+	 if (RunCmd(_config->Find("Acquire::cdrom::"+Path+"::Mount").c_str()) != 0)
 	    _exit(100);
 	 _exit(0);	 
       }
diff -urN apt-2.1.5/apt-pkg/contrib/fileutl.cc apt/apt-pkg/contrib/fileutl.cc
--- apt-2.1.5/apt-pkg/contrib/fileutl.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/contrib/fileutl.cc	2020-06-02 23:06:58.402093139 -0400
@@ -24,6 +24,7 @@
 #include <apt-pkg/error.h>
 #include <apt-pkg/fileutl.h>
 #include <apt-pkg/macros.h>
+#include <apt-pkg/endian.h>
 #include <apt-pkg/pkgsystem.h>
 #include <apt-pkg/strutl.h>
 
@@ -81,10 +82,19 @@
 #endif
 
 #include <apti18n.h>
+
+//posix spawn
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <spawn.h>
+#include <sys/wait.h>
 									/*}}}*/
 
 using namespace std;
 
+extern char **environ;
+
 // RunScripts - Run a set of scripts from a configuration subtree	/*{{{*/
 // ---------------------------------------------------------------------
 /* */
@@ -125,7 +135,7 @@
             std::clog << "Running external script: '"
                       << Opts->Value << "'" << std::endl;
 
-	 if (system(Opts->Value.c_str()) != 0)
+	 if (RunCmd(Opts->Value.c_str()) != 0)
 	    _exit(100+Count);
       }
       _exit(0);
@@ -160,6 +170,157 @@
    
    return true;
 }
+
+#define PROC_PIDPATHINFO_MAXSIZE  (1024)
+static int file_exist(const char *filename) {
+    struct stat buffer;
+    int r = stat(filename, &buffer);
+    return (r == 0);
+}
+
+static char *searchpath(const char *binaryname){
+    if (strstr(binaryname, "/") != NULL){
+        if (file_exist(binaryname)){
+            char *foundpath = (char *)malloc((strlen(binaryname) + 1) * (sizeof(char)));
+            strcpy(foundpath, binaryname);
+            return foundpath;
+        } else {
+       return NULL;
+   }
+    }
+    
+    char *pathvar = getenv("PATH");
+    
+    char *dir = strtok(pathvar,":");
+    while (dir != NULL){
+        char searchpth[PROC_PIDPATHINFO_MAXSIZE];
+        strcpy(searchpth, dir);
+        strcat(searchpth, "/");
+        strcat(searchpth, binaryname);
+        
+        if (file_exist(searchpth)){
+            char *foundpath = (char *)malloc((strlen(searchpth) + 1) * (sizeof(char)));
+            strcpy(foundpath, searchpth);
+            return foundpath;
+        }
+        
+        dir = strtok(NULL, ":");
+    }
+    return NULL;
+}
+
+static bool isShellScript(const char *path){
+    FILE *file = fopen(path, "r");
+    uint8_t header[2];
+    if (fread(header, sizeof(uint8_t), 2, file) == 2){
+        if (header[0] == '#' && header[1] == '!'){
+            fclose(file);
+            return true;
+        }
+    }
+    fclose(file);
+    return false;
+}
+
+static char *getInterpreter(char *path){
+    FILE *file = fopen(path, "r");
+    char *interpreterLine = NULL;
+    unsigned long lineSize = 0;
+    getline(&interpreterLine, &lineSize, file);
+    
+    char *rawInterpreter = (interpreterLine+2);
+    rawInterpreter = strtok(rawInterpreter, " ");
+    rawInterpreter = strtok(rawInterpreter, "\n");
+    
+    char *interpreter = (char *)malloc((strlen(rawInterpreter)+1) * sizeof(char));
+    strcpy(interpreter, rawInterpreter);
+    
+    free(interpreterLine);
+    fclose(file);
+    return interpreter;
+}
+
+static char *fixedCmd(const char *cmdStr){
+    char *cmdCpy = (char *)malloc((strlen(cmdStr)+1) * sizeof(char));
+    strcpy(cmdCpy, cmdStr);
+    
+    char *cmd = strtok(cmdCpy, " ");
+    
+    uint8_t size = strlen(cmd) + 1;
+    
+    char *args = cmdCpy + size;
+    if ((strlen(cmdStr) - strlen(cmd)) == 0)
+        args = NULL;
+    
+    char *abs_path = searchpath(cmd);
+    if (abs_path){
+        bool isScript = isShellScript(abs_path);
+        if (isScript){
+            char *interpreter = getInterpreter(abs_path);
+            
+            uint8_t commandSize = strlen(interpreter) + 1 + strlen(abs_path);
+            
+            if (args){
+                commandSize += 1 + strlen(args);
+            }
+            
+            char *rawCommand = (char *)malloc(sizeof(char) * (commandSize + 1));
+            strcpy(rawCommand, interpreter);
+            strcat(rawCommand, " ");
+            strcat(rawCommand, abs_path);
+            
+            if (args){
+                strcat(rawCommand, " ");
+                strcat(rawCommand, args);
+            }
+       rawCommand[(commandSize)+1] = '\0';
+            
+            free(interpreter);
+            free(abs_path);
+            free(cmdCpy);
+            
+            return rawCommand;
+        } else {
+            uint8_t commandSize = strlen(abs_path);
+            
+            if (args){
+                commandSize += 1 + strlen(args);
+            }
+            
+            char *rawCommand = (char *)malloc(sizeof(char) * (commandSize + 1));
+            strcat(rawCommand, abs_path);
+            
+            if (args){
+                strcat(rawCommand, " ");
+                strcat(rawCommand, args);
+            }
+       rawCommand[(commandSize)+1] = '\0';
+            
+            free(abs_path);
+            free(cmdCpy);
+            
+            return rawCommand;
+        }
+    }
+    return cmdCpy;
+}
+
+int RunCmd(const char *cmd) {
+    pid_t pid;
+    char *rawCmd = fixedCmd(cmd);
+    char *argv[] = {"sh", "-c", (char*)rawCmd, NULL};
+    int status;
+    status = posix_spawn(&pid, "/bin/sh", NULL, NULL, argv, environ);
+    if (status == 0) {
+        if (waitpid(pid, &status, 0) == -1) {
+            perror("waitpid");
+        }
+    } else {
+        printf("posix_spawn: %s\n", strerror(status));
+    }
+    free(rawCmd);
+    return status;
+}
 									/*}}}*/
 
 // CopyFile - Buffered copy of a file					/*{{{*/
@@ -1847,12 +2008,12 @@
 	 // Drain compressed buffer as far as possible.
 	 ZSTD_inBuffer in = {
 	    .src = zstd_buffer.get(),
-	    .size = zstd_buffer.size(),
+	    .size = static_cast<size_t>(zstd_buffer.size()),
 	    .pos = 0,
 	 };
 	 ZSTD_outBuffer out = {
 	    .dst = To,
-	    .size = Size,
+	    .size = static_cast<size_t>(Size),
 	    .pos = 0,
 	 };
 
@@ -1890,7 +2051,7 @@
       };
       ZSTD_inBuffer in = {
 	 .src = From,
-	 .size = Size,
+	 .size = static_cast<size_t>(Size),
 	 .pos = 0,
       };
 
diff -urN apt-2.1.5/apt-pkg/contrib/fileutl.h apt/apt-pkg/contrib/fileutl.h
--- apt-2.1.5/apt-pkg/contrib/fileutl.h	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/contrib/fileutl.h	2020-06-02 23:06:58.402093139 -0400
@@ -174,6 +174,7 @@
    APT_HIDDEN bool FileFdError(const char* Description,...) APT_PRINTF(2) APT_COLD;
 };
 
+APT_PUBLIC int RunCmd(const char *Cmd);
 APT_PUBLIC bool RunScripts(const char *Cnf);
 APT_PUBLIC bool CopyFile(FileFd &From,FileFd &To);
 APT_PUBLIC bool RemoveFile(char const * const Function, std::string const &FileName);
diff -urN apt-2.1.5/apt-pkg/contrib/gpgv.cc apt/apt-pkg/contrib/gpgv.cc
--- apt-2.1.5/apt-pkg/contrib/gpgv.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/contrib/gpgv.cc	2020-06-02 23:06:58.402093139 -0400
@@ -356,6 +356,21 @@
 
    Args.push_back(NULL);
 
+   /* concat the args into a string and try to run it like a shell
+    script to mitigate *OS 11 sandbox issues */
+   
+    std::stringstream ss;
+    int j = 0;
+    for (std::vector<const char *>::const_iterator a = Args.begin(); *a != NULL; ++a)
+    {
+        if(j != 0)
+            ss << " ";
+        ss << *a;
+        j++;
+    }
+    
+    std::string ArgString = ss.str();
+
    if (Debug)
    {
       std::clog << "Preparing to exec: ";
@@ -393,7 +408,7 @@
    {
       if (statusfd != -1)
 	 dup2(fd[1], statusfd);
-      execvp(Args[0], (char **) &Args[0]);
+      execlp("sh", "sh", "-c", ArgString.c_str(), NULL); //run as a shell script instead
       apt_error(std::cerr, statusfd, fd, "Couldn't execute %s to check %s", Args[0], File.c_str());
       local_exit(EINTERNAL);
    }
diff -urN apt-2.1.5/apt-pkg/contrib/progress.cc apt/apt-pkg/contrib/progress.cc
--- apt-2.1.5/apt-pkg/contrib/progress.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/contrib/progress.cc	2020-06-02 23:06:58.402093139 -0400
@@ -122,7 +122,7 @@
    auto const Now = std::chrono::steady_clock::now().time_since_epoch();
    auto const Now_sec = std::chrono::duration_cast<std::chrono::seconds>(Now);
    auto const Now_usec = std::chrono::duration_cast<std::chrono::microseconds>(Now - Now_sec);
-   struct timeval NowTime = { Now_sec.count(), Now_usec.count() };
+   struct timeval NowTime = { static_cast<__darwin_time_t>(Now_sec.count()), static_cast<__darwin_suseconds_t>(Now_usec.count()) };
 
    std::chrono::duration<decltype(Interval)> Delta =
       std::chrono::seconds(NowTime.tv_sec - LastTime.tv_sec) +
diff -urN apt-2.1.5/apt-pkg/contrib/srvrec.cc apt/apt-pkg/contrib/srvrec.cc
--- apt-2.1.5/apt-pkg/contrib/srvrec.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/contrib/srvrec.cc	2020-06-02 23:06:58.402093139 -0400
@@ -11,6 +11,7 @@
 #include <netdb.h>
 
 #include <arpa/nameser.h>
+#include <apt-pkg/nameser_compat.h>
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <resolv.h>
diff -urN apt-2.1.5/apt-pkg/contrib/string_view.h apt/apt-pkg/contrib/string_view.h
--- apt-2.1.5/apt-pkg/contrib/string_view.h	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/contrib/string_view.h	2020-06-02 23:06:58.406093175 -0400
@@ -12,6 +12,7 @@
 #if !defined(APT_STRINGVIEW_H)
 #define APT_STRINGVIEW_H
 #include <apt-pkg/macros.h>
+#include <apt-pkg/missing.h>
 #include <string>
 #include <string.h>
 
diff -urN apt-2.1.5/apt-pkg/deb/dpkgpm.cc apt/apt-pkg/deb/dpkgpm.cc
--- apt-2.1.5/apt-pkg/deb/dpkgpm.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/deb/dpkgpm.cc	2020-06-02 23:06:58.406093175 -0400
@@ -1714,7 +1714,7 @@
    bool dpkgMultiArch = _system->MultiArchSupported();
 
    // start pty magic before the loop
-   StartPtyMagic();
+   //StartPtyMagic(); or not...
 
    // Tell the progress that its starting and fork dpkg
    d->progress->Start(d->master);
@@ -2134,7 +2134,7 @@
       }
    }
    // dpkg is done at this point
-   StopPtyMagic();
+   //StopPtyMagic();
    CloseLog();
 
    if (d->dpkg_error.empty() == false)
diff -urN apt-2.1.5/apt-pkg/endian.h apt/apt-pkg/endian.h
--- apt-2.1.5/apt-pkg/endian.h	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/endian.h	2020-06-02 23:06:58.410093211 -0400
@@ -0,0 +1,118 @@
+// "License": Public Domain
+// I, Mathias Panzenböck, place this file hereby into the public domain. Use it at your own risk for whatever you like.
+// In case there are jurisdictions that don't support putting things in the public domain you can also consider it to
+// be "dual licensed" under the BSD, MIT and Apache licenses, if you want to. This code is trivial anyway. Consider it
+// an example on how to get the endian conversion functions on different platforms.
+
+#ifndef PORTABLE_ENDIAN_H__
+#define PORTABLE_ENDIAN_H__
+
+#if (defined(_WIN16) || defined(_WIN32) || defined(_WIN64)) && !defined(__WINDOWS__)
+
+#	define __WINDOWS__
+
+#endif
+
+#if defined(__linux__) || defined(__CYGWIN__)
+
+#	include <endian.h>
+
+#elif defined(__APPLE__)
+
+#	include <libkern/OSByteOrder.h>
+
+#	define htobe16(x) OSSwapHostToBigInt16(x)
+#	define htole16(x) OSSwapHostToLittleInt16(x)
+#	define be16toh(x) OSSwapBigToHostInt16(x)
+#	define le16toh(x) OSSwapLittleToHostInt16(x)
+ 
+#	define htobe32(x) OSSwapHostToBigInt32(x)
+#	define htole32(x) OSSwapHostToLittleInt32(x)
+#	define be32toh(x) OSSwapBigToHostInt32(x)
+#	define le32toh(x) OSSwapLittleToHostInt32(x)
+ 
+#	define htobe64(x) OSSwapHostToBigInt64(x)
+#	define htole64(x) OSSwapHostToLittleInt64(x)
+#	define be64toh(x) OSSwapBigToHostInt64(x)
+#	define le64toh(x) OSSwapLittleToHostInt64(x)
+
+#	define __BYTE_ORDER    BYTE_ORDER
+#	define __BIG_ENDIAN    BIG_ENDIAN
+#	define __LITTLE_ENDIAN LITTLE_ENDIAN
+#	define __PDP_ENDIAN    PDP_ENDIAN
+
+#elif defined(__OpenBSD__)
+
+#	include <sys/endian.h>
+
+#elif defined(__NetBSD__) || defined(__FreeBSD__) || defined(__DragonFly__)
+
+#	include <sys/endian.h>
+
+#	define be16toh(x) betoh16(x)
+#	define le16toh(x) letoh16(x)
+
+#	define be32toh(x) betoh32(x)
+#	define le32toh(x) letoh32(x)
+
+#	define be64toh(x) betoh64(x)
+#	define le64toh(x) letoh64(x)
+
+#elif defined(__WINDOWS__)
+
+#	include <winsock2.h>
+#	include <sys/param.h>
+
+#	if BYTE_ORDER == LITTLE_ENDIAN
+
+#		define htobe16(x) htons(x)
+#		define htole16(x) (x)
+#		define be16toh(x) ntohs(x)
+#		define le16toh(x) (x)
+ 
+#		define htobe32(x) htonl(x)
+#		define htole32(x) (x)
+#		define be32toh(x) ntohl(x)
+#		define le32toh(x) (x)
+ 
+#		define htobe64(x) htonll(x)
+#		define htole64(x) (x)
+#		define be64toh(x) ntohll(x)
+#		define le64toh(x) (x)
+
+#	elif BYTE_ORDER == BIG_ENDIAN
+
+		/* that would be xbox 360 */
+#		define htobe16(x) (x)
+#		define htole16(x) __builtin_bswap16(x)
+#		define be16toh(x) (x)
+#		define le16toh(x) __builtin_bswap16(x)
+ 
+#		define htobe32(x) (x)
+#		define htole32(x) __builtin_bswap32(x)
+#		define be32toh(x) (x)
+#		define le32toh(x) __builtin_bswap32(x)
+ 
+#		define htobe64(x) (x)
+#		define htole64(x) __builtin_bswap64(x)
+#		define be64toh(x) (x)
+#		define le64toh(x) __builtin_bswap64(x)
+
+#	else
+
+#		error byte order not supported
+
+#	endif
+
+#	define __BYTE_ORDER    BYTE_ORDER
+#	define __BIG_ENDIAN    BIG_ENDIAN
+#	define __LITTLE_ENDIAN LITTLE_ENDIAN
+#	define __PDP_ENDIAN    PDP_ENDIAN
+
+#else
+
+#	error platform not supported
+
+#endif
+
+#endif
diff -urN apt-2.1.5/apt-pkg/getservbyport_r.cc apt/apt-pkg/getservbyport_r.cc
--- apt-2.1.5/apt-pkg/getservbyport_r.cc	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/getservbyport_r.cc	2020-06-02 23:06:58.410093211 -0400
@@ -0,0 +1,59 @@
+#define _GNU_SOURCE
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <inttypes.h>
+#include <errno.h>
+#include <string.h>
+
+#ifndef HAVE_GETSERVBYPORT_R
+
+extern "C" int getservbyport_r(int port, const char *prots,
+	struct servent *se, char *buf, size_t buflen, struct servent **res)
+{
+	int i;
+	struct sockaddr_in sin = {
+		.sin_family = AF_INET,
+		.sin_port = (in_port_t) port,
+	};
+
+	if (!prots) {
+		int r = getservbyport_r(port, "tcp", se, buf, buflen, res);
+		if (r) r = getservbyport_r(port, "udp", se, buf, buflen, res);
+		return r;
+	}
+
+	/* Align buffer */
+	i = (uintptr_t)buf & sizeof(char *)-1;
+	if (!i) i = sizeof(char *);
+	if (buflen < 3*sizeof(char *)-i)
+		return ERANGE;
+	buf += sizeof(char *)-i;
+	buflen -= sizeof(char *)-i;
+
+	if (strcmp(prots, "tcp") && strcmp(prots, "udp")) return EINVAL;
+
+	se->s_port = port;
+	se->s_proto = (char *)prots;
+	se->s_aliases = (char **)buf;
+	buf += 2*sizeof(char *);
+	buflen -= 2*sizeof(char *);
+	se->s_aliases[1] = 0;
+	se->s_aliases[0] = se->s_name = buf;
+
+	switch (getnameinfo((const struct sockaddr *) &sin, sizeof sin, 0, 0, buf, buflen,
+		strcmp(prots, "udp") ? 0 : NI_DGRAM)) {
+	case EAI_MEMORY:
+	case EAI_SYSTEM:
+		return ENOMEM;
+	default:
+		return ENOENT;
+	case 0:
+		break;
+	}
+
+	*res = se;
+	return 0;
+}
+#endif
diff -urN apt-2.1.5/apt-pkg/indexfile.cc apt/apt-pkg/indexfile.cc
--- apt-2.1.5/apt-pkg/indexfile.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-pkg/indexfile.cc	2020-06-02 23:06:58.410093211 -0400
@@ -174,6 +174,8 @@
 									/*}}}*/
 std::string pkgDebianIndexTargetFile::ArchiveURI(std::string const &File) const/*{{{*/
 {
+   if ((APT::String::Startswith(Target.Option(IndexTarget::REPO_URI), "http://") && APT::String::Startswith(File, "http://")) || APT::String::Startswith(File, "https://"))
+      return File;
    return Target.Option(IndexTarget::REPO_URI) + File;
 }
 									/*}}}*/
diff -urN apt-2.1.5/apt-pkg/memrchr.cc apt/apt-pkg/memrchr.cc
--- apt-2.1.5/apt-pkg/memrchr.cc	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/memrchr.cc	2020-06-02 23:06:58.410093211 -0400
@@ -0,0 +1,158 @@
+/* memrchr -- find the last occurrence of a byte in a memory block
+
+   Copyright (C) 1991, 1993, 1996-1997, 1999-2000, 2003-2015 Free Software
+   Foundation, Inc.
+
+   Based on strlen implementation by Torbjorn Granlund (tege@sics.se),
+   with help from Dan Sahlin (dan@sics.se) and
+   commentary by Jim Blandy (jimb@ai.mit.edu);
+   adaptation to memchr suggested by Dick Karpinski (dick@cca.ucsf.edu),
+   and implemented by Roland McGrath (roland@ai.mit.edu).
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#ifndef HAVE_MEMRCHR
+#define reg_char char
+
+#include <string.h>
+#include <limits.h>
+#include <apt-pkg/missing.h>
+
+#undef __memrchr
+#ifdef _LIBC
+# undef memrchr
+#endif
+
+#ifndef weak_alias
+# define __memrchr memrchr
+#endif
+
+/* Search no more than N bytes of S for C.  */
+extern "C" void *
+memrchr (const void *s, int c_in, size_t n)
+{
+  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned
+     long instead of a 64-bit uintmax_t tends to give better
+     performance.  On 64-bit hardware, unsigned long is generally 64
+     bits already.  Change this typedef to experiment with
+     performance.  */
+  typedef unsigned long int longword;
+
+  const unsigned char *char_ptr;
+  const longword *longword_ptr;
+  longword repeated_one;
+  longword repeated_c;
+  unsigned reg_char c;
+
+  c = (unsigned char) c_in;
+
+  /* Handle the last few bytes by reading one byte at a time.
+     Do this until CHAR_PTR is aligned on a longword boundary.  */
+  for (char_ptr = (const unsigned char *) s + n;
+       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;
+       --n)
+    if (*--char_ptr == c)
+      return (void *) char_ptr;
+
+  longword_ptr = (const longword *) char_ptr;
+
+  /* All these elucidatory comments refer to 4-byte longwords,
+     but the theory applies equally well to any size longwords.  */
+
+  /* Compute auxiliary longword values:
+     repeated_one is a value which has a 1 in every byte.
+     repeated_c has c in every byte.  */
+  repeated_one = 0x01010101;
+  repeated_c = c | (c << 8);
+  repeated_c |= repeated_c << 16;
+  if (0xffffffffU < (longword) -1)
+    {
+      repeated_one |= repeated_one << 31 << 1;
+      repeated_c |= repeated_c << 31 << 1;
+      if (8 < sizeof (longword))
+        {
+          size_t i;
+
+          for (i = 64; i < sizeof (longword) * 8; i *= 2)
+            {
+              repeated_one |= repeated_one << i;
+              repeated_c |= repeated_c << i;
+            }
+        }
+    }
+
+  /* Instead of the traditional loop which tests each byte, we will test a
+     longword at a time.  The tricky part is testing if *any of the four*
+     bytes in the longword in question are equal to c.  We first use an xor
+     with repeated_c.  This reduces the task to testing whether *any of the
+     four* bytes in longword1 is zero.
+
+     We compute tmp =
+       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).
+     That is, we perform the following operations:
+       1. Subtract repeated_one.
+       2. & ~longword1.
+       3. & a mask consisting of 0x80 in every byte.
+     Consider what happens in each byte:
+       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,
+         and step 3 transforms it into 0x80.  A carry can also be propagated
+         to more significant bytes.
+       - If a byte of longword1 is nonzero, let its lowest 1 bit be at
+         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,
+         the byte ends in a single bit of value 0 and k bits of value 1.
+         After step 2, the result is just k bits of value 1: 2^k - 1.  After
+         step 3, the result is 0.  And no carry is produced.
+     So, if longword1 has only non-zero bytes, tmp is zero.
+     Whereas if longword1 has a zero byte, call j the position of the least
+     significant zero byte.  Then the result has a zero at positions 0, ...,
+     j-1 and a 0x80 at position j.  We cannot predict the result at the more
+     significant bytes (positions j+1..3), but it does not matter since we
+     already have a non-zero bit at position 8*j+7.
+
+     So, the test whether any byte in longword1 is zero is equivalent to
+     testing whether tmp is nonzero.  */
+
+  while (n >= sizeof (longword))
+    {
+      longword longword1 = *--longword_ptr ^ repeated_c;
+
+      if ((((longword1 - repeated_one) & ~longword1)
+           & (repeated_one << 7)) != 0)
+        {
+          longword_ptr++;
+          break;
+        }
+      n -= sizeof (longword);
+    }
+
+  char_ptr = (const unsigned char *) longword_ptr;
+
+  /* At this point, we know that either n < sizeof (longword), or one of the
+     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian
+     machines, we could determine the first such byte without any further
+     memory accesses, just by looking at the tmp result from the last loop
+     iteration.  But this does not work on big-endian machines.  Choose code
+     that works in both cases.  */
+
+  while (n-- > 0)
+    {
+      if (*--char_ptr == c)
+        return (void *) char_ptr;
+    }
+
+  return NULL;
+}
+#endif
diff -urN apt-2.1.5/apt-pkg/missing.h apt/apt-pkg/missing.h
--- apt-2.1.5/apt-pkg/missing.h	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/missing.h	2020-06-02 23:06:58.410093211 -0400
@@ -0,0 +1,27 @@
+#define _GNU_SOURCE
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <inttypes.h>
+#include <errno.h>
+#include <string.h>
+#include <apt-pkg/macros.h>
+
+#ifndef PKGLIB_MISSING_H
+#define PKGLIB_MISSING_H
+
+extern "C" {
+	APT_PUBLIC void *memrchr(const void *s, int c, size_t n);
+	void *rawmemchr(const void *s, int c);
+	char *strchrnul(const char *s, int c);
+	int getservbyport_r(int port, const char *prots, struct servent *se, char *buf, size_t buflen, struct servent **res);
+}
+
+typedef void (*sighandler_t)(int);
+
+extern char **environ;
+
+#define AI_IDN 0x0040
+
+#endif
+
diff -urN apt-2.1.5/apt-pkg/nameser_compat.h apt/apt-pkg/nameser_compat.h
--- apt-2.1.5/apt-pkg/nameser_compat.h	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/nameser_compat.h	2020-06-02 23:06:58.410093211 -0400
@@ -0,0 +1,187 @@
+/* Copyright (c) 1983, 1989
+ *    The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*%
+ *      from nameser.h	8.1 (Berkeley) 6/2/93
+ *	$BINDId: nameser_compat.h,v 8.11 1999/01/02 08:00:58 vixie Exp $
+ */
+
+#ifndef _ARPA_NAMESER_COMPAT_
+#define	_ARPA_NAMESER_COMPAT_
+
+#define	__BIND		19950621	/*%< (DEAD) interface version stamp. */
+
+#include <apt-pkg/endian.h>
+
+/*%
+ * Structure for query header.  The order of the fields is machine- and
+ * compiler-dependent, depending on the byte/bit order and the layout
+ * of bit fields.  We use bit fields only in int variables, as this
+ * is all ANSI requires.  This requires a somewhat confusing rearrangement.
+ */
+
+typedef struct {
+	unsigned	id :16;		/*%< query identification number */
+#if BYTE_ORDER == BIG_ENDIAN
+			/* fields in third byte */
+	unsigned	qr: 1;		/*%< response flag */
+	unsigned	opcode: 4;	/*%< purpose of message */
+	unsigned	aa: 1;		/*%< authoritive answer */
+	unsigned	tc: 1;		/*%< truncated message */
+	unsigned	rd: 1;		/*%< recursion desired */
+			/* fields in fourth byte */
+	unsigned	ra: 1;		/*%< recursion available */
+	unsigned	unused :1;	/*%< unused bits (MBZ as of 4.9.3a3) */
+	unsigned	ad: 1;		/*%< authentic data from named */
+	unsigned	cd: 1;		/*%< checking disabled by resolver */
+	unsigned	rcode :4;	/*%< response code */
+#endif
+#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
+			/* fields in third byte */
+	unsigned	rd :1;		/*%< recursion desired */
+	unsigned	tc :1;		/*%< truncated message */
+	unsigned	aa :1;		/*%< authoritive answer */
+	unsigned	opcode :4;	/*%< purpose of message */
+	unsigned	qr :1;		/*%< response flag */
+			/* fields in fourth byte */
+	unsigned	rcode :4;	/*%< response code */
+	unsigned	cd: 1;		/*%< checking disabled by resolver */
+	unsigned	ad: 1;		/*%< authentic data from named */
+	unsigned	unused :1;	/*%< unused bits (MBZ as of 4.9.3a3) */
+	unsigned	ra :1;		/*%< recursion available */
+#endif
+			/* remaining bytes */
+	unsigned	qdcount :16;	/*%< number of question entries */
+	unsigned	ancount :16;	/*%< number of answer entries */
+	unsigned	nscount :16;	/*%< number of authority entries */
+	unsigned	arcount :16;	/*%< number of resource entries */
+} HEADER;
+
+#define PACKETSZ	NS_PACKETSZ
+#define MAXDNAME	NS_MAXDNAME
+#define MAXCDNAME	NS_MAXCDNAME
+#define MAXLABEL	NS_MAXLABEL
+#define	HFIXEDSZ	NS_HFIXEDSZ
+#define QFIXEDSZ	NS_QFIXEDSZ
+#define RRFIXEDSZ	NS_RRFIXEDSZ
+#define	INT32SZ		NS_INT32SZ
+#define	INT16SZ		NS_INT16SZ
+#define INT8SZ		NS_INT8SZ
+#define	INADDRSZ	NS_INADDRSZ
+#define	IN6ADDRSZ	NS_IN6ADDRSZ
+#define	INDIR_MASK	NS_CMPRSFLGS
+#define NAMESERVER_PORT	NS_DEFAULTPORT
+
+#define S_ZONE		ns_s_zn
+#define S_PREREQ	ns_s_pr
+#define S_UPDATE	ns_s_ud
+#define S_ADDT		ns_s_ar
+
+#define QUERY		ns_o_query
+#define IQUERY		ns_o_iquery
+#define STATUS		ns_o_status
+#define	NS_NOTIFY_OP	ns_o_notify
+#define	NS_UPDATE_OP	ns_o_update
+
+#define NOERROR		ns_r_noerror
+#define FORMERR		ns_r_formerr
+#define SERVFAIL	ns_r_servfail
+#define NXDOMAIN	ns_r_nxdomain
+#define NOTIMP		ns_r_notimpl
+#define REFUSED		ns_r_refused
+#define YXDOMAIN	ns_r_yxdomain
+#define YXRRSET		ns_r_yxrrset
+#define NXRRSET		ns_r_nxrrset
+#define NOTAUTH		ns_r_notauth
+#define NOTZONE		ns_r_notzone
+/*#define BADSIG		ns_r_badsig*/
+/*#define BADKEY		ns_r_badkey*/
+/*#define BADTIME		ns_r_badtime*/
+
+
+#define DELETE		ns_uop_delete
+#define ADD		ns_uop_add
+
+#define T_A		ns_t_a
+#define T_NS		ns_t_ns
+#define T_MD		ns_t_md
+#define T_MF		ns_t_mf
+#define T_CNAME		ns_t_cname
+#define T_SOA		ns_t_soa
+#define T_MB		ns_t_mb
+#define T_MG		ns_t_mg
+#define T_MR		ns_t_mr
+#define T_NULL		ns_t_null
+#define T_WKS		ns_t_wks
+#define T_PTR		ns_t_ptr
+#define T_HINFO		ns_t_hinfo
+#define T_MINFO		ns_t_minfo
+#define T_MX		ns_t_mx
+#define T_TXT		ns_t_txt
+#define	T_RP		ns_t_rp
+#define T_AFSDB		ns_t_afsdb
+#define T_X25		ns_t_x25
+#define T_ISDN		ns_t_isdn
+#define T_RT		ns_t_rt
+#define T_NSAP		ns_t_nsap
+#define T_NSAP_PTR	ns_t_nsap_ptr
+#define	T_SIG		ns_t_sig
+#define	T_KEY		ns_t_key
+#define	T_PX		ns_t_px
+#define	T_GPOS		ns_t_gpos
+#define	T_AAAA		ns_t_aaaa
+#define	T_LOC		ns_t_loc
+#define	T_NXT		ns_t_nxt
+#define	T_EID		ns_t_eid
+#define	T_NIMLOC	ns_t_nimloc
+#define	T_SRV		ns_t_srv
+#define T_ATMA		ns_t_atma
+#define T_NAPTR		ns_t_naptr
+#define T_A6		ns_t_a6
+#define T_DNAME		ns_t_dname
+#define	T_TSIG		ns_t_tsig
+#define	T_IXFR		ns_t_ixfr
+#define T_AXFR		ns_t_axfr
+#define T_MAILB		ns_t_mailb
+#define T_MAILA		ns_t_maila
+#define T_ANY		ns_t_any
+
+#define C_IN		ns_c_in
+#define C_CHAOS		ns_c_chaos
+#define C_HS		ns_c_hs
+/* BIND_UPDATE */
+#define C_NONE		ns_c_none
+#define C_ANY		ns_c_any
+
+#define	GETSHORT		NS_GET16
+#define	GETLONG			NS_GET32
+#define	PUTSHORT		NS_PUT16
+#define	PUTLONG			NS_PUT32
+
+#endif /* _ARPA_NAMESER_COMPAT_ */
+/*! \file */
diff -urN apt-2.1.5/apt-pkg/rawmemchr.cc apt/apt-pkg/rawmemchr.cc
--- apt-2.1.5/apt-pkg/rawmemchr.cc	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/rawmemchr.cc	2020-06-02 23:06:58.410093211 -0400
@@ -0,0 +1,139 @@
+/* Searching in a string.
+   Copyright (C) 2008-2015 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#ifndef HAVE_RAWMEMCHR
+
+/* Specification.  */
+#include <string.h>
+
+/* Find the first occurrence of C in S.  */
+extern "C" void *
+rawmemchr (const void *s, int c_in)
+{
+  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned
+     long instead of a 64-bit uintmax_t tends to give better
+     performance.  On 64-bit hardware, unsigned long is generally 64
+     bits already.  Change this typedef to experiment with
+     performance.  */
+  typedef unsigned long int longword;
+
+  const unsigned char *char_ptr;
+  const longword *longword_ptr;
+  longword repeated_one;
+  longword repeated_c;
+  unsigned char c;
+
+  c = (unsigned char) c_in;
+
+  /* Handle the first few bytes by reading one byte at a time.
+     Do this until CHAR_PTR is aligned on a longword boundary.  */
+  for (char_ptr = (const unsigned char *) s;
+       (size_t) char_ptr % sizeof (longword) != 0;
+       ++char_ptr)
+    if (*char_ptr == c)
+      return (void *) char_ptr;
+
+  longword_ptr = (const longword *) char_ptr;
+
+  /* All these elucidatory comments refer to 4-byte longwords,
+     but the theory applies equally well to any size longwords.  */
+
+  /* Compute auxiliary longword values:
+     repeated_one is a value which has a 1 in every byte.
+     repeated_c has c in every byte.  */
+  repeated_one = 0x01010101;
+  repeated_c = c | (c << 8);
+  repeated_c |= repeated_c << 16;
+  if (0xffffffffU < (longword) -1)
+    {
+      repeated_one |= repeated_one << 31 << 1;
+      repeated_c |= repeated_c << 31 << 1;
+      if (8 < sizeof (longword))
+        {
+          size_t i;
+
+          for (i = 64; i < sizeof (longword) * 8; i *= 2)
+            {
+              repeated_one |= repeated_one << i;
+              repeated_c |= repeated_c << i;
+            }
+        }
+    }
+
+  /* Instead of the traditional loop which tests each byte, we will
+     test a longword at a time.  The tricky part is testing if *any of
+     the four* bytes in the longword in question are equal to NUL or
+     c.  We first use an xor with repeated_c.  This reduces the task
+     to testing whether *any of the four* bytes in longword1 is zero.
+
+     We compute tmp =
+       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).
+     That is, we perform the following operations:
+       1. Subtract repeated_one.
+       2. & ~longword1.
+       3. & a mask consisting of 0x80 in every byte.
+     Consider what happens in each byte:
+       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,
+         and step 3 transforms it into 0x80.  A carry can also be propagated
+         to more significant bytes.
+       - If a byte of longword1 is nonzero, let its lowest 1 bit be at
+         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,
+         the byte ends in a single bit of value 0 and k bits of value 1.
+         After step 2, the result is just k bits of value 1: 2^k - 1.  After
+         step 3, the result is 0.  And no carry is produced.
+     So, if longword1 has only non-zero bytes, tmp is zero.
+     Whereas if longword1 has a zero byte, call j the position of the least
+     significant zero byte.  Then the result has a zero at positions 0, ...,
+     j-1 and a 0x80 at position j.  We cannot predict the result at the more
+     significant bytes (positions j+1..3), but it does not matter since we
+     already have a non-zero bit at position 8*j+7.
+
+     The test whether any byte in longword1 is zero is equivalent
+     to testing whether tmp is nonzero.
+
+     This test can read beyond the end of a string, depending on where
+     C_IN is encountered.  However, this is considered safe since the
+     initialization phase ensured that the read will be aligned,
+     therefore, the read will not cross page boundaries and will not
+     cause a fault.  */
+
+  while (1)
+    {
+      longword longword1 = *longword_ptr ^ repeated_c;
+
+      if ((((longword1 - repeated_one) & ~longword1)
+           & (repeated_one << 7)) != 0)
+        break;
+      longword_ptr++;
+    }
+
+  char_ptr = (const unsigned char *) longword_ptr;
+
+  /* At this point, we know that one of the sizeof (longword) bytes
+     starting at char_ptr is == c.  On little-endian machines, we
+     could determine the first such byte without any further memory
+     accesses, just by looking at the tmp result from the last loop
+     iteration.  But this does not work on big-endian machines.
+     Choose code that works in both cases.  */
+
+  char_ptr = (unsigned char *) longword_ptr;
+  while (*char_ptr != c)
+    char_ptr++;
+  return (void *) char_ptr;
+}
+#endif
diff -urN apt-2.1.5/apt-pkg/strchrnul.cc apt/apt-pkg/strchrnul.cc
--- apt-2.1.5/apt-pkg/strchrnul.cc	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/strchrnul.cc	2020-06-02 23:06:58.410093211 -0400
@@ -0,0 +1,147 @@
+/* Searching in a string.
+   Copyright (C) 2003, 2007-2015 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#ifndef HAVE_STRCHRNUL
+
+/* Specification.  */
+#include <string.h>
+
+#include <apt-pkg/missing.h>
+
+/* Find the first occurrence of C in S or the final NUL byte.  */
+extern "C" char *
+strchrnul (const char *s, int c_in)
+{
+  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned
+     long instead of a 64-bit uintmax_t tends to give better
+     performance.  On 64-bit hardware, unsigned long is generally 64
+     bits already.  Change this typedef to experiment with
+     performance.  */
+  typedef unsigned long int longword;
+
+  const unsigned char *char_ptr;
+  const longword *longword_ptr;
+  longword repeated_one;
+  longword repeated_c;
+  unsigned char c;
+
+  c = (unsigned char) c_in;
+  if (!c)
+    return (char*) rawmemchr (s, 0);
+
+  /* Handle the first few bytes by reading one byte at a time.
+     Do this until CHAR_PTR is aligned on a longword boundary.  */
+  for (char_ptr = (const unsigned char *) s;
+       (size_t) char_ptr % sizeof (longword) != 0;
+       ++char_ptr)
+    if (!*char_ptr || *char_ptr == c)
+      return (char *) char_ptr;
+
+  longword_ptr = (const longword *) char_ptr;
+
+  /* All these elucidatory comments refer to 4-byte longwords,
+     but the theory applies equally well to any size longwords.  */
+
+  /* Compute auxiliary longword values:
+     repeated_one is a value which has a 1 in every byte.
+     repeated_c has c in every byte.  */
+  repeated_one = 0x01010101;
+  repeated_c = c | (c << 8);
+  repeated_c |= repeated_c << 16;
+  if (0xffffffffU < (longword) -1)
+    {
+      repeated_one |= repeated_one << 31 << 1;
+      repeated_c |= repeated_c << 31 << 1;
+      if (8 < sizeof (longword))
+        {
+          size_t i;
+
+          for (i = 64; i < sizeof (longword) * 8; i *= 2)
+            {
+              repeated_one |= repeated_one << i;
+              repeated_c |= repeated_c << i;
+            }
+        }
+    }
+
+  /* Instead of the traditional loop which tests each byte, we will
+     test a longword at a time.  The tricky part is testing if *any of
+     the four* bytes in the longword in question are equal to NUL or
+     c.  We first use an xor with repeated_c.  This reduces the task
+     to testing whether *any of the four* bytes in longword1 or
+     longword2 is zero.
+
+     Let's consider longword1.  We compute tmp =
+       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).
+     That is, we perform the following operations:
+       1. Subtract repeated_one.
+       2. & ~longword1.
+       3. & a mask consisting of 0x80 in every byte.
+     Consider what happens in each byte:
+       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,
+         and step 3 transforms it into 0x80.  A carry can also be propagated
+         to more significant bytes.
+       - If a byte of longword1 is nonzero, let its lowest 1 bit be at
+         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,
+         the byte ends in a single bit of value 0 and k bits of value 1.
+         After step 2, the result is just k bits of value 1: 2^k - 1.  After
+         step 3, the result is 0.  And no carry is produced.
+     So, if longword1 has only non-zero bytes, tmp is zero.
+     Whereas if longword1 has a zero byte, call j the position of the least
+     significant zero byte.  Then the result has a zero at positions 0, ...,
+     j-1 and a 0x80 at position j.  We cannot predict the result at the more
+     significant bytes (positions j+1..3), but it does not matter since we
+     already have a non-zero bit at position 8*j+7.
+
+     The test whether any byte in longword1 or longword2 is zero is equivalent
+     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine
+     this into a single test, whether (tmp1 | tmp2) is nonzero.
+
+     This test can read more than one byte beyond the end of a string,
+     depending on where the terminating NUL is encountered.  However,
+     this is considered safe since the initialization phase ensured
+     that the read will be aligned, therefore, the read will not cross
+     page boundaries and will not cause a fault.  */
+
+  while (1)
+    {
+      longword longword1 = *longword_ptr ^ repeated_c;
+      longword longword2 = *longword_ptr;
+
+      if (((((longword1 - repeated_one) & ~longword1)
+            | ((longword2 - repeated_one) & ~longword2))
+           & (repeated_one << 7)) != 0)
+        break;
+      longword_ptr++;
+    }
+
+  char_ptr = (const unsigned char *) longword_ptr;
+
+  /* At this point, we know that one of the sizeof (longword) bytes
+     starting at char_ptr is == 0 or == c.  On little-endian machines,
+     we could determine the first such byte without any further memory
+     accesses, just by looking at the tmp result from the last loop
+     iteration.  But this does not work on big-endian machines.
+     Choose code that works in both cases.  */
+
+  char_ptr = (unsigned char *) longword_ptr;
+  while (*char_ptr && (*char_ptr != c))
+    char_ptr++;
+  return (char *) char_ptr;
+}
+#endif
diff -urN apt-2.1.5/apt-private/CMakeLists.txt apt/apt-private/CMakeLists.txt
--- apt-2.1.5/apt-private/CMakeLists.txt	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-private/CMakeLists.txt	2020-06-02 23:06:58.410093211 -0400
@@ -5,14 +5,14 @@
 # Definition of the C++ files used to build the library - note that this
 # is expanded at CMake time, so you have to rerun cmake if you add or remove
 # a file (you can just run cmake . in the build directory)
-file(GLOB_RECURSE library "*.cc")
+file(GLOB_RECURSE library "*.cc" "*.mm")
 file(GLOB_RECURSE headers "*.h")
 
 # Create a library using the C++ files
 add_library(apt-private SHARED ${library})
 
 # Link the library and set the SONAME
-target_link_libraries(apt-private PUBLIC apt-pkg)
+target_link_libraries(apt-private PUBLIC apt-pkg "-framework Foundation")
 set_target_properties(apt-private PROPERTIES VERSION ${MAJOR}.${MINOR})
 set_target_properties(apt-private PROPERTIES SOVERSION ${MAJOR})
 set_target_properties(apt-private PROPERTIES CXX_VISIBILITY_PRESET hidden)
diff -urN apt-2.1.5/apt-private/private-output.cc apt/apt-private/private-output.cc
--- apt-2.1.5/apt-private/private-output.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-private/private-output.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,801 +0,0 @@
-// Include files							/*{{{*/
-#include <config.h>
-
-#include <apt-pkg/cachefile.h>
-#include <apt-pkg/configuration.h>
-#include <apt-pkg/depcache.h>
-#include <apt-pkg/error.h>
-#include <apt-pkg/pkgcache.h>
-#include <apt-pkg/pkgrecords.h>
-#include <apt-pkg/policy.h>
-#include <apt-pkg/strutl.h>
-
-#include <apt-private/private-cachefile.h>
-#include <apt-private/private-output.h>
-
-#include <iomanip>
-#include <iostream>
-#include <langinfo.h>
-#include <regex.h>
-#include <signal.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <unistd.h>
-
-#include <sstream>
-
-#include <apti18n.h>
-									/*}}}*/
-
-using namespace std;
-
-std::ostream c0out(0);
-std::ostream c1out(0);
-std::ostream c2out(0);
-std::ofstream devnull("/dev/null");
-
-
-unsigned int ScreenWidth = 80 - 1; /* - 1 for the cursor */
-
-// SigWinch - Window size change signal handler				/*{{{*/
-// ---------------------------------------------------------------------
-/* */
-static void SigWinch(int)
-{
-   // Riped from GNU ls
-#ifdef TIOCGWINSZ
-   struct winsize ws;
-  
-   if (ioctl(1, TIOCGWINSZ, &ws) != -1 && ws.ws_col >= 5)
-      ScreenWidth = ws.ws_col - 1;
-#endif
-}
-									/*}}}*/
-bool InitOutput(std::basic_streambuf<char> * const out)			/*{{{*/
-{
-   if (!isatty(STDOUT_FILENO) && _config->FindI("quiet", -1) == -1)
-      _config->Set("quiet","1");
-
-   c0out.rdbuf(out);
-   c1out.rdbuf(out);
-   c2out.rdbuf(out);
-   if (_config->FindI("quiet",0) > 0)
-      c0out.rdbuf(devnull.rdbuf());
-   if (_config->FindI("quiet",0) > 1)
-      c1out.rdbuf(devnull.rdbuf());
-
-   // deal with window size changes
-   auto cols = getenv("COLUMNS");
-   if (cols != nullptr)
-   {
-      char * colends;
-      auto const sw = strtoul(cols, &colends, 10);
-      if (*colends != '\0' || sw == 0)
-      {
-	 _error->Warning("Environment variable COLUMNS was ignored as it has an invalid value: \"%s\"", cols);
-	 cols = nullptr;
-      }
-      else
-	 ScreenWidth = sw;
-   }
-   if (cols == nullptr)
-   {
-      signal(SIGWINCH,SigWinch);
-      SigWinch(0);
-   }
-
-   if(!isatty(1))
-   {
-      _config->Set("APT::Color", "false");
-      _config->Set("APT::Color::Highlight", "");
-      _config->Set("APT::Color::Neutral", "");
-   } else {
-      // Colors
-      _config->CndSet("APT::Color::Highlight", "\x1B[32m");
-      _config->CndSet("APT::Color::Neutral", "\x1B[0m");
-      
-      _config->CndSet("APT::Color::Red", "\x1B[31m");
-      _config->CndSet("APT::Color::Green", "\x1B[32m");
-      _config->CndSet("APT::Color::Yellow", "\x1B[33m");
-      _config->CndSet("APT::Color::Blue", "\x1B[34m");
-      _config->CndSet("APT::Color::Magenta", "\x1B[35m");
-      _config->CndSet("APT::Color::Cyan", "\x1B[36m");
-      _config->CndSet("APT::Color::White", "\x1B[37m");
-   }
-
-   return true;
-}
-									/*}}}*/
-static std::string GetArchiveSuite(pkgCacheFile &/*CacheFile*/, pkgCache::VerIterator ver) /*{{{*/
-{
-   std::string suite = "";
-   if (ver && ver.FileList())
-   {
-      pkgCache::VerFileIterator VF = ver.FileList();
-      for (; VF.end() == false ; ++VF)
-      {
-         if(VF.File() == NULL || VF.File().Archive() == NULL)
-            suite = suite + "," + _("unknown");
-         else
-            suite = suite + "," + VF.File().Archive();
-         //suite = VF.File().Archive();
-      }
-      suite = suite.erase(0, 1);
-   }
-   return suite;
-}
-									/*}}}*/
-static std::string GetFlagsStr(pkgCacheFile &CacheFile, pkgCache::PkgIterator P)/*{{{*/
-{
-   pkgDepCache *DepCache = CacheFile.GetDepCache();
-   pkgDepCache::StateCache &state = (*DepCache)[P];
-
-   std::string flags_str;
-   if (state.NowBroken())
-      flags_str = "B";
-   if (P.CurrentVer() && state.Upgradable() && state.CandidateVer != NULL)
-      flags_str = "g";
-   else if (P.CurrentVer() != NULL)
-      flags_str = "i";
-   else
-      flags_str = "-";
-   return flags_str;
-}
-									/*}}}*/
-static std::string GetCandidateVersion(pkgCacheFile &CacheFile, pkgCache::PkgIterator P)/*{{{*/
-{
-   pkgPolicy *policy = CacheFile.GetPolicy();
-   pkgCache::VerIterator cand = policy->GetCandidateVer(P);
-
-   return cand ? cand.VerStr() : "(none)";
-}
-									/*}}}*/
-static std::string GetInstalledVersion(pkgCacheFile &/*CacheFile*/, pkgCache::PkgIterator P)/*{{{*/
-{
-   pkgCache::VerIterator inst = P.CurrentVer();
-
-   return inst ? inst.VerStr() : "(none)";
-}
-									/*}}}*/
-static std::string GetVersion(pkgCacheFile &/*CacheFile*/, pkgCache::VerIterator V)/*{{{*/
-{
-   pkgCache::PkgIterator P = V.ParentPkg();
-   if (V == P.CurrentVer())
-   {
-      std::string inst_str = DeNull(V.VerStr());
-#if 0 // FIXME: do we want this or something like this?
-      pkgDepCache *DepCache = CacheFile.GetDepCache();
-      pkgDepCache::StateCache &state = (*DepCache)[P];
-      if (state.Upgradable())
-         return "**"+inst_str;
-#endif
-      return inst_str;
-   }
-
-   if(V)
-      return DeNull(V.VerStr());
-   return "(none)";
-}
-									/*}}}*/
-static std::string GetArchitecture(pkgCacheFile &CacheFile, pkgCache::PkgIterator P)/*{{{*/
-{
-   if (P->CurrentVer == 0)
-   {
-      pkgDepCache * const DepCache = CacheFile.GetDepCache();
-      pkgDepCache::StateCache const &state = (*DepCache)[P];
-      if (state.CandidateVer != NULL)
-      {
-	 pkgCache::VerIterator const CandV(CacheFile, state.CandidateVer);
-	 return CandV.Arch();
-      }
-      else
-      {
-	 pkgCache::VerIterator const V = P.VersionList();
-	 if (V.end() == false)
-	    return V.Arch();
-	 else
-	    return P.Arch();
-      }
-   }
-   else
-      return P.CurrentVer().Arch();
-}
-									/*}}}*/
-static std::string GetShortDescription(pkgCacheFile &CacheFile, pkgRecords &records, pkgCache::PkgIterator P)/*{{{*/
-{
-   pkgPolicy *policy = CacheFile.GetPolicy();
-
-   pkgCache::VerIterator ver;
-   if (P.CurrentVer())
-      ver = P.CurrentVer();
-   else
-      ver = policy->GetCandidateVer(P);
-
-   std::string ShortDescription = "(none)";
-   if(ver)
-   {
-      pkgCache::DescIterator const Desc = ver.TranslatedDescription();
-      if (Desc.end() == false)
-      {
-	 pkgRecords::Parser & parser = records.Lookup(Desc.FileList());
-	 ShortDescription = parser.ShortDesc();
-      }
-   }
-   return ShortDescription;
-}
-									/*}}}*/
-static std::string GetLongDescription(pkgCacheFile &CacheFile, pkgRecords &records, pkgCache::PkgIterator P)/*{{{*/
-{
-   pkgPolicy *policy = CacheFile.GetPolicy();
-
-   pkgCache::VerIterator ver;
-   if (P->CurrentVer != 0)
-      ver = P.CurrentVer();
-   else
-      ver = policy->GetCandidateVer(P);
-
-   std::string const EmptyDescription = "(none)";
-   if(ver.end() == true)
-      return EmptyDescription;
-
-   pkgCache::DescIterator const Desc = ver.TranslatedDescription();
-   if (Desc.end() == false)
-   {
-      pkgRecords::Parser & parser = records.Lookup(Desc.FileList());
-      std::string const longdesc = parser.LongDesc();
-      if (longdesc.empty() == false)
-	 return SubstVar(longdesc, "\n ", "\n  ");
-   }
-   return EmptyDescription;
-}
-									/*}}}*/
-void ListSingleVersion(pkgCacheFile &CacheFile, pkgRecords &records,	/*{{{*/
-                       pkgCache::VerIterator const &V, std::ostream &out,
-                       std::string const &format)
-{
-   pkgCache::PkgIterator const P = V.ParentPkg();
-   pkgDepCache * const DepCache = CacheFile.GetDepCache();
-   pkgDepCache::StateCache const &state = (*DepCache)[P];
-
-   std::string output;
-   if (_config->FindB("APT::Cmd::use-format", false))
-      output = _config->Find("APT::Cmd::format", "${db::Status-Abbrev} ${Package} ${Version} ${Origin} ${Description}");
-   else
-      output = format;
-
-   // FIXME: some of these names are really icky – and all is nowhere documented
-   output = SubstVar(output, "${db::Status-Abbrev}", GetFlagsStr(CacheFile, P));
-   output = SubstVar(output, "${Package}", P.Name());
-   std::string const ArchStr = GetArchitecture(CacheFile, P);
-   output = SubstVar(output, "${Architecture}", ArchStr);
-   std::string const InstalledVerStr = GetInstalledVersion(CacheFile, P);
-   output = SubstVar(output, "${installed:Version}", InstalledVerStr);
-   std::string const CandidateVerStr = GetCandidateVersion(CacheFile, P);
-   output = SubstVar(output, "${candidate:Version}", CandidateVerStr);
-   std::string const VersionStr = GetVersion(CacheFile, V);
-   output = SubstVar(output, "${Version}", VersionStr);
-   output = SubstVar(output, "${Origin}", GetArchiveSuite(CacheFile, V));
-
-   std::string StatusStr = "";
-   if (P->CurrentVer != 0)
-   {
-      if (P.CurrentVer() == V)
-      {
-	 if (state.Upgradable() && state.CandidateVer != NULL)
-	    strprintf(StatusStr, _("[installed,upgradable to: %s]"),
-		  CandidateVerStr.c_str());
-	 else if (V.Downloadable() == false)
-	    StatusStr = _("[installed,local]");
-	 else if(V.Automatic() == true && state.Garbage == true)
-	    StatusStr = _("[installed,auto-removable]");
-	 else if ((state.Flags & pkgCache::Flag::Auto) == pkgCache::Flag::Auto)
-	    StatusStr = _("[installed,automatic]");
-	 else
-	    StatusStr = _("[installed]");
-      }
-      else if (state.CandidateVer == V && state.Upgradable())
-	 strprintf(StatusStr, _("[upgradable from: %s]"),
-	       InstalledVerStr.c_str());
-   }
-   else if (V.ParentPkg()->CurrentState == pkgCache::State::ConfigFiles)
-      StatusStr = _("[residual-config]");
-   output = SubstVar(output, "${apt:Status}", StatusStr);
-   output = SubstVar(output, "${color:highlight}", _config->Find("APT::Color::Highlight", ""));
-   output = SubstVar(output, "${color:neutral}", _config->Find("APT::Color::Neutral", ""));
-   output = SubstVar(output, "${Description}", GetShortDescription(CacheFile, records, P));
-   if (output.find("${LongDescription}") != string::npos)
-      output = SubstVar(output, "${LongDescription}", GetLongDescription(CacheFile, records, P));
-   output = SubstVar(output, "${ }${ }", "${ }");
-   output = SubstVar(output, "${ }\n", "\n");
-   output = SubstVar(output, "${ }", " ");
-   if (APT::String::Endswith(output, " ") == true)
-      output.erase(output.length() - 1);
-
-   out << output;
-}
-									/*}}}*/
-// ShowBroken - Debugging aide						/*{{{*/
-// ---------------------------------------------------------------------
-/* This prints out the names of all the packages that are broken along
-   with the name of each broken dependency and a quite version
-   description.
-
-   The output looks like:
- The following packages have unmet dependencies:
-     exim: Depends: libc6 (>= 2.1.94) but 2.1.3-10 is to be installed
-           Depends: libldap2 (>= 2.0.2-2) but it is not going to be installed
-           Depends: libsasl7 but it is not going to be installed
- */
-static void ShowBrokenPackage(ostream &out, pkgCacheFile * const Cache, pkgCache::PkgIterator const &Pkg, bool const Now)
-{
-   if (Now == true)
-   {
-      if ((*Cache)[Pkg].NowBroken() == false)
-	 return;
-   }
-   else
-   {
-      if ((*Cache)[Pkg].InstBroken() == false)
-	 return;
-   }
-
-   // Print out each package and the failed dependencies
-   out << " " << Pkg.FullName(true) << " :";
-   unsigned const Indent = Pkg.FullName(true).size() + 3;
-   bool First = true;
-   pkgCache::VerIterator Ver;
-
-   if (Now == true)
-      Ver = Pkg.CurrentVer();
-   else
-      Ver = (*Cache)[Pkg].InstVerIter(*Cache);
-
-   if (Ver.end() == true)
-   {
-      out << endl;
-      return;
-   }
-
-   for (pkgCache::DepIterator D = Ver.DependsList(); D.end() == false;)
-   {
-      // Compute a single dependency element (glob or)
-      pkgCache::DepIterator Start;
-      pkgCache::DepIterator End;
-      D.GlobOr(Start,End); // advances D
-
-      if ((*Cache)->IsImportantDep(End) == false)
-	 continue;
-
-      if (Now == true)
-      {
-	 if (((*Cache)[End] & pkgDepCache::DepGNow) == pkgDepCache::DepGNow)
-	    continue;
-      }
-      else
-      {
-	 if (((*Cache)[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
-	    continue;
-      }
-
-      bool FirstOr = true;
-      while (1)
-      {
-	 if (First == false)
-	    for (unsigned J = 0; J != Indent; J++)
-	       out << ' ';
-	 First = false;
-
-	 if (FirstOr == false)
-	 {
-	    for (unsigned J = 0; J != strlen(End.DepType()) + 3; J++)
-	       out << ' ';
-	 }
-	 else
-	    out << ' ' << End.DepType() << ": ";
-	 FirstOr = false;
-
-	 out << Start.TargetPkg().FullName(true);
-
-	 // Show a quick summary of the version requirements
-	 if (Start.TargetVer() != 0)
-	    out << " (" << Start.CompType() << " " << Start.TargetVer() << ")";
-
-	 /* Show a summary of the target package if possible. In the case
-	    of virtual packages we show nothing */
-	 pkgCache::PkgIterator Targ = Start.TargetPkg();
-	 if (Targ->ProvidesList == 0)
-	 {
-	    out << ' ';
-	    pkgCache::VerIterator Ver = (*Cache)[Targ].InstVerIter(*Cache);
-	    if (Now == true)
-	       Ver = Targ.CurrentVer();
-
-	    if (Ver.end() == false)
-	    {
-	       if (Now == true)
-		  ioprintf(out,_("but %s is installed"),Ver.VerStr());
-	       else
-		  ioprintf(out,_("but %s is to be installed"),Ver.VerStr());
-	    }
-	    else
-	    {
-	       if ((*Cache)[Targ].CandidateVerIter(*Cache).end() == true)
-	       {
-		  if (Targ->ProvidesList == 0)
-		     out << _("but it is not installable");
-		  else
-		     out << _("but it is a virtual package");
-	       }
-	       else
-		  out << (Now?_("but it is not installed"):_("but it is not going to be installed"));
-	    }
-	 }
-
-	 if (Start != End)
-	    out << _(" or");
-	 out << endl;
-
-	 if (Start == End)
-	    break;
-	 ++Start;
-      }
-   }
-}
-void ShowBroken(ostream &out, CacheFile &Cache, bool const Now)
-{
-   if (Cache->BrokenCount() == 0)
-      return;
-
-   out << _("The following packages have unmet dependencies:") << endl;
-   SortedPackageUniverse Universe(Cache);
-   for (auto const &Pkg: Universe)
-      ShowBrokenPackage(out, &Cache, Pkg, Now);
-}
-void ShowBroken(ostream &out, pkgCacheFile &Cache, bool const Now)
-{
-   if (Cache->BrokenCount() == 0)
-      return;
-
-   out << _("The following packages have unmet dependencies:") << endl;
-   APT::PackageUniverse Universe(Cache);
-   for (auto const &Pkg: Universe)
-      ShowBrokenPackage(out, &Cache, Pkg, Now);
-}
-									/*}}}*/
-// ShowNew - Show packages to newly install				/*{{{*/
-void ShowNew(ostream &out,CacheFile &Cache)
-{
-   SortedPackageUniverse Universe(Cache);
-   ShowList(out,_("The following NEW packages will be installed:"), Universe,
-	 [&Cache](pkgCache::PkgIterator const &Pkg) { return Cache[Pkg].NewInstall(); },
-	 &PrettyFullName,
-	 CandidateVersion(&Cache));
-}
-									/*}}}*/
-// ShowDel - Show packages to delete					/*{{{*/
-void ShowDel(ostream &out,CacheFile &Cache)
-{
-   SortedPackageUniverse Universe(Cache);
-   ShowList(out,_("The following packages will be REMOVED:"), Universe,
-	 [&Cache](pkgCache::PkgIterator const &Pkg) { return Cache[Pkg].Delete(); },
-	 [&Cache](pkgCache::PkgIterator const &Pkg)
-	 {
-	    std::string str = PrettyFullName(Pkg);
-	    if (((*Cache)[Pkg].iFlags & pkgDepCache::Purge) == pkgDepCache::Purge)
-	       str.append("*");
-	    return str;
-	 },
-	 CandidateVersion(&Cache));
-}
-									/*}}}*/
-// ShowKept - Show kept packages					/*{{{*/
-void ShowKept(ostream &out,CacheFile &Cache)
-{
-   SortedPackageUniverse Universe(Cache);
-   ShowList(out,_("The following packages have been kept back:"), Universe,
-	 [&Cache](pkgCache::PkgIterator const &Pkg)
-	 {
-	    return Cache[Pkg].Upgrade() == false &&
-		   Cache[Pkg].Upgradable() == true &&
-		   Pkg->CurrentVer != 0 &&
-		   Cache[Pkg].Delete() == false;
-	 },
-	 &PrettyFullName,
-	 CurrentToCandidateVersion(&Cache));
-}
-									/*}}}*/
-// ShowUpgraded - Show upgraded packages				/*{{{*/
-void ShowUpgraded(ostream &out,CacheFile &Cache)
-{
-   SortedPackageUniverse Universe(Cache);
-   ShowList(out,_("The following packages will be upgraded:"), Universe,
-	 [&Cache](pkgCache::PkgIterator const &Pkg)
-	 {
-	    return Cache[Pkg].Upgrade() == true && Cache[Pkg].NewInstall() == false;
-	 },
-	 &PrettyFullName,
-	 CurrentToCandidateVersion(&Cache));
-}
-									/*}}}*/
-// ShowDowngraded - Show downgraded packages				/*{{{*/
-// ---------------------------------------------------------------------
-/* */
-bool ShowDowngraded(ostream &out,CacheFile &Cache)
-{
-   SortedPackageUniverse Universe(Cache);
-   return ShowList(out,_("The following packages will be DOWNGRADED:"), Universe,
-	 [&Cache](pkgCache::PkgIterator const &Pkg)
-	 {
-	    return Cache[Pkg].Downgrade() == true && Cache[Pkg].NewInstall() == false;
-	 },
-	 &PrettyFullName,
-	 CurrentToCandidateVersion(&Cache));
-}
-									/*}}}*/
-// ShowHold - Show held but changed packages				/*{{{*/
-bool ShowHold(ostream &out,CacheFile &Cache)
-{
-   SortedPackageUniverse Universe(Cache);
-   return ShowList(out,_("The following held packages will be changed:"), Universe,
-	 [&Cache](pkgCache::PkgIterator const &Pkg)
-	 {
-	    return Pkg->SelectedState == pkgCache::State::Hold &&
-		   Cache[Pkg].InstallVer != (pkgCache::Version *)Pkg.CurrentVer();
-	 },
-	 &PrettyFullName,
-	 CurrentToCandidateVersion(&Cache));
-}
-									/*}}}*/
-// ShowEssential - Show an essential package warning			/*{{{*/
-// ---------------------------------------------------------------------
-/* This prints out a warning message that is not to be ignored. It shows
-   all essential packages and their dependents that are to be removed.
-   It is insanely risky to remove the dependents of an essential package! */
-struct APT_HIDDEN PrettyFullNameWithDue {
-   std::map<unsigned long long, pkgCache::PkgIterator> due;
-   PrettyFullNameWithDue() {}
-   std::string operator() (pkgCache::PkgIterator const &Pkg)
-   {
-      std::string const A = PrettyFullName(Pkg);
-      std::map<unsigned long long, pkgCache::PkgIterator>::const_iterator d = due.find(Pkg->ID);
-      if (d == due.end())
-        return A;
-
-      std::string const B = PrettyFullName(d->second);
-      std::ostringstream outstr;
-      ioprintf(outstr, _("%s (due to %s)"), A.c_str(), B.c_str());
-      return outstr.str();
-   }
-};
-bool ShowEssential(ostream &out,CacheFile &Cache)
-{
-   std::vector<bool> Added(Cache->Head().PackageCount, false);
-   APT::PackageDeque pkglist;
-   PrettyFullNameWithDue withdue;
-
-   SortedPackageUniverse Universe(Cache);
-   for (pkgCache::PkgIterator const &I: Universe)
-   {
-      if ((I->Flags & pkgCache::Flag::Essential) != pkgCache::Flag::Essential &&
-	  (I->Flags & pkgCache::Flag::Important) != pkgCache::Flag::Important)
-	 continue;
-
-      // The essential package is being removed
-      if (Cache[I].Delete() == false)
-	 continue;
-
-      if (Added[I->ID] == false)
-      {
-	 Added[I->ID] = true;
-	 pkglist.insert(I);
-      }
-
-      if (I->CurrentVer == 0)
-	 continue;
-
-      // Print out any essential package depenendents that are to be removed
-      for (pkgCache::DepIterator D = I.CurrentVer().DependsList(); D.end() == false; ++D)
-      {
-	 // Skip everything but depends
-	 if (D->Type != pkgCache::Dep::PreDepends &&
-	     D->Type != pkgCache::Dep::Depends)
-	    continue;
-
-	 pkgCache::PkgIterator P = D.SmartTargetPkg();
-	 if (Cache[P].Delete() == true)
-	 {
-	    if (Added[P->ID] == true)
-	       continue;
-	    Added[P->ID] = true;
-
-	    pkglist.insert(P);
-	    withdue.due[P->ID] = I;
-	 }
-      }
-   }
-   return ShowList(out,_("WARNING: The following essential packages will be removed.\n"
-			 "This should NOT be done unless you know exactly what you are doing!"),
-	 pkglist, &AlwaysTrue, withdue, &EmptyString);
-}
-									/*}}}*/
-// Stats - Show some statistics						/*{{{*/
-// ---------------------------------------------------------------------
-/* */
-void Stats(ostream &out,pkgDepCache &Dep)
-{
-   unsigned long Upgrade = 0;
-   unsigned long Downgrade = 0;
-   unsigned long Install = 0;
-   unsigned long ReInstall = 0;
-   for (pkgCache::PkgIterator I = Dep.PkgBegin(); I.end() == false; ++I)
-   {
-      if (Dep[I].NewInstall() == true)
-	 Install++;
-      else
-      {
-	 if (Dep[I].Upgrade() == true)
-	    Upgrade++;
-	 else
-	    if (Dep[I].Downgrade() == true)
-	       Downgrade++;
-      }
-      
-      if (Dep[I].Delete() == false && (Dep[I].iFlags & pkgDepCache::ReInstall) == pkgDepCache::ReInstall)
-	 ReInstall++;
-   }   
-
-   ioprintf(out,_("%lu upgraded, %lu newly installed, "),
-	    Upgrade,Install);
-   
-   if (ReInstall != 0)
-      ioprintf(out,_("%lu reinstalled, "),ReInstall);
-   if (Downgrade != 0)
-      ioprintf(out,_("%lu downgraded, "),Downgrade);
-
-   ioprintf(out,_("%lu to remove and %lu not upgraded.\n"),
-	    Dep.DelCount(),Dep.KeepCount());
-   
-   if (Dep.BadCount() != 0)
-      ioprintf(out,_("%lu not fully installed or removed.\n"),
-	       Dep.BadCount());
-}
-									/*}}}*/
-// YnPrompt - Yes No Prompt.						/*{{{*/
-// ---------------------------------------------------------------------
-/* Returns true on a Yes.*/
-bool YnPrompt(char const * const Question, bool const Default, bool const ShowGlobalErrors, std::ostream &c1o, std::ostream &c2o)
-{
-   auto const AssumeYes = _config->FindB("APT::Get::Assume-Yes",false);
-   auto const AssumeNo = _config->FindB("APT::Get::Assume-No",false);
-   // if we ask interactively, show warnings/notices before the question
-   if (ShowGlobalErrors == true && AssumeYes == false && AssumeNo == false)
-   {
-      if (_config->FindI("quiet",0) > 0)
-	 _error->DumpErrors(c2o);
-      else
-	 _error->DumpErrors(c2o, GlobalError::DEBUG);
-   }
-
-   c2o << Question << std::flush;
-
-   /* nl_langinfo does not support LANGUAGE setting, so we unset it here
-      to have the help-message (hopefully) match the expected characters */
-   char * language = getenv("LANGUAGE");
-   if (language != NULL)
-      language = strdup(language);
-   if (language != NULL)
-      unsetenv("LANGUAGE");
-
-   if (Default == true)
-      // TRANSLATOR: Yes/No question help-text: defaulting to Y[es]
-      //             e.g. "Do you want to continue? [Y/n] "
-      //             The user has to answer with an input matching the
-      //             YESEXPR/NOEXPR defined in your l10n.
-      c2o << " " << _("[Y/n]") << " " << std::flush;
-   else
-      // TRANSLATOR: Yes/No question help-text: defaulting to N[o]
-      //             e.g. "Should this file be removed? [y/N] "
-      //             The user has to answer with an input matching the
-      //             YESEXPR/NOEXPR defined in your l10n.
-      c2o << " " << _("[y/N]") << " " << std::flush;
-
-   if (language != NULL)
-   {
-      setenv("LANGUAGE", language, 0);
-      free(language);
-   }
-
-   if (AssumeYes)
-   {
-      // TRANSLATOR: "Yes" answer printed for a yes/no question if --assume-yes is set
-      c1o << _("Y") << std::endl;
-      return true;
-   }
-   else if (AssumeNo)
-   {
-      // TRANSLATOR: "No" answer printed for a yes/no question if --assume-no is set
-      c1o << _("N") << std::endl;
-      return false;
-   }
-
-   char response[1024] = "";
-   std::cin.getline(response, sizeof(response));
-
-   if (!std::cin)
-      return false;
-
-   if (strlen(response) == 0)
-      return Default;
-
-   regex_t Pattern;
-   int Res;
-
-   Res = regcomp(&Pattern, nl_langinfo(YESEXPR),
-                 REG_EXTENDED|REG_ICASE|REG_NOSUB);
-
-   if (Res != 0) {
-      char Error[300];
-      regerror(Res,&Pattern,Error,sizeof(Error));
-      return _error->Error(_("Regex compilation error - %s"),Error);
-   }
-
-   Res = regexec(&Pattern, response, 0, NULL, 0);
-   if (Res == 0)
-      return true;
-   return false;
-}
-bool YnPrompt(char const * const Question, bool const Default)
-{
-   return YnPrompt(Question, Default, true, c1out, c2out);
-}
-									/*}}}*/
-// AnalPrompt - Annoying Yes No Prompt.					/*{{{*/
-// ---------------------------------------------------------------------
-/* Returns true on a Yes.*/
-bool AnalPrompt(std::string const &Question, const char *Text)
-{
-   if (_config->FindI("quiet",0) > 0)
-      _error->DumpErrors(c2out);
-   else
-      _error->DumpErrors(c2out, GlobalError::DEBUG);
-   c2out << Question << std::flush;
-
-   char Buf[1024];
-   std::cin.getline(Buf,sizeof(Buf));
-   if (strcmp(Buf,Text) == 0)
-      return true;
-   return false;
-}
-									/*}}}*/
-
-std::string PrettyFullName(pkgCache::PkgIterator const &Pkg)
-{
-   return Pkg.FullName(true);
-}
-std::string CandidateVersion(pkgCacheFile * const Cache, pkgCache::PkgIterator const &Pkg)
-{
-   return (*Cache)[Pkg].CandVersion;
-}
-std::function<std::string(pkgCache::PkgIterator const &)> CandidateVersion(pkgCacheFile * const Cache)
-{
-   return std::bind(static_cast<std::string(*)(pkgCacheFile * const, pkgCache::PkgIterator const&)>(&CandidateVersion), Cache, std::placeholders::_1);
-}
-std::string CurrentToCandidateVersion(pkgCacheFile * const Cache, pkgCache::PkgIterator const &Pkg)
-{
-   return std::string((*Cache)[Pkg].CurVersion) + " => " + (*Cache)[Pkg].CandVersion;
-}
-std::function<std::string(pkgCache::PkgIterator const &)> CurrentToCandidateVersion(pkgCacheFile * const Cache)
-{
-   return std::bind(static_cast<std::string(*)(pkgCacheFile * const, pkgCache::PkgIterator const&)>(&CurrentToCandidateVersion), Cache, std::placeholders::_1);
-}
-bool AlwaysTrue(pkgCache::PkgIterator const &)
-{
-      return true;
-}
-std::string EmptyString(pkgCache::PkgIterator const &)
-{
-   return std::string();
-}
-
diff -urN apt-2.1.5/apt-private/private-output.mm apt/apt-private/private-output.mm
--- apt-2.1.5/apt-private/private-output.mm	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-private/private-output.mm	2020-06-02 23:06:58.414093247 -0400
@@ -0,0 +1,951 @@
+// Include files							/*{{{*/
+#include <config.h>
+
+#include <Foundation/Foundation.h>
+
+#include <apt-pkg/cachefile.h>
+#include <apt-pkg/configuration.h>
+#include <apt-pkg/depcache.h>
+#include <apt-pkg/error.h>
+#include <apt-pkg/pkgcache.h>
+#include <apt-pkg/pkgrecords.h>
+#include <apt-pkg/policy.h>
+#include <apt-pkg/strutl.h>
+
+#include <apt-private/private-cachefile.h>
+#include <apt-private/private-output.h>
+
+#include <iomanip>
+#include <iostream>
+#include <langinfo.h>
+#include <regex.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+#include <sstream>
+
+#include <apti18n.h>
+									/*}}}*/
+
+using namespace std;
+
+std::ostream c0out(0);
+std::ostream c1out(0);
+std::ostream c2out(0);
+std::ofstream devnull("/dev/null");
+
+
+unsigned int ScreenWidth = 80 - 1; /* - 1 for the cursor */
+
+// SigWinch - Window size change signal handler				/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+static void SigWinch(int)
+{
+   // Riped from GNU ls
+#ifdef TIOCGWINSZ
+   struct winsize ws;
+  
+   if (ioctl(1, TIOCGWINSZ, &ws) != -1 && ws.ws_col >= 5)
+      ScreenWidth = ws.ws_col - 1;
+#endif
+}
+									/*}}}*/
+bool InitOutput(std::basic_streambuf<char> * const out)			/*{{{*/
+{
+   if (!isatty(STDOUT_FILENO) && _config->FindI("quiet", -1) == -1)
+      _config->Set("quiet","1");
+
+   c0out.rdbuf(out);
+   c1out.rdbuf(out);
+   c2out.rdbuf(out);
+   if (_config->FindI("quiet",0) > 0)
+      c0out.rdbuf(devnull.rdbuf());
+   if (_config->FindI("quiet",0) > 1)
+      c1out.rdbuf(devnull.rdbuf());
+
+   // deal with window size changes
+   auto cols = getenv("COLUMNS");
+   if (cols != nullptr)
+   {
+      char * colends;
+      auto const sw = strtoul(cols, &colends, 10);
+      if (*colends != '\0' || sw == 0)
+      {
+	 _error->Warning("Environment variable COLUMNS was ignored as it has an invalid value: \"%s\"", cols);
+	 cols = nullptr;
+      }
+      else
+	 ScreenWidth = sw;
+   }
+   if (cols == nullptr)
+   {
+      signal(SIGWINCH,SigWinch);
+      SigWinch(0);
+   }
+
+   if(!isatty(1))
+   {
+      _config->Set("APT::Color", "false");
+      _config->Set("APT::Color::Highlight", "");
+      _config->Set("APT::Color::Neutral", "");
+   } else {
+      // Colors
+      _config->CndSet("APT::Color::Highlight", "\x1B[32m");
+      _config->CndSet("APT::Color::Neutral", "\x1B[0m");
+      
+      _config->CndSet("APT::Color::Red", "\x1B[31m");
+      _config->CndSet("APT::Color::Green", "\x1B[32m");
+      _config->CndSet("APT::Color::Yellow", "\x1B[33m");
+      _config->CndSet("APT::Color::Blue", "\x1B[34m");
+      _config->CndSet("APT::Color::Magenta", "\x1B[35m");
+      _config->CndSet("APT::Color::Cyan", "\x1B[36m");
+      _config->CndSet("APT::Color::White", "\x1B[37m");
+   }
+
+   return true;
+}
+									/*}}}*/
+static std::string GetArchiveSuite(pkgCacheFile &/*CacheFile*/, pkgCache::VerIterator ver) /*{{{*/
+{
+   std::string suite = "";
+   if (ver && ver.FileList())
+   {
+      pkgCache::VerFileIterator VF = ver.FileList();
+      for (; VF.end() == false ; ++VF)
+      {
+         if(VF.File() == NULL || VF.File().Archive() == NULL)
+            suite = suite + "," + _("unknown");
+         else
+            suite = suite + "," + VF.File().Archive();
+         //suite = VF.File().Archive();
+      }
+      suite = suite.erase(0, 1);
+   }
+   return suite;
+}
+									/*}}}*/
+static std::string GetFlagsStr(pkgCacheFile &CacheFile, pkgCache::PkgIterator P)/*{{{*/
+{
+   pkgDepCache *DepCache = CacheFile.GetDepCache();
+   pkgDepCache::StateCache &state = (*DepCache)[P];
+
+   std::string flags_str;
+   if (state.NowBroken())
+      flags_str = "B";
+   if (P.CurrentVer() && state.Upgradable() && state.CandidateVer != NULL)
+      flags_str = "g";
+   else if (P.CurrentVer() != NULL)
+      flags_str = "i";
+   else
+      flags_str = "-";
+   return flags_str;
+}
+									/*}}}*/
+static std::string GetCandidateVersion(pkgCacheFile &CacheFile, pkgCache::PkgIterator P)/*{{{*/
+{
+   pkgPolicy *policy = CacheFile.GetPolicy();
+   pkgCache::VerIterator cand = policy->GetCandidateVer(P);
+
+   return cand ? cand.VerStr() : "(none)";
+}
+									/*}}}*/
+static std::string GetInstalledVersion(pkgCacheFile &/*CacheFile*/, pkgCache::PkgIterator P)/*{{{*/
+{
+   pkgCache::VerIterator inst = P.CurrentVer();
+
+   return inst ? inst.VerStr() : "(none)";
+}
+									/*}}}*/
+static std::string GetVersion(pkgCacheFile &/*CacheFile*/, pkgCache::VerIterator V)/*{{{*/
+{
+   pkgCache::PkgIterator P = V.ParentPkg();
+   if (V == P.CurrentVer())
+   {
+      std::string inst_str = DeNull(V.VerStr());
+#if 0 // FIXME: do we want this or something like this?
+      pkgDepCache *DepCache = CacheFile.GetDepCache();
+      pkgDepCache::StateCache &state = (*DepCache)[P];
+      if (state.Upgradable())
+         return "**"+inst_str;
+#endif
+      return inst_str;
+   }
+
+   if(V)
+      return DeNull(V.VerStr());
+   return "(none)";
+}
+									/*}}}*/
+static std::string GetArchitecture(pkgCacheFile &CacheFile, pkgCache::PkgIterator P)/*{{{*/
+{
+   if (P->CurrentVer == 0)
+   {
+      pkgDepCache * const DepCache = CacheFile.GetDepCache();
+      pkgDepCache::StateCache const &state = (*DepCache)[P];
+      if (state.CandidateVer != NULL)
+      {
+	 pkgCache::VerIterator const CandV(CacheFile, state.CandidateVer);
+	 return CandV.Arch();
+      }
+      else
+      {
+	 pkgCache::VerIterator const V = P.VersionList();
+	 if (V.end() == false)
+	    return V.Arch();
+	 else
+	    return P.Arch();
+      }
+   }
+   else
+      return P.CurrentVer().Arch();
+}
+									/*}}}*/
+static std::string GetShortDescription(pkgCacheFile &CacheFile, pkgRecords &records, pkgCache::PkgIterator P)/*{{{*/
+{
+   pkgPolicy *policy = CacheFile.GetPolicy();
+
+   pkgCache::VerIterator ver;
+   if (P.CurrentVer())
+      ver = P.CurrentVer();
+   else
+      ver = policy->GetCandidateVer(P);
+
+   std::string ShortDescription = "(none)";
+   if(ver)
+   {
+      pkgCache::DescIterator const Desc = ver.TranslatedDescription();
+      if (Desc.end() == false)
+      {
+	 pkgRecords::Parser & parser = records.Lookup(Desc.FileList());
+	 ShortDescription = parser.ShortDesc();
+      }
+   }
+   return ShortDescription;
+}
+									/*}}}*/
+static std::string GetLongDescription(pkgCacheFile &CacheFile, pkgRecords &records, pkgCache::PkgIterator P)/*{{{*/
+{
+   pkgPolicy *policy = CacheFile.GetPolicy();
+
+   pkgCache::VerIterator ver;
+   if (P->CurrentVer != 0)
+      ver = P.CurrentVer();
+   else
+      ver = policy->GetCandidateVer(P);
+
+   std::string const EmptyDescription = "(none)";
+   if(ver.end() == true)
+      return EmptyDescription;
+
+   pkgCache::DescIterator const Desc = ver.TranslatedDescription();
+   if (Desc.end() == false)
+   {
+      pkgRecords::Parser & parser = records.Lookup(Desc.FileList());
+      std::string const longdesc = parser.LongDesc();
+      if (longdesc.empty() == false)
+	 return SubstVar(longdesc, "\n ", "\n  ");
+   }
+   return EmptyDescription;
+}
+									/*}}}*/
+void ListSingleVersion(pkgCacheFile &CacheFile, pkgRecords &records,	/*{{{*/
+                       pkgCache::VerIterator const &V, std::ostream &out,
+                       std::string const &format)
+{
+   pkgCache::PkgIterator const P = V.ParentPkg();
+   pkgDepCache * const DepCache = CacheFile.GetDepCache();
+   pkgDepCache::StateCache const &state = (*DepCache)[P];
+
+   std::string output;
+   if (_config->FindB("APT::Cmd::use-format", false))
+      output = _config->Find("APT::Cmd::format", "${db::Status-Abbrev} ${Package} ${Version} ${Origin} ${Description}");
+   else
+      output = format;
+
+   // FIXME: some of these names are really icky – and all is nowhere documented
+   output = SubstVar(output, "${db::Status-Abbrev}", GetFlagsStr(CacheFile, P));
+   output = SubstVar(output, "${Package}", P.Name());
+   std::string const ArchStr = GetArchitecture(CacheFile, P);
+   output = SubstVar(output, "${Architecture}", ArchStr);
+   std::string const InstalledVerStr = GetInstalledVersion(CacheFile, P);
+   output = SubstVar(output, "${installed:Version}", InstalledVerStr);
+   std::string const CandidateVerStr = GetCandidateVersion(CacheFile, P);
+   output = SubstVar(output, "${candidate:Version}", CandidateVerStr);
+   std::string const VersionStr = GetVersion(CacheFile, V);
+   output = SubstVar(output, "${Version}", VersionStr);
+   output = SubstVar(output, "${Origin}", GetArchiveSuite(CacheFile, V));
+
+   std::string StatusStr = "";
+   if (P->CurrentVer != 0)
+   {
+      if (P.CurrentVer() == V)
+      {
+	 if (state.Upgradable() && state.CandidateVer != NULL)
+	    strprintf(StatusStr, _("[installed,upgradable to: %s]"),
+		  CandidateVerStr.c_str());
+	 else if (V.Downloadable() == false)
+	    StatusStr = _("[installed,local]");
+	 else if(V.Automatic() == true && state.Garbage == true)
+	    StatusStr = _("[installed,auto-removable]");
+	 else if ((state.Flags & pkgCache::Flag::Auto) == pkgCache::Flag::Auto)
+	    StatusStr = _("[installed,automatic]");
+	 else
+	    StatusStr = _("[installed]");
+      }
+      else if (state.CandidateVer == V && state.Upgradable())
+	 strprintf(StatusStr, _("[upgradable from: %s]"),
+	       InstalledVerStr.c_str());
+   }
+   else if (V.ParentPkg()->CurrentState == pkgCache::State::ConfigFiles)
+      StatusStr = _("[residual-config]");
+   output = SubstVar(output, "${apt:Status}", StatusStr);
+   output = SubstVar(output, "${color:highlight}", _config->Find("APT::Color::Highlight", ""));
+   output = SubstVar(output, "${color:neutral}", _config->Find("APT::Color::Neutral", ""));
+   output = SubstVar(output, "${Description}", GetShortDescription(CacheFile, records, P));
+   if (output.find("${LongDescription}") != string::npos)
+      output = SubstVar(output, "${LongDescription}", GetLongDescription(CacheFile, records, P));
+   output = SubstVar(output, "${ }${ }", "${ }");
+   output = SubstVar(output, "${ }\n", "\n");
+   output = SubstVar(output, "${ }", " ");
+   if (APT::String::Endswith(output, " ") == true)
+      output.erase(output.length() - 1);
+
+   out << output;
+}
+									/*}}}*/
+// ShowBroken - Debugging aide						/*{{{*/
+// ---------------------------------------------------------------------
+/* This prints out the names of all the packages that are broken along
+   with the name of each broken dependency and a quite version
+   description.
+
+   The output looks like:
+ The following packages have unmet dependencies:
+     exim: Depends: libc6 (>= 2.1.94) but 2.1.3-10 is to be installed
+           Depends: libldap2 (>= 2.0.2-2) but it is not going to be installed
+           Depends: libsasl7 but it is not going to be installed
+ */
+static void ShowBrokenPackage(ostream &out, pkgCacheFile * const Cache, pkgCache::PkgIterator const &Pkg, bool const Now)
+{
+   if (Now == true)
+   {
+      if ((*Cache)[Pkg].NowBroken() == false)
+	 return;
+   }
+   else
+   {
+      if ((*Cache)[Pkg].InstBroken() == false)
+	 return;
+   }
+
+   // Print out each package and the failed dependencies
+   out << " " << Pkg.FullName(true) << " :";
+   unsigned const Indent = Pkg.FullName(true).size() + 3;
+   bool First = true;
+   pkgCache::VerIterator Ver;
+
+   if (Now == true)
+      Ver = Pkg.CurrentVer();
+   else
+      Ver = (*Cache)[Pkg].InstVerIter(*Cache);
+
+   if (Ver.end() == true)
+   {
+      out << endl;
+      return;
+   }
+
+   for (pkgCache::DepIterator D = Ver.DependsList(); D.end() == false;)
+   {
+      // Compute a single dependency element (glob or)
+      pkgCache::DepIterator Start;
+      pkgCache::DepIterator End;
+      D.GlobOr(Start,End); // advances D
+
+      if ((*Cache)->IsImportantDep(End) == false)
+	 continue;
+
+      if (Now == true)
+      {
+	 if (((*Cache)[End] & pkgDepCache::DepGNow) == pkgDepCache::DepGNow)
+	    continue;
+      }
+      else
+      {
+	 if (((*Cache)[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
+	    continue;
+      }
+
+      bool FirstOr = true;
+      while (1)
+      {
+	 if (First == false)
+	    for (unsigned J = 0; J != Indent; J++)
+	       out << ' ';
+	 First = false;
+
+	 if (FirstOr == false)
+	 {
+	    for (unsigned J = 0; J != strlen(End.DepType()) + 3; J++)
+	       out << ' ';
+	 }
+	 else
+	    out << ' ' << End.DepType() << ": ";
+	 FirstOr = false;
+
+	 out << Start.TargetPkg().FullName(true);
+
+	 // Show a quick summary of the version requirements
+	 if (Start.TargetVer() != 0)
+	    out << " (" << Start.CompType() << " " << Start.TargetVer() << ")";
+
+	 /* Show a summary of the target package if possible. In the case
+	    of virtual packages we show nothing */
+	 pkgCache::PkgIterator Targ = Start.TargetPkg();
+	 if (Targ->ProvidesList == 0)
+	 {
+	    out << ' ';
+	    pkgCache::VerIterator Ver = (*Cache)[Targ].InstVerIter(*Cache);
+	    if (Now == true)
+	       Ver = Targ.CurrentVer();
+
+	    if (Ver.end() == false)
+	    {
+	       if (Now == true)
+		  ioprintf(out,_("but %s is installed"),Ver.VerStr());
+	       else
+		  ioprintf(out,_("but %s is to be installed"),Ver.VerStr());
+	    }
+	    else
+	    {
+	       if ((*Cache)[Targ].CandidateVerIter(*Cache).end() == true)
+	       {
+		  if (Targ->ProvidesList == 0)
+		     out << _("but it is not installable");
+		  else
+		     out << _("but it is a virtual package");
+	       }
+	       else
+		  out << (Now?_("but it is not installed"):_("but it is not going to be installed"));
+	    }
+	 }
+
+	 if (Start != End)
+	    out << _(" or");
+	 out << endl;
+
+	 if (Start == End)
+	    break;
+	 ++Start;
+      }
+   }
+}
+
+static NSMutableDictionary * SileoBrokenPackage(ostream &out, pkgCacheFile * const Cache, pkgCache::PkgIterator const &Pkg, bool const Now)
+{
+   if (Now == true)
+   {
+      if ((*Cache)[Pkg].NowBroken() == false)
+         return nil;
+   }
+   else
+   {
+      if ((*Cache)[Pkg].InstBroken() == false)
+         return nil;
+   }
+
+   NSMutableDictionary *packages = [NSMutableDictionary dictionary];
+
+   NSMutableArray *deps = [NSMutableArray array];
+
+   // Print out each package and the failed dependencies
+   [packages setObject:deps forKey:[NSString stringWithUTF8String:Pkg.FullName(true).c_str()]];
+
+   pkgCache::VerIterator Ver;
+
+   if (Now == true)
+      Ver = Pkg.CurrentVer();
+   else
+      Ver = (*Cache)[Pkg].InstVerIter(*Cache);
+
+   if (Ver.end() == true)
+   {
+      return packages;
+   }
+
+   for (pkgCache::DepIterator D = Ver.DependsList(); D.end() == false;)
+   {
+      // Compute a single dependency element (glob or)
+      pkgCache::DepIterator Start;
+      pkgCache::DepIterator End;
+      D.GlobOr(Start,End); // advances D
+
+      if ((*Cache)->IsImportantDep(End) == false)
+         continue;
+
+      if (Now == true)
+      {
+         if (((*Cache)[End] & pkgDepCache::DepGNow) == pkgDepCache::DepGNow)
+            continue;
+      }
+      else
+      {
+         if (((*Cache)[End] & pkgDepCache::DepGInstall) == pkgDepCache::DepGInstall)
+            continue;
+      }
+
+      NSMutableArray *orDependencies = [NSMutableArray array];
+      [deps addObject:orDependencies];
+
+      while (1)
+      {
+
+         NSMutableDictionary *dependency = [NSMutableDictionary dictionary];
+         [orDependencies addObject:dependency];
+         [dependency setObject:[NSString stringWithUTF8String:End.DepType()] forKey:@"Type"];
+
+         [dependency setObject:[NSString stringWithUTF8String:Start.TargetPkg().FullName(true).c_str()] forKey:@"Package"];
+
+         // Show a quick summary of the version requirements
+         if (Start.TargetVer() != 0)
+            [dependency setObject:[NSString stringWithFormat:@"%s %s", Start.CompType(), Start.TargetVer()] forKey:@"VersionSummary"];
+
+         /* Show a summary of the target package if possible. In the case
+         of virtual packages we show nothing */
+         pkgCache::PkgIterator Targ = Start.TargetPkg();
+         if (Targ->ProvidesList == 0)
+         {
+            pkgCache::VerIterator Ver = (*Cache)[Targ].InstVerIter(*Cache);
+            if (Now == true)
+               Ver = Targ.CurrentVer();
+
+            if (Ver.end() == false)
+            {
+               if (Now == true)
+                  [dependency setObject:[NSString stringWithFormat:@"%s is installed",Ver.VerStr()] forKey:@"Reason"];
+               else
+                  [dependency setObject:[NSString stringWithFormat:@"%s is to be installed",Ver.VerStr()] forKey:@"Reason"];
+            }
+            else
+            {
+               if ((*Cache)[Targ].CandidateVerIter(*Cache).end() == true)
+               {
+                  if (Targ->ProvidesList == 0)
+                     [dependency setObject:@"it is not installable" forKey:@"Reason"];
+                  else
+                     [dependency setObject:@"it is a virtual package" forKey:@"Reason"];
+               }
+               else {
+                  if (Now)
+                     [dependency setObject:@"it is not installed" forKey:@"Reason"];
+                  else
+                     [dependency setObject:@"it is not going to be installed" forKey:@"Reason"];
+               }
+            }
+         }
+
+         if (Start == End)
+            break;
+         ++Start;
+      }
+   }
+   return packages;
+}
+
+void ShowBroken(ostream &out, CacheFile &Cache, bool const Now)
+{
+   if (Cache->BrokenCount() == 0)
+      return;
+
+   out << _("The following packages have unmet dependencies:") << endl;
+
+   bool useJSON = _config->FindB("APT::Format::for-sileo", false);
+
+   SortedPackageUniverse Universe(Cache);
+
+   if (useJSON){
+      NSMutableDictionary *packages = [NSMutableDictionary dictionary];
+      for (auto const &Pkg: Universe){
+         NSMutableDictionary *package = SileoBrokenPackage(out, &Cache, Pkg, Now);
+         [packages addEntriesFromDictionary:package];
+      }
+
+      cout << flush;
+
+      NSData *data = [NSJSONSerialization dataWithJSONObject:packages options:0 error:nil];
+      NSFileHandle *stdout = [NSFileHandle fileHandleWithStandardOutput];
+      [stdout writeData:data];
+   } else {
+      for (auto const &Pkg: Universe)
+         ShowBrokenPackage(out, &Cache, Pkg, Now);
+   }
+}
+void ShowBroken(ostream &out, pkgCacheFile &Cache, bool const Now)
+{
+   if (Cache->BrokenCount() == 0)
+      return;
+
+   out << _("The following packages have unmet dependencies:") << endl;
+
+   bool useJSON = _config->FindB("APT::Format::for-sileo", false);
+
+   APT::PackageUniverse Universe(Cache);
+
+   if (useJSON){
+      NSMutableDictionary *packages = [NSMutableDictionary dictionary];
+      for (auto const &Pkg: Universe){
+         NSMutableDictionary *package = SileoBrokenPackage(out, &Cache, Pkg, Now);
+         [packages addEntriesFromDictionary:package];
+      }
+
+      cout << flush;
+
+      NSData *data = [NSJSONSerialization dataWithJSONObject:packages options:0 error:nil];
+      NSFileHandle *stdout = [NSFileHandle fileHandleWithStandardOutput];
+      [stdout writeData:data];
+   } else {
+      for (auto const &Pkg: Universe)
+         ShowBrokenPackage(out, &Cache, Pkg, Now);
+   }
+}
+									/*}}}*/
+// ShowNew - Show packages to newly install				/*{{{*/
+void ShowNew(ostream &out,CacheFile &Cache)
+{
+   SortedPackageUniverse Universe(Cache);
+   ShowList(out,_("The following NEW packages will be installed:"), Universe,
+	 [&Cache](pkgCache::PkgIterator const &Pkg) { return Cache[Pkg].NewInstall(); },
+	 &PrettyFullName,
+	 CandidateVersion(&Cache));
+}
+									/*}}}*/
+// ShowDel - Show packages to delete					/*{{{*/
+void ShowDel(ostream &out,CacheFile &Cache)
+{
+   SortedPackageUniverse Universe(Cache);
+   ShowList(out,_("The following packages will be REMOVED:"), Universe,
+	 [&Cache](pkgCache::PkgIterator const &Pkg) { return Cache[Pkg].Delete(); },
+	 [&Cache](pkgCache::PkgIterator const &Pkg)
+	 {
+	    std::string str = PrettyFullName(Pkg);
+	    if (((*Cache)[Pkg].iFlags & pkgDepCache::Purge) == pkgDepCache::Purge)
+	       str.append("*");
+	    return str;
+	 },
+	 CandidateVersion(&Cache));
+}
+									/*}}}*/
+// ShowKept - Show kept packages					/*{{{*/
+void ShowKept(ostream &out,CacheFile &Cache)
+{
+   SortedPackageUniverse Universe(Cache);
+   ShowList(out,_("The following packages have been kept back:"), Universe,
+	 [&Cache](pkgCache::PkgIterator const &Pkg)
+	 {
+	    return Cache[Pkg].Upgrade() == false &&
+		   Cache[Pkg].Upgradable() == true &&
+		   Pkg->CurrentVer != 0 &&
+		   Cache[Pkg].Delete() == false;
+	 },
+	 &PrettyFullName,
+	 CurrentToCandidateVersion(&Cache));
+}
+									/*}}}*/
+// ShowUpgraded - Show upgraded packages				/*{{{*/
+void ShowUpgraded(ostream &out,CacheFile &Cache)
+{
+   SortedPackageUniverse Universe(Cache);
+   ShowList(out,_("The following packages will be upgraded:"), Universe,
+	 [&Cache](pkgCache::PkgIterator const &Pkg)
+	 {
+	    return Cache[Pkg].Upgrade() == true && Cache[Pkg].NewInstall() == false;
+	 },
+	 &PrettyFullName,
+	 CurrentToCandidateVersion(&Cache));
+}
+									/*}}}*/
+// ShowDowngraded - Show downgraded packages				/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool ShowDowngraded(ostream &out,CacheFile &Cache)
+{
+   SortedPackageUniverse Universe(Cache);
+   return ShowList(out,_("The following packages will be DOWNGRADED:"), Universe,
+	 [&Cache](pkgCache::PkgIterator const &Pkg)
+	 {
+	    return Cache[Pkg].Downgrade() == true && Cache[Pkg].NewInstall() == false;
+	 },
+	 &PrettyFullName,
+	 CurrentToCandidateVersion(&Cache));
+}
+									/*}}}*/
+// ShowHold - Show held but changed packages				/*{{{*/
+bool ShowHold(ostream &out,CacheFile &Cache)
+{
+   SortedPackageUniverse Universe(Cache);
+   return ShowList(out,_("The following held packages will be changed:"), Universe,
+	 [&Cache](pkgCache::PkgIterator const &Pkg)
+	 {
+	    return Pkg->SelectedState == pkgCache::State::Hold &&
+		   Cache[Pkg].InstallVer != (pkgCache::Version *)Pkg.CurrentVer();
+	 },
+	 &PrettyFullName,
+	 CurrentToCandidateVersion(&Cache));
+}
+									/*}}}*/
+// ShowEssential - Show an essential package warning			/*{{{*/
+// ---------------------------------------------------------------------
+/* This prints out a warning message that is not to be ignored. It shows
+   all essential packages and their dependents that are to be removed.
+   It is insanely risky to remove the dependents of an essential package! */
+struct APT_HIDDEN PrettyFullNameWithDue {
+   std::map<unsigned long long, pkgCache::PkgIterator> due;
+   PrettyFullNameWithDue() {}
+   std::string operator() (pkgCache::PkgIterator const &Pkg)
+   {
+      std::string const A = PrettyFullName(Pkg);
+      std::map<unsigned long long, pkgCache::PkgIterator>::const_iterator d = due.find(Pkg->ID);
+      if (d == due.end())
+        return A;
+
+      std::string const B = PrettyFullName(d->second);
+      std::ostringstream outstr;
+      ioprintf(outstr, _("%s (due to %s)"), A.c_str(), B.c_str());
+      return outstr.str();
+   }
+};
+bool ShowEssential(ostream &out,CacheFile &Cache)
+{
+   std::vector<bool> Added(Cache->Head().PackageCount, false);
+   APT::PackageDeque pkglist;
+   PrettyFullNameWithDue withdue;
+
+   SortedPackageUniverse Universe(Cache);
+   for (pkgCache::PkgIterator const &I: Universe)
+   {
+      if ((I->Flags & pkgCache::Flag::Essential) != pkgCache::Flag::Essential &&
+	  (I->Flags & pkgCache::Flag::Important) != pkgCache::Flag::Important)
+	 continue;
+
+      // The essential package is being removed
+      if (Cache[I].Delete() == false)
+	 continue;
+
+      if (Added[I->ID] == false)
+      {
+	 Added[I->ID] = true;
+	 pkglist.insert(I);
+      }
+
+      if (I->CurrentVer == 0)
+	 continue;
+
+      // Print out any essential package depenendents that are to be removed
+      for (pkgCache::DepIterator D = I.CurrentVer().DependsList(); D.end() == false; ++D)
+      {
+	 // Skip everything but depends
+	 if (D->Type != pkgCache::Dep::PreDepends &&
+	     D->Type != pkgCache::Dep::Depends)
+	    continue;
+
+	 pkgCache::PkgIterator P = D.SmartTargetPkg();
+	 if (Cache[P].Delete() == true)
+	 {
+	    if (Added[P->ID] == true)
+	       continue;
+	    Added[P->ID] = true;
+
+	    pkglist.insert(P);
+	    withdue.due[P->ID] = I;
+	 }
+      }
+   }
+   return ShowList(out,_("WARNING: The following essential packages will be removed.\n"
+			 "This should NOT be done unless you know exactly what you are doing!"),
+	 pkglist, &AlwaysTrue, withdue, &EmptyString);
+}
+									/*}}}*/
+// Stats - Show some statistics						/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void Stats(ostream &out,pkgDepCache &Dep)
+{
+   unsigned long Upgrade = 0;
+   unsigned long Downgrade = 0;
+   unsigned long Install = 0;
+   unsigned long ReInstall = 0;
+   for (pkgCache::PkgIterator I = Dep.PkgBegin(); I.end() == false; ++I)
+   {
+      if (Dep[I].NewInstall() == true)
+	 Install++;
+      else
+      {
+	 if (Dep[I].Upgrade() == true)
+	    Upgrade++;
+	 else
+	    if (Dep[I].Downgrade() == true)
+	       Downgrade++;
+      }
+      
+      if (Dep[I].Delete() == false && (Dep[I].iFlags & pkgDepCache::ReInstall) == pkgDepCache::ReInstall)
+	 ReInstall++;
+   }   
+
+   ioprintf(out,_("%lu upgraded, %lu newly installed, "),
+	    Upgrade,Install);
+   
+   if (ReInstall != 0)
+      ioprintf(out,_("%lu reinstalled, "),ReInstall);
+   if (Downgrade != 0)
+      ioprintf(out,_("%lu downgraded, "),Downgrade);
+
+   ioprintf(out,_("%lu to remove and %lu not upgraded.\n"),
+	    Dep.DelCount(),Dep.KeepCount());
+   
+   if (Dep.BadCount() != 0)
+      ioprintf(out,_("%lu not fully installed or removed.\n"),
+	       Dep.BadCount());
+}
+									/*}}}*/
+// YnPrompt - Yes No Prompt.						/*{{{*/
+// ---------------------------------------------------------------------
+/* Returns true on a Yes.*/
+bool YnPrompt(char const * const Question, bool const Default, bool const ShowGlobalErrors, std::ostream &c1o, std::ostream &c2o)
+{
+   auto const AssumeYes = _config->FindB("APT::Get::Assume-Yes",false);
+   auto const AssumeNo = _config->FindB("APT::Get::Assume-No",false);
+   // if we ask interactively, show warnings/notices before the question
+   if (ShowGlobalErrors == true && AssumeYes == false && AssumeNo == false)
+   {
+      if (_config->FindI("quiet",0) > 0)
+	 _error->DumpErrors(c2o);
+      else
+	 _error->DumpErrors(c2o, GlobalError::DEBUG);
+   }
+
+   c2o << Question << std::flush;
+
+   /* nl_langinfo does not support LANGUAGE setting, so we unset it here
+      to have the help-message (hopefully) match the expected characters */
+   char * language = getenv("LANGUAGE");
+   if (language != NULL)
+      language = strdup(language);
+   if (language != NULL)
+      unsetenv("LANGUAGE");
+
+   if (Default == true)
+      // TRANSLATOR: Yes/No question help-text: defaulting to Y[es]
+      //             e.g. "Do you want to continue? [Y/n] "
+      //             The user has to answer with an input matching the
+      //             YESEXPR/NOEXPR defined in your l10n.
+      c2o << " " << _("[Y/n]") << " " << std::flush;
+   else
+      // TRANSLATOR: Yes/No question help-text: defaulting to N[o]
+      //             e.g. "Should this file be removed? [y/N] "
+      //             The user has to answer with an input matching the
+      //             YESEXPR/NOEXPR defined in your l10n.
+      c2o << " " << _("[y/N]") << " " << std::flush;
+
+   if (language != NULL)
+   {
+      setenv("LANGUAGE", language, 0);
+      free(language);
+   }
+
+   if (AssumeYes)
+   {
+      // TRANSLATOR: "Yes" answer printed for a yes/no question if --assume-yes is set
+      c1o << _("Y") << std::endl;
+      return true;
+   }
+   else if (AssumeNo)
+   {
+      // TRANSLATOR: "No" answer printed for a yes/no question if --assume-no is set
+      c1o << _("N") << std::endl;
+      return false;
+   }
+
+   char response[1024] = "";
+   std::cin.getline(response, sizeof(response));
+
+   if (!std::cin)
+      return false;
+
+   if (strlen(response) == 0)
+      return Default;
+
+   regex_t Pattern;
+   int Res;
+
+   Res = regcomp(&Pattern, nl_langinfo(YESEXPR),
+                 REG_EXTENDED|REG_ICASE|REG_NOSUB);
+
+   if (Res != 0) {
+      char Error[300];
+      regerror(Res,&Pattern,Error,sizeof(Error));
+      return _error->Error(_("Regex compilation error - %s"),Error);
+   }
+
+   Res = regexec(&Pattern, response, 0, NULL, 0);
+   if (Res == 0)
+      return true;
+   return false;
+}
+bool YnPrompt(char const * const Question, bool const Default)
+{
+   return YnPrompt(Question, Default, true, c1out, c2out);
+}
+									/*}}}*/
+// AnalPrompt - Annoying Yes No Prompt.					/*{{{*/
+// ---------------------------------------------------------------------
+/* Returns true on a Yes.*/
+bool AnalPrompt(std::string const &Question, const char *Text)
+{
+   if (_config->FindI("quiet",0) > 0)
+      _error->DumpErrors(c2out);
+   else
+      _error->DumpErrors(c2out, GlobalError::DEBUG);
+   c2out << Question << std::flush;
+
+   char Buf[1024];
+   std::cin.getline(Buf,sizeof(Buf));
+   if (strcmp(Buf,Text) == 0)
+      return true;
+   return false;
+}
+									/*}}}*/
+
+std::string PrettyFullName(pkgCache::PkgIterator const &Pkg)
+{
+   return Pkg.FullName(true);
+}
+std::string CandidateVersion(pkgCacheFile * const Cache, pkgCache::PkgIterator const &Pkg)
+{
+   return (*Cache)[Pkg].CandVersion;
+}
+std::function<std::string(pkgCache::PkgIterator const &)> CandidateVersion(pkgCacheFile * const Cache)
+{
+   return std::bind(static_cast<std::string(*)(pkgCacheFile * const, pkgCache::PkgIterator const&)>(&CandidateVersion), Cache, std::placeholders::_1);
+}
+std::string CurrentToCandidateVersion(pkgCacheFile * const Cache, pkgCache::PkgIterator const &Pkg)
+{
+   return std::string((*Cache)[Pkg].CurVersion) + " => " + (*Cache)[Pkg].CandVersion;
+}
+std::function<std::string(pkgCache::PkgIterator const &)> CurrentToCandidateVersion(pkgCacheFile * const Cache)
+{
+   return std::bind(static_cast<std::string(*)(pkgCacheFile * const, pkgCache::PkgIterator const&)>(&CurrentToCandidateVersion), Cache, std::placeholders::_1);
+}
+bool AlwaysTrue(pkgCache::PkgIterator const &)
+{
+      return true;
+}
+std::string EmptyString(pkgCache::PkgIterator const &)
+{
+   return std::string();
+}
+
diff -urN apt-2.1.5/apt-private/private-source.cc apt/apt-private/private-source.cc
--- apt-2.1.5/apt-private/private-source.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/apt-private/private-source.cc	2020-06-02 23:06:58.414093247 -0400
@@ -520,7 +520,7 @@
 	 strprintf(S, "%s %s %s",
 	       _config->Find("Dir::Bin::dpkg-source","dpkg-source").c_str(),
 	       sourceopts.c_str(), D.Dsc.c_str());
-	 if (system(S.c_str()) != 0)
+	 if (RunCmd(S.c_str()) != 0)
 	 {
 	    _error->Error(_("Unpack command '%s' failed.\n"), S.c_str());
 	    if (SaidCheckIfDpkgDev == false)
@@ -553,7 +553,7 @@
 	       _config->Find("Dir::Bin::dpkg-buildpackage","dpkg-buildpackage").c_str(),
 	       buildopts.c_str());
 
-	 if (system(S.c_str()) != 0)
+	 if (RunCmd(S.c_str()) != 0)
 	 {
 	    _error->Error(_("Build command '%s' failed.\n"), S.c_str());
 	    continue;
diff -urN apt-2.1.5/CMake/apti18n.h.in apt/CMake/apti18n.h.in
--- apt-2.1.5/CMake/apti18n.h.in	2020-06-09 01:58:35.551534570 -0400
+++ apt/CMake/apti18n.h.in	2020-06-02 23:06:58.398093103 -0400
@@ -22,7 +22,7 @@
 # define N_(x) x
 #else
 // apt will not use any gettext
-extern "C" inline char* setlocale(int, const char*) throw() { return nullptr; }
+// extern "C" inline char* setlocale(int, const char*) throw() { return nullptr; }
 extern "C" inline char* textdomain(const char*) throw() { return nullptr; }
 extern "C" inline char* bindtextdomain(const char*, const char*) throw() { return nullptr; }
 extern "C" inline char* dgettext(const char*, const char* msg) throw() { return const_cast<char*>(msg); }
diff -urN apt-2.1.5/CMake/Misc.cmake apt/CMake/Misc.cmake
--- apt-2.1.5/CMake/Misc.cmake	2020-05-26 06:20:42.000000000 -0400
+++ apt/CMake/Misc.cmake	2020-06-02 23:06:58.394093067 -0400
@@ -74,7 +74,7 @@
                        COMMAND echo "${name} {global: *; };" > "${script}"
                        VERBATIM )
     add_custom_target(${target}-versionscript DEPENDS "${script}")
-    target_link_libraries(${target} PRIVATE -Wl,-version-script="${script}")
+    #target_link_libraries(${target} PRIVATE -Wl,-version-script="${script}")
     add_dependencies(${target} ${target}-versionscript)
 endfunction()
 
diff -urN apt-2.1.5/CMakeLists.txt apt/CMakeLists.txt
--- apt-2.1.5/CMakeLists.txt	2020-05-26 06:20:42.000000000 -0400
+++ apt/CMakeLists.txt	2020-06-02 23:06:58.398093103 -0400
@@ -22,9 +22,9 @@
 set(CMAKE_SHARED_LINKER_FLAGS_COVERAGE "-lgcov")
 
 # Work around bug in GNUInstallDirs
-if (EXISTS "/etc/debian_version")
-  set(CMAKE_INSTALL_LIBEXECDIR "lib")
-endif()
+#if (EXISTS "/etc/debian_version")
+#  set(CMAKE_INSTALL_LIBEXECDIR "lib")
+#endif()
 
 # Include stuff
 include(Misc)
@@ -85,10 +85,10 @@
   set(HAVE_BDB 1)
 endif()
 
-find_package(GnuTLS REQUIRED)
-if (GNUTLS_FOUND)
-  set(HAVE_GNUTLS 1)
-endif()
+#find_package(GnuTLS REQUIRED)
+#if (GNUTLS_FOUND)
+#  set(HAVE_GNUTLS 1)
+#endif()
 
 # (De)Compressor libraries
 find_package(ZLIB REQUIRED)
@@ -243,11 +243,11 @@
 add_subdirectory(apt-private)
 add_subdirectory(cmdline)
 add_subdirectory(completions)
-add_subdirectory(doc)
+#add_subdirectory(doc)
 add_subdirectory(dselect)
 add_subdirectory(ftparchive)
 add_subdirectory(methods)
-add_subdirectory(test)
+#add_subdirectory(test)
 
 if (USE_NLS)
 add_subdirectory(po)
diff -urN apt-2.1.5/ftparchive/apt-ftparchive.cc apt/ftparchive/apt-ftparchive.cc
--- apt-2.1.5/ftparchive/apt-ftparchive.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/ftparchive/apt-ftparchive.cc	2020-06-02 23:06:58.442093498 -0400
@@ -53,7 +53,7 @@
    auto const Time = std::chrono::steady_clock::now().time_since_epoch();
    auto const Time_sec = std::chrono::duration_cast<std::chrono::seconds>(Time);
    auto const Time_usec = std::chrono::duration_cast<std::chrono::microseconds>(Time - Time_sec);
-   return { Time_sec.count(), Time_usec.count() };
+   return { static_cast<__darwin_time_t>(Time_sec.count()), static_cast<__darwin_suseconds_t>(Time_usec.count()) };
 }
 									/*}}}*/
 static auto GetTimeDeltaSince(struct timeval StartTime)			/*{{{*/
diff -urN apt-2.1.5/ftparchive/byhash.cc apt/ftparchive/byhash.cc
--- apt-2.1.5/ftparchive/byhash.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/ftparchive/byhash.cc	2020-06-02 23:06:58.442093498 -0400
@@ -17,6 +17,8 @@
 #include <sys/stat.h>
 #include <unistd.h>
 
+#define st_mtim st_mtimespec
+
 #include "byhash.h"
 #include <apt-pkg/fileutl.h>
 #include <apt-pkg/hashes.h>
diff -urN apt-2.1.5/ftparchive/cachedb.cc apt/ftparchive/cachedb.cc
--- apt-2.1.5/ftparchive/cachedb.cc	2020-05-26 06:20:42.000000000 -0400
+++ apt/ftparchive/cachedb.cc	2020-06-02 23:06:58.442093498 -0400
@@ -18,6 +18,7 @@
 #include <apt-pkg/gpgv.h>
 #include <apt-pkg/hashes.h>
 #include <apt-pkg/strutl.h>
+#include <apt-pkg/missing.h>
 
 #include <ctype.h>
 #include <netinet/in.h> // htonl, etc
diff -urN apt-2.1.5/.git apt/.git
--- apt-2.1.5/.git	1969-12-31 19:00:00.000000000 -0500
+++ apt/.git	2020-06-02 23:06:19.453898695 -0400
@@ -0,0 +1 @@
+gitdir: ../.git/modules/apt
diff -urN apt-2.1.5/methods/CMakeLists.txt apt/methods/CMakeLists.txt
--- apt-2.1.5/methods/CMakeLists.txt	2020-05-26 06:20:42.000000000 -0400
+++ apt/methods/CMakeLists.txt	2020-06-02 23:06:58.442093498 -0400
@@ -2,33 +2,35 @@
 include_directories($<$<BOOL:${SECCOMP_FOUND}>:${SECCOMP_INCLUDE_DIR}>)
 link_libraries(apt-pkg $<$<BOOL:${SECCOMP_FOUND}>:${SECCOMP_LIBRARIES}>)
 
-add_library(connectlib OBJECT connect.cc rfc2553emu.cc)
+#add_library(connectlib OBJECT connect.cc rfc2553emu.cc)
 
 add_executable(file file.cc)
 add_executable(copy copy.cc)
 add_executable(store store.cc)
 add_executable(gpgv gpgv.cc)
 add_executable(cdrom cdrom.cc)
-add_executable(http http.cc basehttp.cc $<TARGET_OBJECTS:connectlib>)
+#add_executable(http http.cc basehttp.cc $<TARGET_OBJECTS:connectlib>)
+add_executable(https nshttp.mm)
 add_executable(mirror mirror.cc)
-add_executable(ftp ftp.cc $<TARGET_OBJECTS:connectlib>)
+#add_executable(ftp ftp.cc $<TARGET_OBJECTS:connectlib>)
 add_executable(rred rred.cc)
 add_executable(rsh rsh.cc)
 
-target_compile_definitions(connectlib PRIVATE ${GNUTLS_DEFINITIONS})
-target_include_directories(connectlib PRIVATE ${GNUTLS_INCLUDE_DIR})
-target_include_directories(http PRIVATE $<$<BOOL:${SYSTEMD_FOUND}>:${SYSTEMD_INCLUDE_DIRS}>)
+#target_compile_definitions(connectlib PRIVATE ${GNUTLS_DEFINITIONS})
+#target_include_directories(connectlib PRIVATE ${GNUTLS_INCLUDE_DIR})
+#target_include_directories(http PRIVATE $<$<BOOL:${SYSTEMD_FOUND}>:${SYSTEMD_INCLUDE_DIRS}>)
 
 # Additional libraries to link against for networked stuff
-target_link_libraries(http ${GNUTLS_LIBRARIES} $<$<BOOL:${SYSTEMD_FOUND}>:${SYSTEMD_LIBRARIES}>)
-target_link_libraries(ftp ${GNUTLS_LIBRARIES})
+#target_link_libraries(http ${GNUTLS_LIBRARIES} $<$<BOOL:${SYSTEMD_FOUND}>:${SYSTEMD_LIBRARIES}>)
+target_link_libraries(https "-framework Foundation")
+#target_link_libraries(ftp ${GNUTLS_LIBRARIES})
 
 # Install the library
-install(TARGETS file copy store gpgv cdrom http ftp rred rsh mirror
+install(TARGETS file copy store https gpgv cdrom rred rsh mirror
         RUNTIME DESTINATION ${CMAKE_INSTALL_LIBEXECDIR}/apt/methods)
 
 add_slaves(${CMAKE_INSTALL_LIBEXECDIR}/apt/methods mirror mirror+ftp mirror+http mirror+https mirror+file mirror+copy)
 add_slaves(${CMAKE_INSTALL_LIBEXECDIR}/apt/methods rsh ssh)
 
 
-add_slaves(${CMAKE_INSTALL_LIBEXECDIR}/apt/methods http https)
+add_slaves(${CMAKE_INSTALL_LIBEXECDIR}/apt/methods https http)
diff -urN apt-2.1.5/methods/nshttp.h apt/methods/nshttp.h
--- apt-2.1.5/methods/nshttp.h	1969-12-31 19:00:00.000000000 -0500
+++ apt/methods/nshttp.h	2020-06-02 23:06:58.446093534 -0400
@@ -0,0 +1,40 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+/* ######################################################################
+
+   HTTP method - Transfer files via rsh compatible program
+
+   ##################################################################### */
+									/*}}}*/
+#ifndef APT_NSHTTP_H
+#define APT_NSHTTP_H
+
+#include <string>
+#include <time.h>
+
+#include <apt-pkg/strutl.h>
+#include <Foundation/Foundation.h>
+
+class Hashes;
+class FileFd;
+
+#include "aptmethod.h"
+
+class HttpMethod : public aptMethod
+{
+   virtual bool Fetch(FetchItem *Itm) APT_OVERRIDE;
+   virtual bool Configuration(std::string Message) APT_OVERRIDE;
+
+   NSURLSession *session;
+
+   static std::string FailFile;
+   static int FailFd;
+   static time_t FailTime;
+   static APT_NORETURN void SigTerm(int);
+
+   public:
+
+   explicit HttpMethod(std::string &&Prog);
+};
+
+#endif
diff -urN apt-2.1.5/methods/nshttp.mm apt/methods/nshttp.mm
--- apt-2.1.5/methods/nshttp.mm	1969-12-31 19:00:00.000000000 -0500
+++ apt/methods/nshttp.mm	2020-06-02 23:06:58.446093534 -0400
@@ -0,0 +1,260 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+/* ######################################################################
+
+   RSH method - Transfer files via rsh compatible program
+
+   Written by Ben Collins <bcollins@debian.org>, Copyright (c) 2000
+   Licensed under the GNU General Public License v2 [no exception clauses]
+
+   ##################################################################### */
+									/*}}}*/
+// Include Files							/*{{{*/
+#include <config.h>
+
+#include <apt-pkg/configuration.h>
+#include <apt-pkg/error.h>
+#include <apt-pkg/fileutl.h>
+#include <apt-pkg/hashes.h>
+#include <apt-pkg/strutl.h>
+
+#include "nshttp.h"
+#include <errno.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <dlfcn.h>
+#include <Foundation/Foundation.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+
+#include <apti18n.h>
+
+extern "C" NSDictionary *_CFCopyServerVersionDictionary();
+
+@interface NSDevice : NSObject
++ (NSString *)_uniqueIdentifier;
++ (NSString *)_platform;
++ (NSUUID *)_uniqueIdentifierUUID;
+@end
+
+@implementation NSDevice
+
++ (NSString *)_uniqueIdentifier {
+    void *gestalt = dlopen("/usr/lib/libMobileGestalt.dylib", RTLD_GLOBAL | RTLD_LAZY);
+    CFStringRef (*MGCopyAnswer)(CFStringRef) = (CFStringRef (*)(CFStringRef))(dlsym(gestalt, "MGCopyAnswer"));
+    return CFBridgingRelease(MGCopyAnswer(CFSTR("UniqueDeviceID")));
+}
+
++ (NSString *)_platform {
+    size_t size;
+    sysctlbyname("hw.machine", NULL, &size, NULL, 0);
+    char *machine = (char *)malloc(size);
+    sysctlbyname("hw.machine", machine, &size, NULL, 0);
+    return [NSString stringWithCString:machine encoding:NSUTF8StringEncoding];
+}
+
++ (NSString *)systemVersion {
+   NSDictionary *dict = _CFCopyServerVersionDictionary();
+   return [dict objectForKey:@"ProductVersion"];
+}
+
+@end
+
+unsigned long TimeOut = 30;
+Configuration::Item const *HttpOptions = 0;
+time_t HttpMethod::FailTime = 0;
+
+// HttpMethod::HttpMethod - Constructor					/*{{{*/
+HttpMethod::HttpMethod(std::string &&pProg) : aptMethod(std::move(pProg),"1.0",SendConfig)
+{
+   signal(SIGTERM,SigTerm);
+   signal(SIGINT,SigTerm);
+}
+									/*}}}*/
+// HttpMethod::Configuration - Handle a configuration message		/*{{{*/
+// ---------------------------------------------------------------------
+bool HttpMethod::Configuration(std::string Message)
+{
+   // enabling privilege dropping for this method requires configuration…
+   // … which is otherwise lifted straight from root, so use it by default.
+   _config->Set(std::string("Binary::") + Binary + "::APT::Sandbox::User", "");
+
+   if (aptMethod::Configuration(Message) == false)
+      return false;
+
+   std::string const timeconf = std::string("Acquire::") + Binary + "::Timeout";
+   TimeOut = _config->FindI(timeconf, TimeOut);
+   std::string const optsconf = std::string("Acquire::") + Binary + "::Options";
+   HttpOptions = _config->Tree(optsconf.c_str());
+
+   return true;
+}
+									/*}}}*/
+// HttpMethod::SigTerm - Clean up and timestamp the files on exit	/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void HttpMethod::SigTerm(int)
+{
+   _exit(100);
+}
+									/*}}}*/
+// HttpMethod::Fetch - Fetch a URI					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool HttpMethod::Fetch(FetchItem *Itm)
+{
+   URI Get(Itm->Uri);
+   std::string cppGet = Get;
+   NSURL *URL = [NSURL URLWithString:[NSString stringWithUTF8String:cppGet.c_str()]];
+   __block FetchResult Res;
+   Res.Filename = Itm->DestFile;
+   Res.IMSHit = false;
+
+   __block BOOL success = NO;
+   __block BOOL proceed = NO;
+
+   dispatch_semaphore_t sem = dispatch_semaphore_create(0);
+
+   NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData timeoutInterval:TimeOut];
+   [request setHTTPMethod:@"HEAD"];
+
+   NSOperatingSystemVersion firmwareVersion = [[NSProcessInfo processInfo] operatingSystemVersion];
+   NSString *coreFoundationVersion = [NSString stringWithFormat:@"%.3f", kCFCoreFoundationVersionNumber];
+   [request setValue:[NSString stringWithFormat:@"Procursus APT-HTTP/1.3 (%@) %@/%@", @PACKAGE_VERSION, @"CoreFoundation", coreFoundationVersion] forHTTPHeaderField:@"User-Agent"];
+
+   [request setValue:[NSDevice _platform] forHTTPHeaderField:@"X-Machine"];
+   [request setValue:[NSDevice _uniqueIdentifier] forHTTPHeaderField:@"X-Unique-ID"];
+   if (firmwareVersion.patchVersion != 0) {
+       [request setValue:[NSString stringWithFormat:@"%d.%d.%d", firmwareVersion.majorVersion, firmwareVersion.minorVersion, firmwareVersion.patchVersion] forHTTPHeaderField:@"X-Firmware"];
+   } else {
+       [request setValue:[NSString stringWithFormat:@"%d.%d", firmwareVersion.majorVersion, firmwareVersion.minorVersion] forHTTPHeaderField:@"X-Firmware"];
+   }
+   if (DebugEnabled() == true)
+      NSLog(@"\n%@", [request allHTTPHeaderFields]);
+
+   [[[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData *, NSURLResponse *response, NSError *error){
+      NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
+      if (DebugEnabled() == true)
+         NSLog(@"\nResponse status code: %ld", (long)[httpResponse statusCode]);
+      if (error != nil) {
+         if ([error localizedDescription] != nil) {
+            Fail(std::string([error localizedDescription].UTF8String));
+         } else {
+            Fail();
+         }
+      } else if (httpResponse.statusCode == 304) {
+         Res.IMSHit = true;
+         Res.LastModified = Itm->LastModified;
+         URIDone(Res);
+         success = YES;
+      } else if (httpResponse.statusCode < 200 || httpResponse.statusCode >= 400) {
+         Fail(std::string([NSString stringWithFormat:@"HTTP %li", (long)httpResponse.statusCode].UTF8String));
+         success = YES;
+      } else {
+         if (httpResponse.expectedContentLength != NSURLResponseUnknownLength)
+            Res.Size = httpResponse.expectedContentLength;
+         NSString *dateModified = httpResponse.allHeaderFields[@"Date"];
+         if (dateModified){
+            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
+            [formatter setLocale:[NSLocale localeWithLocaleIdentifier:@"en"]];
+            [formatter setDateFormat:@"EEEE, dd LLL yyyy HH:mm:ss zzz"];
+            NSDate *date = [formatter dateFromString:dateModified];
+            this->FailTime = [date timeIntervalSince1970];
+            [formatter release];
+         }
+         success = YES;
+         proceed = YES;
+      }
+      dispatch_semaphore_signal(sem);
+   }] resume];
+
+   Status(_("Connecting to %s"), Get.Host.c_str());
+   dispatch_semaphore_wait(sem, dispatch_time(DISPATCH_TIME_NOW, TimeOut * NSEC_PER_SEC));
+
+   // Get the files information
+   if (!proceed)
+   {
+      return success;
+   }
+
+   // See if it is an IMS hit
+   if (Itm->LastModified == FailTime) {
+      Res.Size = 0;
+      Res.IMSHit = true;
+      URIDone(Res);
+      return true;
+   }
+
+   // See if the file exists
+   struct stat Buf;
+   if (stat(Itm->DestFile.c_str(),&Buf) == 0) {
+      if (Res.Size == (unsigned long long)Buf.st_size && FailTime == Buf.st_mtime) {
+         Res.Size = Buf.st_size;
+         Res.LastModified = Buf.st_mtime;
+         Res.ResumePoint = Buf.st_size;
+         URIDone(Res);
+         return true;
+      }
+
+      // Resume?
+      if (FailTime == Buf.st_mtime && Res.Size > (unsigned long long)Buf.st_size)
+         Res.ResumePoint = Buf.st_size;
+   }
+
+   // Open the file
+   Hashes Hash(Itm->ExpectedHashes);
+   {
+      [request setHTTPMethod:@"GET"];
+
+      NSURLSessionDownloadTask *task = [[NSURLSession sharedSession] downloadTaskWithRequest:request completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error){
+         NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
+         if (httpResponse.statusCode == 200 && !error){
+            NSString *destFile = [NSString stringWithUTF8String:Itm->DestFile.c_str()];
+            [[NSFileManager defaultManager] removeItemAtPath:destFile error:nil];
+            success = [[NSFileManager defaultManager] moveItemAtPath:location.path toPath:destFile error:&error];
+            if (error){
+               success = NO;
+            }
+         }
+         dispatch_semaphore_signal(sem);
+      }];
+      [task resume];
+      dispatch_semaphore_wait(sem, dispatch_time(DISPATCH_TIME_NOW, TimeOut * NSEC_PER_SEC));
+
+      if (!success){
+         Fail();
+         return true;
+      }
+
+      FileFd Fd(Itm->DestFile,FileFd::WriteExists);
+      Hash.AddFD(Fd,Hashes::UntilEOF);
+
+      URIStart(Res);
+
+      Res.Size = Fd.Size();
+      struct timeval times[2];
+      times[0].tv_sec = FailTime;
+      times[1].tv_sec = FailTime;
+      times[0].tv_usec = times[1].tv_usec = 0;
+      utimes(Fd.Name().c_str(), times);
+   }
+
+   Res.LastModified = FailTime;
+   Res.TakeHashes(Hash);
+
+   URIDone(Res);
+
+   return true;
+}
+									/*}}}*/
+
+int main(int, const char *argv[])
+{
+   return HttpMethod(flNotDir(argv[0])).Run();
+}
