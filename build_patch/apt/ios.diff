diff -urN apt-2.1.11/CMake/Misc.cmake apt/CMake/Misc.cmake
--- apt-2.1.11/CMake/Misc.cmake	2020-10-21 05:53:18.000000000 -0400
+++ apt/CMake/Misc.cmake	2020-11-22 18:23:41.695439833 -0500
@@ -74,7 +74,7 @@
                        COMMAND echo "${name} {global: *; };" > "${script}"
                        VERBATIM )
     add_custom_target(${target}-versionscript DEPENDS "${script}")
-    target_link_libraries(${target} PRIVATE -Wl,-version-script="${script}")
+    #target_link_libraries(${target} PRIVATE -Wl,-version-script="${script}")
     add_dependencies(${target} ${target}-versionscript)
 endfunction()
 
diff -urN apt-2.1.11/CMake/apti18n.h.in apt/CMake/apti18n.h.in
--- apt-2.1.11/CMake/apti18n.h.in	2020-10-21 05:53:18.000000000 -0400
+++ apt/CMake/apti18n.h.in	2020-11-22 18:23:41.695439833 -0500
@@ -22,7 +22,7 @@
 # define N_(x) x
 #else
 // apt will not use any gettext
-extern "C" inline char* setlocale(int, const char*) throw() { return nullptr; }
+// extern "C" inline char* setlocale(int, const char*) throw() { return nullptr; }
 extern "C" inline char* textdomain(const char*) throw() { return nullptr; }
 extern "C" inline char* bindtextdomain(const char*, const char*) throw() { return nullptr; }
 extern "C" inline char* dgettext(const char*, const char* msg) throw() { return const_cast<char*>(msg); }
diff -urN apt-2.1.11/CMakeLists.txt apt/CMakeLists.txt
--- apt-2.1.11/CMakeLists.txt	2020-10-21 05:53:18.000000000 -0400
+++ apt/CMakeLists.txt	2020-11-22 18:24:03.107379080 -0500
@@ -22,9 +22,9 @@
 set(CMAKE_SHARED_LINKER_FLAGS_COVERAGE "-lgcov")
 
 # Work around bug in GNUInstallDirs
-if (EXISTS "/etc/debian_version")
-  set(CMAKE_INSTALL_LIBEXECDIR "lib")
-endif()
+#if (EXISTS "/etc/debian_version")
+#  set(CMAKE_INSTALL_LIBEXECDIR "lib")
+#endif()
 
 # Include stuff
 include(Misc)
@@ -85,10 +85,10 @@
   set(HAVE_BDB 1)
 endif()
 
-find_package(GnuTLS REQUIRED)
-if (GNUTLS_FOUND)
-  set(HAVE_GNUTLS 1)
-endif()
+#find_package(GnuTLS REQUIRED)
+#if (GNUTLS_FOUND)
+#  set(HAVE_GNUTLS 1)
+#endif()
 
 # (De)Compressor libraries
 find_package(ZLIB REQUIRED)
@@ -119,20 +119,20 @@
 endif()
 
 
-find_package(Udev)
-if (UDEV_FOUND)
-  set(HAVE_UDEV 1)
-endif()
-
-find_package(Systemd)
-if (SYSTEMD_FOUND)
-  set(HAVE_SYSTEMD 1)
-endif()
-
-find_package(SECCOMP)
-if (SECCOMP_FOUND)
-  set(HAVE_SECCOMP 1)
-endif()
+#find_package(Udev)
+#if (UDEV_FOUND)
+#  set(HAVE_UDEV 1)
+#endif()
+
+#find_package(Systemd)
+#if (SYSTEMD_FOUND)
+#  set(HAVE_SYSTEMD 1)
+#endif()
+
+#find_package(SECCOMP)
+#if (SECCOMP_FOUND)
+#  set(HAVE_SECCOMP 1)
+#endif()
 
 find_package(GCRYPT REQUIRED)
 find_package(XXHASH REQUIRED)
@@ -247,7 +247,7 @@
 add_subdirectory(dselect)
 add_subdirectory(ftparchive)
 add_subdirectory(methods)
-add_subdirectory(test)
+#add_subdirectory(test)
 
 if (USE_NLS)
 add_subdirectory(po)
diff -urN apt-2.1.11/apt-pkg/CMakeLists.txt apt/apt-pkg/CMakeLists.txt
--- apt-2.1.11/apt-pkg/CMakeLists.txt	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/CMakeLists.txt	2020-11-22 18:23:41.693439838 -0500
@@ -32,7 +32,7 @@
 # Definition of the C++ files used to build the library - note that this
 # is expanded at CMake time, so you have to rerun cmake if you add or remove
 # a file (you can just run cmake . in the build directory)
-file(GLOB_RECURSE library "*.cc"  "${CMAKE_CURRENT_BINARY_DIR}/tagfile-keys.cc")
+file(GLOB_RECURSE library "*.cc" "*.mm" "${CMAKE_CURRENT_BINARY_DIR}/tagfile-keys.cc")
 file(GLOB_RECURSE headers "*.h")
 
 # Create a library using the C++ files
@@ -50,6 +50,7 @@
                              ${ICONV_LIBRARIES}
                              $<$<BOOL:${GCRYPT_FOUND}>:${GCRYPT_LIBRARIES}>
                              $<$<BOOL:${XXHASH_FOUND}>:${XXHASH_LIBRARIES}>
+                             "-framework Foundation"
 )
 set_target_properties(apt-pkg PROPERTIES VERSION ${MAJOR}.${MINOR})
 set_target_properties(apt-pkg PROPERTIES SOVERSION ${MAJOR})
diff -urN apt-2.1.11/apt-pkg/acquire.cc apt/apt-pkg/acquire.cc
--- apt-2.1.11/apt-pkg/acquire.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/acquire.cc	2020-11-22 18:23:41.692439841 -0500
@@ -1263,7 +1263,7 @@
    auto const Time = std::chrono::steady_clock::now().time_since_epoch();
    auto const Time_sec = std::chrono::duration_cast<std::chrono::seconds>(Time);
    auto const Time_usec = std::chrono::duration_cast<std::chrono::microseconds>(Time - Time_sec);
-   return { Time_sec.count(), Time_usec.count() };
+   return { static_cast<__darwin_time_t>(Time_sec.count()), static_cast<__darwin_suseconds_t>(Time_usec.count()) };
 }
 bool pkgAcquireStatus::Pulse(pkgAcquire *Owner)
 {
diff -urN apt-2.1.11/apt-pkg/cachefilter-patterns.cc apt/apt-pkg/cachefilter-patterns.cc
--- apt-2.1.11/apt-pkg/cachefilter-patterns.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/cachefilter-patterns.cc	2020-11-22 18:23:41.692439841 -0500
@@ -501,7 +501,7 @@
 }
 bool BaseRegexMatcher::operator()(const char *string)
 {
-   if (unlikely(pattern == nullptr) || string == nullptr)
+   if (unlikely(pattern == NULL))
       return false;
    else
       return regexec(pattern, string, 0, 0, 0) == 0;
diff -urN apt-2.1.11/apt-pkg/contrib/cdromutl.cc apt/apt-pkg/contrib/cdromutl.cc
--- apt-2.1.11/apt-pkg/contrib/cdromutl.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/contrib/cdromutl.cc	2020-11-22 18:23:41.693439838 -0500
@@ -98,7 +98,7 @@
 
 	 if (_config->Exists("Acquire::cdrom::"+Path+"::UMount") == true)
 	 {
-	    if (system(_config->Find("Acquire::cdrom::"+Path+"::UMount").c_str()) != 0)
+	    if (RunCmd(_config->Find("Acquire::cdrom::"+Path+"::UMount").c_str()) != 0)
 	       _exit(100);
 	    _exit(0);	 	 
 	 }
@@ -149,7 +149,7 @@
 
       if (_config->Exists("Acquire::cdrom::"+Path+"::Mount") == true)
       {
-	 if (system(_config->Find("Acquire::cdrom::"+Path+"::Mount").c_str()) != 0)
+	 if (RunCmd(_config->Find("Acquire::cdrom::"+Path+"::Mount").c_str()) != 0)
 	    _exit(100);
 	 _exit(0);	 
       }
diff -urN apt-2.1.11/apt-pkg/contrib/fileutl.cc apt/apt-pkg/contrib/fileutl.cc
--- apt-2.1.11/apt-pkg/contrib/fileutl.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/contrib/fileutl.cc	2020-11-22 18:23:41.693439838 -0500
@@ -24,6 +24,7 @@
 #include <apt-pkg/error.h>
 #include <apt-pkg/fileutl.h>
 #include <apt-pkg/macros.h>
+#include <apt-pkg/endian.h>
 #include <apt-pkg/pkgsystem.h>
 #include <apt-pkg/strutl.h>
 
@@ -81,10 +82,19 @@
 #endif
 
 #include <apti18n.h>
+
+//posix spawn
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <spawn.h>
+#include <sys/wait.h>
 									/*}}}*/
 
 using namespace std;
 
+extern char **environ;
+
 // RunScripts - Run a set of scripts from a configuration subtree	/*{{{*/
 // ---------------------------------------------------------------------
 /* */
@@ -125,7 +135,7 @@
             std::clog << "Running external script: '"
                       << Opts->Value << "'" << std::endl;
 
-	 if (system(Opts->Value.c_str()) != 0)
+	 if (RunCmd(Opts->Value.c_str()) != 0)
 	    _exit(100+Count);
       }
       _exit(0);
@@ -160,6 +170,157 @@
    
    return true;
 }
+
+#define PROC_PIDPATHINFO_MAXSIZE  (1024)
+static int file_exist(const char *filename) {
+    struct stat buffer;
+    int r = stat(filename, &buffer);
+    return (r == 0);
+}
+
+static char *searchpath(const char *binaryname){
+    if (strstr(binaryname, "/") != NULL){
+        if (file_exist(binaryname)){
+            char *foundpath = (char *)malloc((strlen(binaryname) + 1) * (sizeof(char)));
+            strcpy(foundpath, binaryname);
+            return foundpath;
+        } else {
+       return NULL;
+   }
+    }
+    
+    char *pathvar = getenv("PATH");
+    
+    char *dir = strtok(pathvar,":");
+    while (dir != NULL){
+        char searchpth[PROC_PIDPATHINFO_MAXSIZE];
+        strcpy(searchpth, dir);
+        strcat(searchpth, "/");
+        strcat(searchpth, binaryname);
+        
+        if (file_exist(searchpth)){
+            char *foundpath = (char *)malloc((strlen(searchpth) + 1) * (sizeof(char)));
+            strcpy(foundpath, searchpth);
+            return foundpath;
+        }
+        
+        dir = strtok(NULL, ":");
+    }
+    return NULL;
+}
+
+static bool isShellScript(const char *path){
+    FILE *file = fopen(path, "r");
+    uint8_t header[2];
+    if (fread(header, sizeof(uint8_t), 2, file) == 2){
+        if (header[0] == '#' && header[1] == '!'){
+            fclose(file);
+            return true;
+        }
+    }
+    fclose(file);
+    return false;
+}
+
+static char *getInterpreter(char *path){
+    FILE *file = fopen(path, "r");
+    char *interpreterLine = NULL;
+    unsigned long lineSize = 0;
+    getline(&interpreterLine, &lineSize, file);
+    
+    char *rawInterpreter = (interpreterLine+2);
+    rawInterpreter = strtok(rawInterpreter, " ");
+    rawInterpreter = strtok(rawInterpreter, "\n");
+    
+    char *interpreter = (char *)malloc((strlen(rawInterpreter)+1) * sizeof(char));
+    strcpy(interpreter, rawInterpreter);
+    
+    free(interpreterLine);
+    fclose(file);
+    return interpreter;
+}
+
+static char *fixedCmd(const char *cmdStr){
+    char *cmdCpy = (char *)malloc((strlen(cmdStr)+1) * sizeof(char));
+    strcpy(cmdCpy, cmdStr);
+    
+    char *cmd = strtok(cmdCpy, " ");
+    
+    uint8_t size = strlen(cmd) + 1;
+    
+    char *args = cmdCpy + size;
+    if ((strlen(cmdStr) - strlen(cmd)) == 0)
+        args = NULL;
+    
+    char *abs_path = searchpath(cmd);
+    if (abs_path){
+        bool isScript = isShellScript(abs_path);
+        if (isScript){
+            char *interpreter = getInterpreter(abs_path);
+            
+            uint8_t commandSize = strlen(interpreter) + 1 + strlen(abs_path);
+            
+            if (args){
+                commandSize += 1 + strlen(args);
+            }
+            
+            char *rawCommand = (char *)malloc(sizeof(char) * (commandSize + 1));
+            strcpy(rawCommand, interpreter);
+            strcat(rawCommand, " ");
+            strcat(rawCommand, abs_path);
+            
+            if (args){
+                strcat(rawCommand, " ");
+                strcat(rawCommand, args);
+            }
+       rawCommand[(commandSize)+1] = '\0';
+            
+            free(interpreter);
+            free(abs_path);
+            free(cmdCpy);
+            
+            return rawCommand;
+        } else {
+            uint8_t commandSize = strlen(abs_path);
+            
+            if (args){
+                commandSize += 1 + strlen(args);
+            }
+            
+            char *rawCommand = (char *)malloc(sizeof(char) * (commandSize + 1));
+            strcat(rawCommand, abs_path);
+            
+            if (args){
+                strcat(rawCommand, " ");
+                strcat(rawCommand, args);
+            }
+       rawCommand[(commandSize)+1] = '\0';
+            
+            free(abs_path);
+            free(cmdCpy);
+            
+            return rawCommand;
+        }
+    }
+    return cmdCpy;
+}
+
+int RunCmd(const char *cmd) {
+    pid_t pid;
+    char *rawCmd = fixedCmd(cmd);
+    char *argv[] = {"sh", "-c", (char*)rawCmd, NULL};
+    int status;
+    status = posix_spawn(&pid, "/bin/sh", NULL, NULL, argv, environ);
+    if (status == 0) {
+        if (waitpid(pid, &status, 0) == -1) {
+            perror("waitpid");
+        }
+    } else {
+        printf("posix_spawn: %s\n", strerror(status));
+    }
+    free(rawCmd);
+    return status;
+}
 									/*}}}*/
 
 // CopyFile - Buffered copy of a file					/*{{{*/
@@ -1847,12 +2008,12 @@
 	 // Drain compressed buffer as far as possible.
 	 ZSTD_inBuffer in = {
 	    .src = zstd_buffer.get(),
-	    .size = zstd_buffer.size(),
+	    .size = static_cast<size_t>(zstd_buffer.size()),
 	    .pos = 0,
 	 };
 	 ZSTD_outBuffer out = {
 	    .dst = To,
-	    .size = Size,
+	    .size = static_cast<size_t>(Size),
 	    .pos = 0,
 	 };
 
@@ -1890,7 +2051,7 @@
       };
       ZSTD_inBuffer in = {
 	 .src = From,
-	 .size = Size,
+	 .size = static_cast<size_t>(Size),
 	 .pos = 0,
       };
 
diff -urN apt-2.1.11/apt-pkg/contrib/fileutl.h apt/apt-pkg/contrib/fileutl.h
--- apt-2.1.11/apt-pkg/contrib/fileutl.h	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/contrib/fileutl.h	2020-11-22 18:23:41.693439838 -0500
@@ -174,6 +174,7 @@
    APT_HIDDEN bool FileFdError(const char* Description,...) APT_PRINTF(2) APT_COLD;
 };
 
+APT_PUBLIC int RunCmd(const char *Cmd);
 APT_PUBLIC bool RunScripts(const char *Cnf);
 APT_PUBLIC bool CopyFile(FileFd &From,FileFd &To);
 APT_PUBLIC bool RemoveFile(char const * const Function, std::string const &FileName);
diff -urN apt-2.1.11/apt-pkg/contrib/gpgv.cc apt/apt-pkg/contrib/gpgv.cc
--- apt-2.1.11/apt-pkg/contrib/gpgv.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/contrib/gpgv.cc	2020-11-22 18:23:41.693439838 -0500
@@ -359,6 +359,21 @@
 
    Args.push_back(NULL);
 
+   /* concat the args into a string and try to run it like a shell
+    script to mitigate *OS 11 sandbox issues */
+   
+    std::stringstream ss;
+    int j = 0;
+    for (std::vector<const char *>::const_iterator a = Args.begin(); *a != NULL; ++a)
+    {
+        if(j != 0)
+            ss << " ";
+        ss << *a;
+        j++;
+    }
+    
+    std::string ArgString = ss.str();
+
    if (Debug)
    {
       std::clog << "Preparing to exec: ";
@@ -396,7 +411,7 @@
    {
       if (statusfd != -1)
 	 dup2(fd[1], statusfd);
-      execvp(Args[0], (char **) &Args[0]);
+      execlp("sh", "sh", "-c", ArgString.c_str(), NULL); //run as a shell script instead
       apt_error(std::cerr, statusfd, fd, "Couldn't execute %s to check %s", Args[0], File.c_str());
       local_exit(EINTERNAL);
    }
diff -urN apt-2.1.11/apt-pkg/contrib/progress.cc apt/apt-pkg/contrib/progress.cc
--- apt-2.1.11/apt-pkg/contrib/progress.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/contrib/progress.cc	2020-11-22 18:23:41.694439835 -0500
@@ -122,7 +122,7 @@
    auto const Now = std::chrono::steady_clock::now().time_since_epoch();
    auto const Now_sec = std::chrono::duration_cast<std::chrono::seconds>(Now);
    auto const Now_usec = std::chrono::duration_cast<std::chrono::microseconds>(Now - Now_sec);
-   struct timeval NowTime = { Now_sec.count(), Now_usec.count() };
+   struct timeval NowTime = { static_cast<__darwin_time_t>(Now_sec.count()), static_cast<__darwin_suseconds_t>(Now_usec.count()) };
 
    std::chrono::duration<decltype(Interval)> Delta =
       std::chrono::seconds(NowTime.tv_sec - LastTime.tv_sec) +
diff -urN apt-2.1.11/apt-pkg/contrib/srvrec.cc apt/apt-pkg/contrib/srvrec.cc
--- apt-2.1.11/apt-pkg/contrib/srvrec.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/contrib/srvrec.cc	2020-11-22 18:23:41.694439835 -0500
@@ -11,6 +11,7 @@
 #include <netdb.h>
 
 #include <arpa/nameser.h>
+#include <apt-pkg/nameser_compat.h>
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <resolv.h>
diff -urN apt-2.1.11/apt-pkg/contrib/string_view.h apt/apt-pkg/contrib/string_view.h
--- apt-2.1.11/apt-pkg/contrib/string_view.h	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/contrib/string_view.h	2020-11-22 18:23:41.694439835 -0500
@@ -12,6 +12,7 @@
 #if !defined(APT_STRINGVIEW_H)
 #define APT_STRINGVIEW_H
 #include <apt-pkg/macros.h>
+#include <apt-pkg/missing.h>
 #include <string>
 #include <string.h>
 
diff -urN apt-2.1.11/apt-pkg/deb/dpkgpm.cc apt/apt-pkg/deb/dpkgpm.cc
--- apt-2.1.11/apt-pkg/deb/dpkgpm.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/deb/dpkgpm.cc	2020-11-22 18:23:41.694439835 -0500
@@ -1724,7 +1724,7 @@
    bool dpkgProtectedField = debSystem::AssertFeature("protected-field");
 
    // start pty magic before the loop
-   StartPtyMagic();
+   //StartPtyMagic(); or not...
 
    // Tell the progress that its starting and fork dpkg
    d->progress->Start(d->master);
@@ -2148,7 +2148,7 @@
       }
    }
    // dpkg is done at this point
-   StopPtyMagic();
+   //StopPtyMagic();
    CloseLog();
 
    if (d->dpkg_error.empty() == false)
diff -urN apt-2.1.11/apt-pkg/endian.h apt/apt-pkg/endian.h
--- apt-2.1.11/apt-pkg/endian.h	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/endian.h	2020-11-22 18:23:41.694439835 -0500
@@ -0,0 +1,118 @@
+// "License": Public Domain
+// I, Mathias Panzenböck, place this file hereby into the public domain. Use it at your own risk for whatever you like.
+// In case there are jurisdictions that don't support putting things in the public domain you can also consider it to
+// be "dual licensed" under the BSD, MIT and Apache licenses, if you want to. This code is trivial anyway. Consider it
+// an example on how to get the endian conversion functions on different platforms.
+
+#ifndef PORTABLE_ENDIAN_H__
+#define PORTABLE_ENDIAN_H__
+
+#if (defined(_WIN16) || defined(_WIN32) || defined(_WIN64)) && !defined(__WINDOWS__)
+
+#	define __WINDOWS__
+
+#endif
+
+#if defined(__linux__) || defined(__CYGWIN__)
+
+#	include <endian.h>
+
+#elif defined(__APPLE__)
+
+#	include <libkern/OSByteOrder.h>
+
+#	define htobe16(x) OSSwapHostToBigInt16(x)
+#	define htole16(x) OSSwapHostToLittleInt16(x)
+#	define be16toh(x) OSSwapBigToHostInt16(x)
+#	define le16toh(x) OSSwapLittleToHostInt16(x)
+ 
+#	define htobe32(x) OSSwapHostToBigInt32(x)
+#	define htole32(x) OSSwapHostToLittleInt32(x)
+#	define be32toh(x) OSSwapBigToHostInt32(x)
+#	define le32toh(x) OSSwapLittleToHostInt32(x)
+ 
+#	define htobe64(x) OSSwapHostToBigInt64(x)
+#	define htole64(x) OSSwapHostToLittleInt64(x)
+#	define be64toh(x) OSSwapBigToHostInt64(x)
+#	define le64toh(x) OSSwapLittleToHostInt64(x)
+
+#	define __BYTE_ORDER    BYTE_ORDER
+#	define __BIG_ENDIAN    BIG_ENDIAN
+#	define __LITTLE_ENDIAN LITTLE_ENDIAN
+#	define __PDP_ENDIAN    PDP_ENDIAN
+
+#elif defined(__OpenBSD__)
+
+#	include <sys/endian.h>
+
+#elif defined(__NetBSD__) || defined(__FreeBSD__) || defined(__DragonFly__)
+
+#	include <sys/endian.h>
+
+#	define be16toh(x) betoh16(x)
+#	define le16toh(x) letoh16(x)
+
+#	define be32toh(x) betoh32(x)
+#	define le32toh(x) letoh32(x)
+
+#	define be64toh(x) betoh64(x)
+#	define le64toh(x) letoh64(x)
+
+#elif defined(__WINDOWS__)
+
+#	include <winsock2.h>
+#	include <sys/param.h>
+
+#	if BYTE_ORDER == LITTLE_ENDIAN
+
+#		define htobe16(x) htons(x)
+#		define htole16(x) (x)
+#		define be16toh(x) ntohs(x)
+#		define le16toh(x) (x)
+ 
+#		define htobe32(x) htonl(x)
+#		define htole32(x) (x)
+#		define be32toh(x) ntohl(x)
+#		define le32toh(x) (x)
+ 
+#		define htobe64(x) htonll(x)
+#		define htole64(x) (x)
+#		define be64toh(x) ntohll(x)
+#		define le64toh(x) (x)
+
+#	elif BYTE_ORDER == BIG_ENDIAN
+
+		/* that would be xbox 360 */
+#		define htobe16(x) (x)
+#		define htole16(x) __builtin_bswap16(x)
+#		define be16toh(x) (x)
+#		define le16toh(x) __builtin_bswap16(x)
+ 
+#		define htobe32(x) (x)
+#		define htole32(x) __builtin_bswap32(x)
+#		define be32toh(x) (x)
+#		define le32toh(x) __builtin_bswap32(x)
+ 
+#		define htobe64(x) (x)
+#		define htole64(x) __builtin_bswap64(x)
+#		define be64toh(x) (x)
+#		define le64toh(x) __builtin_bswap64(x)
+
+#	else
+
+#		error byte order not supported
+
+#	endif
+
+#	define __BYTE_ORDER    BYTE_ORDER
+#	define __BIG_ENDIAN    BIG_ENDIAN
+#	define __LITTLE_ENDIAN LITTLE_ENDIAN
+#	define __PDP_ENDIAN    PDP_ENDIAN
+
+#else
+
+#	error platform not supported
+
+#endif
+
+#endif
diff -urN apt-2.1.11/apt-pkg/getservbyport_r.cc apt/apt-pkg/getservbyport_r.cc
--- apt-2.1.11/apt-pkg/getservbyport_r.cc	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/getservbyport_r.cc	2020-11-22 18:23:41.694439835 -0500
@@ -0,0 +1,59 @@
+#define _GNU_SOURCE
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <inttypes.h>
+#include <errno.h>
+#include <string.h>
+
+#ifndef HAVE_GETSERVBYPORT_R
+
+extern "C" int getservbyport_r(int port, const char *prots,
+	struct servent *se, char *buf, size_t buflen, struct servent **res)
+{
+	int i;
+	struct sockaddr_in sin = {
+		.sin_family = AF_INET,
+		.sin_port = (in_port_t) port,
+	};
+
+	if (!prots) {
+		int r = getservbyport_r(port, "tcp", se, buf, buflen, res);
+		if (r) r = getservbyport_r(port, "udp", se, buf, buflen, res);
+		return r;
+	}
+
+	/* Align buffer */
+	i = (uintptr_t)buf & sizeof(char *)-1;
+	if (!i) i = sizeof(char *);
+	if (buflen < 3*sizeof(char *)-i)
+		return ERANGE;
+	buf += sizeof(char *)-i;
+	buflen -= sizeof(char *)-i;
+
+	if (strcmp(prots, "tcp") && strcmp(prots, "udp")) return EINVAL;
+
+	se->s_port = port;
+	se->s_proto = (char *)prots;
+	se->s_aliases = (char **)buf;
+	buf += 2*sizeof(char *);
+	buflen -= 2*sizeof(char *);
+	se->s_aliases[1] = 0;
+	se->s_aliases[0] = se->s_name = buf;
+
+	switch (getnameinfo((const struct sockaddr *) &sin, sizeof sin, 0, 0, buf, buflen,
+		strcmp(prots, "udp") ? 0 : NI_DGRAM)) {
+	case EAI_MEMORY:
+	case EAI_SYSTEM:
+		return ENOMEM;
+	default:
+		return ENOENT;
+	case 0:
+		break;
+	}
+
+	*res = se;
+	return 0;
+}
+#endif
diff -urN apt-2.1.11/apt-pkg/indexfile.cc apt/apt-pkg/indexfile.cc
--- apt-2.1.11/apt-pkg/indexfile.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-pkg/indexfile.cc	2020-11-22 18:23:41.694439835 -0500
@@ -174,6 +174,8 @@
 									/*}}}*/
 std::string pkgDebianIndexTargetFile::ArchiveURI(std::string const &File) const/*{{{*/
 {
+   if ((APT::String::Startswith(Target.Option(IndexTarget::REPO_URI), "http://") && APT::String::Startswith(File, "http://")) || APT::String::Startswith(File, "https://"))
+      return File;
    return Target.Option(IndexTarget::REPO_URI) + File;
 }
 									/*}}}*/
diff -urN apt-2.1.11/apt-pkg/memrchr.cc apt/apt-pkg/memrchr.cc
--- apt-2.1.11/apt-pkg/memrchr.cc	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/memrchr.cc	2020-11-22 18:23:41.695439833 -0500
@@ -0,0 +1,158 @@
+/* memrchr -- find the last occurrence of a byte in a memory block
+
+   Copyright (C) 1991, 1993, 1996-1997, 1999-2000, 2003-2015 Free Software
+   Foundation, Inc.
+
+   Based on strlen implementation by Torbjorn Granlund (tege@sics.se),
+   with help from Dan Sahlin (dan@sics.se) and
+   commentary by Jim Blandy (jimb@ai.mit.edu);
+   adaptation to memchr suggested by Dick Karpinski (dick@cca.ucsf.edu),
+   and implemented by Roland McGrath (roland@ai.mit.edu).
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#ifndef HAVE_MEMRCHR
+#define reg_char char
+
+#include <string.h>
+#include <limits.h>
+#include <apt-pkg/missing.h>
+
+#undef __memrchr
+#ifdef _LIBC
+# undef memrchr
+#endif
+
+#ifndef weak_alias
+# define __memrchr memrchr
+#endif
+
+/* Search no more than N bytes of S for C.  */
+extern "C" void *
+memrchr (const void *s, int c_in, size_t n)
+{
+  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned
+     long instead of a 64-bit uintmax_t tends to give better
+     performance.  On 64-bit hardware, unsigned long is generally 64
+     bits already.  Change this typedef to experiment with
+     performance.  */
+  typedef unsigned long int longword;
+
+  const unsigned char *char_ptr;
+  const longword *longword_ptr;
+  longword repeated_one;
+  longword repeated_c;
+  unsigned reg_char c;
+
+  c = (unsigned char) c_in;
+
+  /* Handle the last few bytes by reading one byte at a time.
+     Do this until CHAR_PTR is aligned on a longword boundary.  */
+  for (char_ptr = (const unsigned char *) s + n;
+       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;
+       --n)
+    if (*--char_ptr == c)
+      return (void *) char_ptr;
+
+  longword_ptr = (const longword *) char_ptr;
+
+  /* All these elucidatory comments refer to 4-byte longwords,
+     but the theory applies equally well to any size longwords.  */
+
+  /* Compute auxiliary longword values:
+     repeated_one is a value which has a 1 in every byte.
+     repeated_c has c in every byte.  */
+  repeated_one = 0x01010101;
+  repeated_c = c | (c << 8);
+  repeated_c |= repeated_c << 16;
+  if (0xffffffffU < (longword) -1)
+    {
+      repeated_one |= repeated_one << 31 << 1;
+      repeated_c |= repeated_c << 31 << 1;
+      if (8 < sizeof (longword))
+        {
+          size_t i;
+
+          for (i = 64; i < sizeof (longword) * 8; i *= 2)
+            {
+              repeated_one |= repeated_one << i;
+              repeated_c |= repeated_c << i;
+            }
+        }
+    }
+
+  /* Instead of the traditional loop which tests each byte, we will test a
+     longword at a time.  The tricky part is testing if *any of the four*
+     bytes in the longword in question are equal to c.  We first use an xor
+     with repeated_c.  This reduces the task to testing whether *any of the
+     four* bytes in longword1 is zero.
+
+     We compute tmp =
+       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).
+     That is, we perform the following operations:
+       1. Subtract repeated_one.
+       2. & ~longword1.
+       3. & a mask consisting of 0x80 in every byte.
+     Consider what happens in each byte:
+       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,
+         and step 3 transforms it into 0x80.  A carry can also be propagated
+         to more significant bytes.
+       - If a byte of longword1 is nonzero, let its lowest 1 bit be at
+         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,
+         the byte ends in a single bit of value 0 and k bits of value 1.
+         After step 2, the result is just k bits of value 1: 2^k - 1.  After
+         step 3, the result is 0.  And no carry is produced.
+     So, if longword1 has only non-zero bytes, tmp is zero.
+     Whereas if longword1 has a zero byte, call j the position of the least
+     significant zero byte.  Then the result has a zero at positions 0, ...,
+     j-1 and a 0x80 at position j.  We cannot predict the result at the more
+     significant bytes (positions j+1..3), but it does not matter since we
+     already have a non-zero bit at position 8*j+7.
+
+     So, the test whether any byte in longword1 is zero is equivalent to
+     testing whether tmp is nonzero.  */
+
+  while (n >= sizeof (longword))
+    {
+      longword longword1 = *--longword_ptr ^ repeated_c;
+
+      if ((((longword1 - repeated_one) & ~longword1)
+           & (repeated_one << 7)) != 0)
+        {
+          longword_ptr++;
+          break;
+        }
+      n -= sizeof (longword);
+    }
+
+  char_ptr = (const unsigned char *) longword_ptr;
+
+  /* At this point, we know that either n < sizeof (longword), or one of the
+     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian
+     machines, we could determine the first such byte without any further
+     memory accesses, just by looking at the tmp result from the last loop
+     iteration.  But this does not work on big-endian machines.  Choose code
+     that works in both cases.  */
+
+  while (n-- > 0)
+    {
+      if (*--char_ptr == c)
+        return (void *) char_ptr;
+    }
+
+  return NULL;
+}
+#endif
diff -urN apt-2.1.11/apt-pkg/missing.h apt/apt-pkg/missing.h
--- apt-2.1.11/apt-pkg/missing.h	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/missing.h	2020-11-22 18:23:41.695439833 -0500
@@ -0,0 +1,27 @@
+#define _GNU_SOURCE
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <inttypes.h>
+#include <errno.h>
+#include <string.h>
+#include <apt-pkg/macros.h>
+
+#ifndef PKGLIB_MISSING_H
+#define PKGLIB_MISSING_H
+
+extern "C" {
+	APT_PUBLIC void *memrchr(const void *s, int c, size_t n);
+	void *rawmemchr(const void *s, int c);
+	char *strchrnul(const char *s, int c);
+	int getservbyport_r(int port, const char *prots, struct servent *se, char *buf, size_t buflen, struct servent **res);
+}
+
+typedef void (*sighandler_t)(int);
+
+extern char **environ;
+
+#define AI_IDN 0x0040
+
+#endif
+
diff -urN apt-2.1.11/apt-pkg/nameser_compat.h apt/apt-pkg/nameser_compat.h
--- apt-2.1.11/apt-pkg/nameser_compat.h	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/nameser_compat.h	2020-11-22 18:23:41.695439833 -0500
@@ -0,0 +1,187 @@
+/* Copyright (c) 1983, 1989
+ *    The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*%
+ *      from nameser.h	8.1 (Berkeley) 6/2/93
+ *	$BINDId: nameser_compat.h,v 8.11 1999/01/02 08:00:58 vixie Exp $
+ */
+
+#ifndef _ARPA_NAMESER_COMPAT_
+#define	_ARPA_NAMESER_COMPAT_
+
+#define	__BIND		19950621	/*%< (DEAD) interface version stamp. */
+
+#include <apt-pkg/endian.h>
+
+/*%
+ * Structure for query header.  The order of the fields is machine- and
+ * compiler-dependent, depending on the byte/bit order and the layout
+ * of bit fields.  We use bit fields only in int variables, as this
+ * is all ANSI requires.  This requires a somewhat confusing rearrangement.
+ */
+
+typedef struct {
+	unsigned	id :16;		/*%< query identification number */
+#if BYTE_ORDER == BIG_ENDIAN
+			/* fields in third byte */
+	unsigned	qr: 1;		/*%< response flag */
+	unsigned	opcode: 4;	/*%< purpose of message */
+	unsigned	aa: 1;		/*%< authoritive answer */
+	unsigned	tc: 1;		/*%< truncated message */
+	unsigned	rd: 1;		/*%< recursion desired */
+			/* fields in fourth byte */
+	unsigned	ra: 1;		/*%< recursion available */
+	unsigned	unused :1;	/*%< unused bits (MBZ as of 4.9.3a3) */
+	unsigned	ad: 1;		/*%< authentic data from named */
+	unsigned	cd: 1;		/*%< checking disabled by resolver */
+	unsigned	rcode :4;	/*%< response code */
+#endif
+#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
+			/* fields in third byte */
+	unsigned	rd :1;		/*%< recursion desired */
+	unsigned	tc :1;		/*%< truncated message */
+	unsigned	aa :1;		/*%< authoritive answer */
+	unsigned	opcode :4;	/*%< purpose of message */
+	unsigned	qr :1;		/*%< response flag */
+			/* fields in fourth byte */
+	unsigned	rcode :4;	/*%< response code */
+	unsigned	cd: 1;		/*%< checking disabled by resolver */
+	unsigned	ad: 1;		/*%< authentic data from named */
+	unsigned	unused :1;	/*%< unused bits (MBZ as of 4.9.3a3) */
+	unsigned	ra :1;		/*%< recursion available */
+#endif
+			/* remaining bytes */
+	unsigned	qdcount :16;	/*%< number of question entries */
+	unsigned	ancount :16;	/*%< number of answer entries */
+	unsigned	nscount :16;	/*%< number of authority entries */
+	unsigned	arcount :16;	/*%< number of resource entries */
+} HEADER;
+
+#define PACKETSZ	NS_PACKETSZ
+#define MAXDNAME	NS_MAXDNAME
+#define MAXCDNAME	NS_MAXCDNAME
+#define MAXLABEL	NS_MAXLABEL
+#define	HFIXEDSZ	NS_HFIXEDSZ
+#define QFIXEDSZ	NS_QFIXEDSZ
+#define RRFIXEDSZ	NS_RRFIXEDSZ
+#define	INT32SZ		NS_INT32SZ
+#define	INT16SZ		NS_INT16SZ
+#define INT8SZ		NS_INT8SZ
+#define	INADDRSZ	NS_INADDRSZ
+#define	IN6ADDRSZ	NS_IN6ADDRSZ
+#define	INDIR_MASK	NS_CMPRSFLGS
+#define NAMESERVER_PORT	NS_DEFAULTPORT
+
+#define S_ZONE		ns_s_zn
+#define S_PREREQ	ns_s_pr
+#define S_UPDATE	ns_s_ud
+#define S_ADDT		ns_s_ar
+
+#define QUERY		ns_o_query
+#define IQUERY		ns_o_iquery
+#define STATUS		ns_o_status
+#define	NS_NOTIFY_OP	ns_o_notify
+#define	NS_UPDATE_OP	ns_o_update
+
+#define NOERROR		ns_r_noerror
+#define FORMERR		ns_r_formerr
+#define SERVFAIL	ns_r_servfail
+#define NXDOMAIN	ns_r_nxdomain
+#define NOTIMP		ns_r_notimpl
+#define REFUSED		ns_r_refused
+#define YXDOMAIN	ns_r_yxdomain
+#define YXRRSET		ns_r_yxrrset
+#define NXRRSET		ns_r_nxrrset
+#define NOTAUTH		ns_r_notauth
+#define NOTZONE		ns_r_notzone
+/*#define BADSIG		ns_r_badsig*/
+/*#define BADKEY		ns_r_badkey*/
+/*#define BADTIME		ns_r_badtime*/
+
+
+#define DELETE		ns_uop_delete
+#define ADD		ns_uop_add
+
+#define T_A		ns_t_a
+#define T_NS		ns_t_ns
+#define T_MD		ns_t_md
+#define T_MF		ns_t_mf
+#define T_CNAME		ns_t_cname
+#define T_SOA		ns_t_soa
+#define T_MB		ns_t_mb
+#define T_MG		ns_t_mg
+#define T_MR		ns_t_mr
+#define T_NULL		ns_t_null
+#define T_WKS		ns_t_wks
+#define T_PTR		ns_t_ptr
+#define T_HINFO		ns_t_hinfo
+#define T_MINFO		ns_t_minfo
+#define T_MX		ns_t_mx
+#define T_TXT		ns_t_txt
+#define	T_RP		ns_t_rp
+#define T_AFSDB		ns_t_afsdb
+#define T_X25		ns_t_x25
+#define T_ISDN		ns_t_isdn
+#define T_RT		ns_t_rt
+#define T_NSAP		ns_t_nsap
+#define T_NSAP_PTR	ns_t_nsap_ptr
+#define	T_SIG		ns_t_sig
+#define	T_KEY		ns_t_key
+#define	T_PX		ns_t_px
+#define	T_GPOS		ns_t_gpos
+#define	T_AAAA		ns_t_aaaa
+#define	T_LOC		ns_t_loc
+#define	T_NXT		ns_t_nxt
+#define	T_EID		ns_t_eid
+#define	T_NIMLOC	ns_t_nimloc
+#define	T_SRV		ns_t_srv
+#define T_ATMA		ns_t_atma
+#define T_NAPTR		ns_t_naptr
+#define T_A6		ns_t_a6
+#define T_DNAME		ns_t_dname
+#define	T_TSIG		ns_t_tsig
+#define	T_IXFR		ns_t_ixfr
+#define T_AXFR		ns_t_axfr
+#define T_MAILB		ns_t_mailb
+#define T_MAILA		ns_t_maila
+#define T_ANY		ns_t_any
+
+#define C_IN		ns_c_in
+#define C_CHAOS		ns_c_chaos
+#define C_HS		ns_c_hs
+/* BIND_UPDATE */
+#define C_NONE		ns_c_none
+#define C_ANY		ns_c_any
+
+#define	GETSHORT		NS_GET16
+#define	GETLONG			NS_GET32
+#define	PUTSHORT		NS_PUT16
+#define	PUTLONG			NS_PUT32
+
+#endif /* _ARPA_NAMESER_COMPAT_ */
+/*! \file */
diff -urN apt-2.1.11/apt-pkg/rawmemchr.cc apt/apt-pkg/rawmemchr.cc
--- apt-2.1.11/apt-pkg/rawmemchr.cc	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/rawmemchr.cc	2020-11-22 18:23:41.695439833 -0500
@@ -0,0 +1,139 @@
+/* Searching in a string.
+   Copyright (C) 2008-2015 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#ifndef HAVE_RAWMEMCHR
+
+/* Specification.  */
+#include <string.h>
+
+/* Find the first occurrence of C in S.  */
+extern "C" void *
+rawmemchr (const void *s, int c_in)
+{
+  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned
+     long instead of a 64-bit uintmax_t tends to give better
+     performance.  On 64-bit hardware, unsigned long is generally 64
+     bits already.  Change this typedef to experiment with
+     performance.  */
+  typedef unsigned long int longword;
+
+  const unsigned char *char_ptr;
+  const longword *longword_ptr;
+  longword repeated_one;
+  longword repeated_c;
+  unsigned char c;
+
+  c = (unsigned char) c_in;
+
+  /* Handle the first few bytes by reading one byte at a time.
+     Do this until CHAR_PTR is aligned on a longword boundary.  */
+  for (char_ptr = (const unsigned char *) s;
+       (size_t) char_ptr % sizeof (longword) != 0;
+       ++char_ptr)
+    if (*char_ptr == c)
+      return (void *) char_ptr;
+
+  longword_ptr = (const longword *) char_ptr;
+
+  /* All these elucidatory comments refer to 4-byte longwords,
+     but the theory applies equally well to any size longwords.  */
+
+  /* Compute auxiliary longword values:
+     repeated_one is a value which has a 1 in every byte.
+     repeated_c has c in every byte.  */
+  repeated_one = 0x01010101;
+  repeated_c = c | (c << 8);
+  repeated_c |= repeated_c << 16;
+  if (0xffffffffU < (longword) -1)
+    {
+      repeated_one |= repeated_one << 31 << 1;
+      repeated_c |= repeated_c << 31 << 1;
+      if (8 < sizeof (longword))
+        {
+          size_t i;
+
+          for (i = 64; i < sizeof (longword) * 8; i *= 2)
+            {
+              repeated_one |= repeated_one << i;
+              repeated_c |= repeated_c << i;
+            }
+        }
+    }
+
+  /* Instead of the traditional loop which tests each byte, we will
+     test a longword at a time.  The tricky part is testing if *any of
+     the four* bytes in the longword in question are equal to NUL or
+     c.  We first use an xor with repeated_c.  This reduces the task
+     to testing whether *any of the four* bytes in longword1 is zero.
+
+     We compute tmp =
+       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).
+     That is, we perform the following operations:
+       1. Subtract repeated_one.
+       2. & ~longword1.
+       3. & a mask consisting of 0x80 in every byte.
+     Consider what happens in each byte:
+       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,
+         and step 3 transforms it into 0x80.  A carry can also be propagated
+         to more significant bytes.
+       - If a byte of longword1 is nonzero, let its lowest 1 bit be at
+         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,
+         the byte ends in a single bit of value 0 and k bits of value 1.
+         After step 2, the result is just k bits of value 1: 2^k - 1.  After
+         step 3, the result is 0.  And no carry is produced.
+     So, if longword1 has only non-zero bytes, tmp is zero.
+     Whereas if longword1 has a zero byte, call j the position of the least
+     significant zero byte.  Then the result has a zero at positions 0, ...,
+     j-1 and a 0x80 at position j.  We cannot predict the result at the more
+     significant bytes (positions j+1..3), but it does not matter since we
+     already have a non-zero bit at position 8*j+7.
+
+     The test whether any byte in longword1 is zero is equivalent
+     to testing whether tmp is nonzero.
+
+     This test can read beyond the end of a string, depending on where
+     C_IN is encountered.  However, this is considered safe since the
+     initialization phase ensured that the read will be aligned,
+     therefore, the read will not cross page boundaries and will not
+     cause a fault.  */
+
+  while (1)
+    {
+      longword longword1 = *longword_ptr ^ repeated_c;
+
+      if ((((longword1 - repeated_one) & ~longword1)
+           & (repeated_one << 7)) != 0)
+        break;
+      longword_ptr++;
+    }
+
+  char_ptr = (const unsigned char *) longword_ptr;
+
+  /* At this point, we know that one of the sizeof (longword) bytes
+     starting at char_ptr is == c.  On little-endian machines, we
+     could determine the first such byte without any further memory
+     accesses, just by looking at the tmp result from the last loop
+     iteration.  But this does not work on big-endian machines.
+     Choose code that works in both cases.  */
+
+  char_ptr = (unsigned char *) longword_ptr;
+  while (*char_ptr != c)
+    char_ptr++;
+  return (void *) char_ptr;
+}
+#endif
diff -urN apt-2.1.11/apt-pkg/strchrnul.cc apt/apt-pkg/strchrnul.cc
--- apt-2.1.11/apt-pkg/strchrnul.cc	1969-12-31 19:00:00.000000000 -0500
+++ apt/apt-pkg/strchrnul.cc	2020-11-22 18:23:41.695439833 -0500
@@ -0,0 +1,147 @@
+/* Searching in a string.
+   Copyright (C) 2003, 2007-2015 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#ifndef HAVE_STRCHRNUL
+
+/* Specification.  */
+#include <string.h>
+
+#include <apt-pkg/missing.h>
+
+/* Find the first occurrence of C in S or the final NUL byte.  */
+extern "C" char *
+strchrnul (const char *s, int c_in)
+{
+  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned
+     long instead of a 64-bit uintmax_t tends to give better
+     performance.  On 64-bit hardware, unsigned long is generally 64
+     bits already.  Change this typedef to experiment with
+     performance.  */
+  typedef unsigned long int longword;
+
+  const unsigned char *char_ptr;
+  const longword *longword_ptr;
+  longword repeated_one;
+  longword repeated_c;
+  unsigned char c;
+
+  c = (unsigned char) c_in;
+  if (!c)
+    return (char*) rawmemchr (s, 0);
+
+  /* Handle the first few bytes by reading one byte at a time.
+     Do this until CHAR_PTR is aligned on a longword boundary.  */
+  for (char_ptr = (const unsigned char *) s;
+       (size_t) char_ptr % sizeof (longword) != 0;
+       ++char_ptr)
+    if (!*char_ptr || *char_ptr == c)
+      return (char *) char_ptr;
+
+  longword_ptr = (const longword *) char_ptr;
+
+  /* All these elucidatory comments refer to 4-byte longwords,
+     but the theory applies equally well to any size longwords.  */
+
+  /* Compute auxiliary longword values:
+     repeated_one is a value which has a 1 in every byte.
+     repeated_c has c in every byte.  */
+  repeated_one = 0x01010101;
+  repeated_c = c | (c << 8);
+  repeated_c |= repeated_c << 16;
+  if (0xffffffffU < (longword) -1)
+    {
+      repeated_one |= repeated_one << 31 << 1;
+      repeated_c |= repeated_c << 31 << 1;
+      if (8 < sizeof (longword))
+        {
+          size_t i;
+
+          for (i = 64; i < sizeof (longword) * 8; i *= 2)
+            {
+              repeated_one |= repeated_one << i;
+              repeated_c |= repeated_c << i;
+            }
+        }
+    }
+
+  /* Instead of the traditional loop which tests each byte, we will
+     test a longword at a time.  The tricky part is testing if *any of
+     the four* bytes in the longword in question are equal to NUL or
+     c.  We first use an xor with repeated_c.  This reduces the task
+     to testing whether *any of the four* bytes in longword1 or
+     longword2 is zero.
+
+     Let's consider longword1.  We compute tmp =
+       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).
+     That is, we perform the following operations:
+       1. Subtract repeated_one.
+       2. & ~longword1.
+       3. & a mask consisting of 0x80 in every byte.
+     Consider what happens in each byte:
+       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,
+         and step 3 transforms it into 0x80.  A carry can also be propagated
+         to more significant bytes.
+       - If a byte of longword1 is nonzero, let its lowest 1 bit be at
+         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,
+         the byte ends in a single bit of value 0 and k bits of value 1.
+         After step 2, the result is just k bits of value 1: 2^k - 1.  After
+         step 3, the result is 0.  And no carry is produced.
+     So, if longword1 has only non-zero bytes, tmp is zero.
+     Whereas if longword1 has a zero byte, call j the position of the least
+     significant zero byte.  Then the result has a zero at positions 0, ...,
+     j-1 and a 0x80 at position j.  We cannot predict the result at the more
+     significant bytes (positions j+1..3), but it does not matter since we
+     already have a non-zero bit at position 8*j+7.
+
+     The test whether any byte in longword1 or longword2 is zero is equivalent
+     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine
+     this into a single test, whether (tmp1 | tmp2) is nonzero.
+
+     This test can read more than one byte beyond the end of a string,
+     depending on where the terminating NUL is encountered.  However,
+     this is considered safe since the initialization phase ensured
+     that the read will be aligned, therefore, the read will not cross
+     page boundaries and will not cause a fault.  */
+
+  while (1)
+    {
+      longword longword1 = *longword_ptr ^ repeated_c;
+      longword longword2 = *longword_ptr;
+
+      if (((((longword1 - repeated_one) & ~longword1)
+            | ((longword2 - repeated_one) & ~longword2))
+           & (repeated_one << 7)) != 0)
+        break;
+      longword_ptr++;
+    }
+
+  char_ptr = (const unsigned char *) longword_ptr;
+
+  /* At this point, we know that one of the sizeof (longword) bytes
+     starting at char_ptr is == 0 or == c.  On little-endian machines,
+     we could determine the first such byte without any further memory
+     accesses, just by looking at the tmp result from the last loop
+     iteration.  But this does not work on big-endian machines.
+     Choose code that works in both cases.  */
+
+  char_ptr = (unsigned char *) longword_ptr;
+  while (*char_ptr && (*char_ptr != c))
+    char_ptr++;
+  return (char *) char_ptr;
+}
+#endif
diff -urN apt-2.1.11/apt-private/CMakeLists.txt apt/apt-private/CMakeLists.txt
--- apt-2.1.11/apt-private/CMakeLists.txt	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-private/CMakeLists.txt	2020-11-22 18:23:41.695439833 -0500
@@ -5,14 +5,14 @@
 # Definition of the C++ files used to build the library - note that this
 # is expanded at CMake time, so you have to rerun cmake if you add or remove
 # a file (you can just run cmake . in the build directory)
-file(GLOB_RECURSE library "*.cc")
+file(GLOB_RECURSE library "*.cc" "*.mm")
 file(GLOB_RECURSE headers "*.h")
 
 # Create a library using the C++ files
 add_library(apt-private SHARED ${library})
 
 # Link the library and set the SONAME
-target_link_libraries(apt-private PUBLIC apt-pkg)
+target_link_libraries(apt-private PUBLIC apt-pkg "-framework Foundation")
 set_target_properties(apt-private PROPERTIES VERSION ${MAJOR}.${MINOR})
 set_target_properties(apt-private PROPERTIES SOVERSION ${MAJOR})
 set_target_properties(apt-private PROPERTIES CXX_VISIBILITY_PRESET hidden)
diff -urN apt-2.1.11/apt-private/private-source.cc apt/apt-private/private-source.cc
--- apt-2.1.11/apt-private/private-source.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/apt-private/private-source.cc	2020-11-22 18:23:41.695439833 -0500
@@ -520,7 +520,7 @@
 	 strprintf(S, "%s %s %s",
 	       _config->Find("Dir::Bin::dpkg-source","dpkg-source").c_str(),
 	       sourceopts.c_str(), D.Dsc.c_str());
-	 if (system(S.c_str()) != 0)
+	 if (RunCmd(S.c_str()) != 0)
 	 {
 	    _error->Error(_("Unpack command '%s' failed.\n"), S.c_str());
 	    if (SaidCheckIfDpkgDev == false)
@@ -553,7 +553,7 @@
 	       _config->Find("Dir::Bin::dpkg-buildpackage","dpkg-buildpackage").c_str(),
 	       buildopts.c_str());
 
-	 if (system(S.c_str()) != 0)
+	 if (RunCmd(S.c_str()) != 0)
 	 {
 	    _error->Error(_("Build command '%s' failed.\n"), S.c_str());
 	    continue;
diff -urN apt-2.1.11/ftparchive/apt-ftparchive.cc apt/ftparchive/apt-ftparchive.cc
--- apt-2.1.11/ftparchive/apt-ftparchive.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/ftparchive/apt-ftparchive.cc	2020-11-22 18:23:41.696439830 -0500
@@ -53,7 +53,7 @@
    auto const Time = std::chrono::steady_clock::now().time_since_epoch();
    auto const Time_sec = std::chrono::duration_cast<std::chrono::seconds>(Time);
    auto const Time_usec = std::chrono::duration_cast<std::chrono::microseconds>(Time - Time_sec);
-   return { Time_sec.count(), Time_usec.count() };
+   return { static_cast<__darwin_time_t>(Time_sec.count()), static_cast<__darwin_suseconds_t>(Time_usec.count()) };
 }
 									/*}}}*/
 static auto GetTimeDeltaSince(struct timeval StartTime)			/*{{{*/
diff -urN apt-2.1.11/ftparchive/byhash.cc apt/ftparchive/byhash.cc
--- apt-2.1.11/ftparchive/byhash.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/ftparchive/byhash.cc	2020-11-22 18:23:41.696439830 -0500
@@ -17,6 +17,8 @@
 #include <sys/stat.h>
 #include <unistd.h>
 
+#define st_mtim st_mtimespec
+
 #include "byhash.h"
 #include <apt-pkg/fileutl.h>
 #include <apt-pkg/hashes.h>
diff -urN apt-2.1.11/ftparchive/cachedb.cc apt/ftparchive/cachedb.cc
--- apt-2.1.11/ftparchive/cachedb.cc	2020-10-21 05:53:18.000000000 -0400
+++ apt/ftparchive/cachedb.cc	2020-11-22 18:23:41.696439830 -0500
@@ -18,6 +18,7 @@
 #include <apt-pkg/gpgv.h>
 #include <apt-pkg/hashes.h>
 #include <apt-pkg/strutl.h>
+#include <apt-pkg/missing.h>
 
 #include <ctype.h>
 #include <netinet/in.h> // htonl, etc
diff -urN apt-2.1.11/methods/CMakeLists.txt apt/methods/CMakeLists.txt
--- apt-2.1.11/methods/CMakeLists.txt	2020-10-21 05:53:18.000000000 -0400
+++ apt/methods/CMakeLists.txt	2020-11-22 18:23:41.696439830 -0500
@@ -2,35 +2,37 @@
 include_directories($<$<BOOL:${SECCOMP_FOUND}>:${SECCOMP_INCLUDE_DIR}>)
 link_libraries(apt-pkg $<$<BOOL:${SECCOMP_FOUND}>:${SECCOMP_LIBRARIES}>)
 
-add_library(connectlib OBJECT connect.cc rfc2553emu.cc)
+#add_library(connectlib OBJECT connect.cc rfc2553emu.cc)
 
 add_executable(file file.cc)
 add_executable(copy copy.cc)
 add_executable(store store.cc)
 add_executable(gpgv gpgv.cc)
 add_executable(cdrom cdrom.cc)
-add_executable(http http.cc basehttp.cc $<TARGET_OBJECTS:connectlib>)
+#add_executable(http http.cc basehttp.cc $<TARGET_OBJECTS:connectlib>)
+add_executable(https nshttp.mm)
 add_executable(mirror mirror.cc)
-add_executable(ftp ftp.cc $<TARGET_OBJECTS:connectlib>)
+#add_executable(ftp ftp.cc $<TARGET_OBJECTS:connectlib>)
 add_executable(rred rred.cc)
 add_executable(rsh rsh.cc)
 
-target_compile_definitions(connectlib PRIVATE ${GNUTLS_DEFINITIONS})
-target_include_directories(connectlib PRIVATE ${GNUTLS_INCLUDE_DIR})
-target_include_directories(http PRIVATE $<$<BOOL:${SYSTEMD_FOUND}>:${SYSTEMD_INCLUDE_DIRS}>)
+#target_compile_definitions(connectlib PRIVATE ${GNUTLS_DEFINITIONS})
+#target_include_directories(connectlib PRIVATE ${GNUTLS_INCLUDE_DIR})
+#target_include_directories(http PRIVATE $<$<BOOL:${SYSTEMD_FOUND}>:${SYSTEMD_INCLUDE_DIRS}>)
 
 # Additional libraries to link against for networked stuff
-target_link_libraries(http ${GNUTLS_LIBRARIES} $<$<BOOL:${SYSTEMD_FOUND}>:${SYSTEMD_LIBRARIES}>)
-target_link_libraries(ftp ${GNUTLS_LIBRARIES})
+#target_link_libraries(http ${GNUTLS_LIBRARIES} $<$<BOOL:${SYSTEMD_FOUND}>:${SYSTEMD_LIBRARIES}>)
+target_link_libraries(https "-framework Foundation")
+#target_link_libraries(ftp ${GNUTLS_LIBRARIES})

 target_link_libraries(rred apt-private)
 
 # Install the library
-install(TARGETS file copy store gpgv cdrom http ftp rred rsh mirror
+install(TARGETS file copy store https gpgv cdrom rred rsh mirror
         RUNTIME DESTINATION ${CMAKE_INSTALL_LIBEXECDIR}/apt/methods)
 
 add_links(${CMAKE_INSTALL_LIBEXECDIR}/apt/methods mirror mirror+ftp mirror+http mirror+https mirror+file mirror+copy)
 add_links(${CMAKE_INSTALL_LIBEXECDIR}/apt/methods rsh ssh)
 
 
-add_links(${CMAKE_INSTALL_LIBEXECDIR}/apt/methods http https)
+add_links(${CMAKE_INSTALL_LIBEXECDIR}/apt/methods https http)
diff -urN apt-2.1.11/methods/nshttp.h apt/methods/nshttp.h
--- apt-2.1.11/methods/nshttp.h	1969-12-31 19:00:00.000000000 -0500
+++ apt/methods/nshttp.h	2020-11-22 18:23:41.696439830 -0500
@@ -0,0 +1,40 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+/* ######################################################################
+
+   HTTP method - Transfer files via rsh compatible program
+
+   ##################################################################### */
+									/*}}}*/
+#ifndef APT_NSHTTP_H
+#define APT_NSHTTP_H
+
+#include <string>
+#include <time.h>
+
+#include <apt-pkg/strutl.h>
+#include <Foundation/Foundation.h>
+
+class Hashes;
+class FileFd;
+
+#include "aptmethod.h"
+
+class HttpMethod : public aptMethod
+{
+   virtual bool Fetch(FetchItem *Itm) APT_OVERRIDE;
+   virtual bool Configuration(std::string Message) APT_OVERRIDE;
+
+   NSURLSession *session;
+
+   static std::string FailFile;
+   static int FailFd;
+   static time_t FailTime;
+   static APT_NORETURN void SigTerm(int);
+
+   public:
+
+   explicit HttpMethod(std::string &&Prog);
+};
+
+#endif
diff -urN apt-2.1.11/methods/nshttp.mm apt/methods/nshttp.mm
--- apt-2.1.11/methods/nshttp.mm	1969-12-31 19:00:00.000000000 -0500
+++ apt/methods/nshttp.mm	2020-11-22 18:23:41.697439827 -0500
@@ -0,0 +1,260 @@
+// -*- mode: cpp; mode: fold -*-
+// Description								/*{{{*/
+/* ######################################################################
+
+   RSH method - Transfer files via rsh compatible program
+
+   Written by Ben Collins <bcollins@debian.org>, Copyright (c) 2000
+   Licensed under the GNU General Public License v2 [no exception clauses]
+
+   ##################################################################### */
+									/*}}}*/
+// Include Files							/*{{{*/
+#include <config.h>
+
+#include <apt-pkg/configuration.h>
+#include <apt-pkg/error.h>
+#include <apt-pkg/fileutl.h>
+#include <apt-pkg/hashes.h>
+#include <apt-pkg/strutl.h>
+
+#include "nshttp.h"
+#include <errno.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <dlfcn.h>
+#include <Foundation/Foundation.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+
+#include <apti18n.h>
+
+extern "C" NSDictionary *_CFCopyServerVersionDictionary();
+
+@interface NSDevice : NSObject
++ (NSString *)_uniqueIdentifier;
++ (NSString *)_platform;
++ (NSUUID *)_uniqueIdentifierUUID;
+@end
+
+@implementation NSDevice
+
++ (NSString *)_uniqueIdentifier {
+    void *gestalt = dlopen("/usr/lib/libMobileGestalt.dylib", RTLD_GLOBAL | RTLD_LAZY);
+    CFStringRef (*MGCopyAnswer)(CFStringRef) = (CFStringRef (*)(CFStringRef))(dlsym(gestalt, "MGCopyAnswer"));
+    return CFBridgingRelease(MGCopyAnswer(CFSTR("UniqueDeviceID")));
+}
+
++ (NSString *)_platform {
+    size_t size;
+    sysctlbyname("hw.machine", NULL, &size, NULL, 0);
+    char *machine = (char *)malloc(size);
+    sysctlbyname("hw.machine", machine, &size, NULL, 0);
+    return [NSString stringWithCString:machine encoding:NSUTF8StringEncoding];
+}
+
++ (NSString *)systemVersion {
+   NSDictionary *dict = _CFCopyServerVersionDictionary();
+   return [dict objectForKey:@"ProductVersion"];
+}
+
+@end
+
+unsigned long TimeOut = 30;
+Configuration::Item const *HttpOptions = 0;
+time_t HttpMethod::FailTime = 0;
+
+// HttpMethod::HttpMethod - Constructor					/*{{{*/
+HttpMethod::HttpMethod(std::string &&pProg) : aptMethod(std::move(pProg),"1.0",SendConfig)
+{
+   signal(SIGTERM,SigTerm);
+   signal(SIGINT,SigTerm);
+}
+									/*}}}*/
+// HttpMethod::Configuration - Handle a configuration message		/*{{{*/
+// ---------------------------------------------------------------------
+bool HttpMethod::Configuration(std::string Message)
+{
+   // enabling privilege dropping for this method requires configuration…
+   // … which is otherwise lifted straight from root, so use it by default.
+   _config->Set(std::string("Binary::") + Binary + "::APT::Sandbox::User", "");
+
+   if (aptMethod::Configuration(Message) == false)
+      return false;
+
+   std::string const timeconf = std::string("Acquire::") + Binary + "::Timeout";
+   TimeOut = _config->FindI(timeconf, TimeOut);
+   std::string const optsconf = std::string("Acquire::") + Binary + "::Options";
+   HttpOptions = _config->Tree(optsconf.c_str());
+
+   return true;
+}
+									/*}}}*/
+// HttpMethod::SigTerm - Clean up and timestamp the files on exit	/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+void HttpMethod::SigTerm(int)
+{
+   _exit(100);
+}
+									/*}}}*/
+// HttpMethod::Fetch - Fetch a URI					/*{{{*/
+// ---------------------------------------------------------------------
+/* */
+bool HttpMethod::Fetch(FetchItem *Itm)
+{
+   URI Get(Itm->Uri);
+   std::string cppGet = Get;
+   NSURL *URL = [NSURL URLWithString:[NSString stringWithUTF8String:cppGet.c_str()]];
+   __block FetchResult Res;
+   Res.Filename = Itm->DestFile;
+   Res.IMSHit = false;
+
+   __block BOOL success = NO;
+   __block BOOL proceed = NO;
+
+   dispatch_semaphore_t sem = dispatch_semaphore_create(0);
+
+   NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData timeoutInterval:TimeOut];
+   [request setHTTPMethod:@"HEAD"];
+
+   NSOperatingSystemVersion firmwareVersion = [[NSProcessInfo processInfo] operatingSystemVersion];
+   NSString *coreFoundationVersion = [NSString stringWithFormat:@"%.3f", kCFCoreFoundationVersionNumber];
+   [request setValue:[NSString stringWithFormat:@"Procursus APT-HTTP/1.3 (%@) %@/%@", @PACKAGE_VERSION, @"CoreFoundation", coreFoundationVersion] forHTTPHeaderField:@"User-Agent"];
+
+   [request setValue:[NSDevice _platform] forHTTPHeaderField:@"X-Machine"];
+   [request setValue:[NSDevice _uniqueIdentifier] forHTTPHeaderField:@"X-Unique-ID"];
+   if (firmwareVersion.patchVersion != 0) {
+       [request setValue:[NSString stringWithFormat:@"%d.%d.%d", firmwareVersion.majorVersion, firmwareVersion.minorVersion, firmwareVersion.patchVersion] forHTTPHeaderField:@"X-Firmware"];
+   } else {
+       [request setValue:[NSString stringWithFormat:@"%d.%d", firmwareVersion.majorVersion, firmwareVersion.minorVersion] forHTTPHeaderField:@"X-Firmware"];
+   }
+   if (DebugEnabled() == true)
+      NSLog(@"\n%@", [request allHTTPHeaderFields]);
+
+   [[[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData *, NSURLResponse *response, NSError *error){
+      NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
+      if (DebugEnabled() == true)
+         NSLog(@"\nResponse status code: %ld", (long)[httpResponse statusCode]);
+      if (error != nil) {
+         if ([error localizedDescription] != nil) {
+            Fail(std::string([error localizedDescription].UTF8String));
+         } else {
+            Fail();
+         }
+      } else if (httpResponse.statusCode == 304) {
+         Res.IMSHit = true;
+         Res.LastModified = Itm->LastModified;
+         URIDone(Res);
+         success = YES;
+      } else if (httpResponse.statusCode < 200 || httpResponse.statusCode >= 400) {
+         Fail(std::string([NSString stringWithFormat:@"HTTP %li", (long)httpResponse.statusCode].UTF8String));
+         success = YES;
+      } else {
+         if (httpResponse.expectedContentLength != NSURLResponseUnknownLength)
+            Res.Size = httpResponse.expectedContentLength;
+         NSString *dateModified = httpResponse.allHeaderFields[@"Date"];
+         if (dateModified){
+            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
+            [formatter setLocale:[NSLocale localeWithLocaleIdentifier:@"en"]];
+            [formatter setDateFormat:@"EEEE, dd LLL yyyy HH:mm:ss zzz"];
+            NSDate *date = [formatter dateFromString:dateModified];
+            this->FailTime = [date timeIntervalSince1970];
+            [formatter release];
+         }
+         success = YES;
+         proceed = YES;
+      }
+      dispatch_semaphore_signal(sem);
+   }] resume];
+
+   Status(_("Connecting to %s"), Get.Host.c_str());
+   dispatch_semaphore_wait(sem, dispatch_time(DISPATCH_TIME_NOW, TimeOut * NSEC_PER_SEC));
+
+   // Get the files information
+   if (!proceed)
+   {
+      return success;
+   }
+
+   // See if it is an IMS hit
+   if (Itm->LastModified == FailTime) {
+      Res.Size = 0;
+      Res.IMSHit = true;
+      URIDone(Res);
+      return true;
+   }
+
+   // See if the file exists
+   struct stat Buf;
+   if (stat(Itm->DestFile.c_str(),&Buf) == 0) {
+      if (Res.Size == (unsigned long long)Buf.st_size && FailTime == Buf.st_mtime) {
+         Res.Size = Buf.st_size;
+         Res.LastModified = Buf.st_mtime;
+         Res.ResumePoint = Buf.st_size;
+         URIDone(Res);
+         return true;
+      }
+
+      // Resume?
+      if (FailTime == Buf.st_mtime && Res.Size > (unsigned long long)Buf.st_size)
+         Res.ResumePoint = Buf.st_size;
+   }
+
+   // Open the file
+   Hashes Hash(Itm->ExpectedHashes);
+   {
+      [request setHTTPMethod:@"GET"];
+
+      NSURLSessionDownloadTask *task = [[NSURLSession sharedSession] downloadTaskWithRequest:request completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error){
+         NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
+         if (httpResponse.statusCode == 200 && !error){
+            NSString *destFile = [NSString stringWithUTF8String:Itm->DestFile.c_str()];
+            [[NSFileManager defaultManager] removeItemAtPath:destFile error:nil];
+            success = [[NSFileManager defaultManager] moveItemAtPath:location.path toPath:destFile error:&error];
+            if (error){
+               success = NO;
+            }
+         }
+         dispatch_semaphore_signal(sem);
+      }];
+      [task resume];
+      dispatch_semaphore_wait(sem, dispatch_time(DISPATCH_TIME_NOW, TimeOut * NSEC_PER_SEC));
+
+      if (!success){
+         Fail();
+         return true;
+      }
+
+      FileFd Fd(Itm->DestFile,FileFd::WriteExists);
+      Hash.AddFD(Fd,Hashes::UntilEOF);
+
+      URIStart(Res);
+
+      Res.Size = Fd.Size();
+      struct timeval times[2];
+      times[0].tv_sec = FailTime;
+      times[1].tv_sec = FailTime;
+      times[0].tv_usec = times[1].tv_usec = 0;
+      utimes(Fd.Name().c_str(), times);
+   }
+
+   Res.LastModified = FailTime;
+   Res.TakeHashes(Hash);
+
+   URIDone(Res);
+
+   return true;
+}
+									/*}}}*/
+
+int main(int, const char *argv[])
+{
+   return HttpMethod(flNotDir(argv[0])).Run();
+}
