From 4cbb9537758ce332759b985c3d5e528360318e45 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Thu, 24 Sep 2020 05:56:48 -0700
Subject: [PATCH 01/94] Import JDK-8253015 v1: Aarch64: Move linux code out
 from generic CPU feature detection

---
 .../cpu/aarch64/macroAssembler_aarch64.cpp    |   2 +-
 .../cpu/aarch64/vm_version_aarch64.cpp        | 206 +++---------------
 .../cpu/aarch64/vm_version_aarch64.hpp        |  53 ++---
 .../vm_version_linux_aarch64.cpp              | 137 ++++++++++++
 src/hotspot/share/jvmci/vmStructs_jvmci.cpp   |   2 +-
 .../aarch64/AArch64HotSpotLIRGenerator.java   |  24 +-
 .../hotspot/GraalHotSpotVMConfig.java         |   4 +-
 7 files changed, 219 insertions(+), 209 deletions(-)

diff --git a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
index 80953cbb20f..ee9c321c00c 100644
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
@@ -5271,7 +5271,7 @@ void MacroAssembler::cache_wb(Address line) {
   assert(line.offset() == 0, "offset should be 0");
   // would like to assert this
   // assert(line._ext.shift == 0, "shift should be zero");
-  if (VM_Version::supports_dcpop()) {
+  if (VM_Version::features() & VM_Version::CPU_DCPOP) {
     // writeback using clear virtual address to point of persistence
     dc(Assembler::CVAP, line.base());
   } else {
diff --git a/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp b/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
index 3cbf025b0c7..3c2efdaf2be 100644
--- a/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
@@ -24,123 +24,35 @@
  */
 
 #include "precompiled.hpp"
-#include "asm/macroAssembler.hpp"
-#include "asm/macroAssembler.inline.hpp"
-#include "memory/resourceArea.hpp"
 #include "runtime/arguments.hpp"
 #include "runtime/java.hpp"
 #include "runtime/os.hpp"
-#include "runtime/stubCodeGenerator.hpp"
 #include "runtime/vm_version.hpp"
 #include "utilities/formatBuffer.hpp"
 #include "utilities/macros.hpp"
 
 #include OS_HEADER_INLINE(os)
 
-#include <asm/hwcap.h>
-#include <sys/auxv.h>
-#include <sys/prctl.h>
-
-#ifndef HWCAP_AES
-#define HWCAP_AES   (1<<3)
-#endif
-
-#ifndef HWCAP_PMULL
-#define HWCAP_PMULL (1<<4)
-#endif
-
-#ifndef HWCAP_SHA1
-#define HWCAP_SHA1  (1<<5)
-#endif
-
-#ifndef HWCAP_SHA2
-#define HWCAP_SHA2  (1<<6)
-#endif
-
-#ifndef HWCAP_CRC32
-#define HWCAP_CRC32 (1<<7)
-#endif
-
-#ifndef HWCAP_ATOMICS
-#define HWCAP_ATOMICS (1<<8)
-#endif
-
-#ifndef HWCAP_SHA512
-#define HWCAP_SHA512 (1 << 21)
-#endif
-
-#ifndef HWCAP_SVE
-#define HWCAP_SVE (1 << 22)
-#endif
-
-#ifndef HWCAP2_SVE2
-#define HWCAP2_SVE2 (1 << 1)
-#endif
-
-#ifndef PR_SVE_GET_VL
-// For old toolchains which do not have SVE related macros defined.
-#define PR_SVE_SET_VL   50
-#define PR_SVE_GET_VL   51
-#endif
-
 int VM_Version::_cpu;
 int VM_Version::_model;
 int VM_Version::_model2;
 int VM_Version::_variant;
 int VM_Version::_revision;
 int VM_Version::_stepping;
-bool VM_Version::_dcpop;
-int VM_Version::_initial_sve_vector_length;
-VM_Version::PsrInfo VM_Version::_psr_info   = { 0, };
-
-static BufferBlob* stub_blob;
-static const int stub_size = 550;
-
-extern "C" {
-  typedef void (*getPsrInfo_stub_t)(void*);
-}
-static getPsrInfo_stub_t getPsrInfo_stub = NULL;
-
-
-class VM_Version_StubGenerator: public StubCodeGenerator {
- public:
 
-  VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}
-
-  address generate_getPsrInfo() {
-    StubCodeMark mark(this, "VM_Version", "getPsrInfo_stub");
-#   define __ _masm->
-    address start = __ pc();
-
-    // void getPsrInfo(VM_Version::PsrInfo* psr_info);
-
-    address entry = __ pc();
-
-    __ enter();
-
-    __ get_dczid_el0(rscratch1);
-    __ strw(rscratch1, Address(c_rarg0, in_bytes(VM_Version::dczid_el0_offset())));
-
-    __ get_ctr_el0(rscratch1);
-    __ strw(rscratch1, Address(c_rarg0, in_bytes(VM_Version::ctr_el0_offset())));
-
-    __ leave();
-    __ ret(lr);
-
-#   undef __
-
-    return start;
-  }
-};
+int VM_Version::_zva_length;
+int VM_Version::_dcache_line_size;
+int VM_Version::_icache_line_size;
+int VM_Version::_initial_sve_vector_length;
 
-void VM_Version::get_processor_features() {
+void VM_Version::initialize() {
   _supports_cx8 = true;
   _supports_atomic_getset4 = true;
   _supports_atomic_getadd4 = true;
   _supports_atomic_getset8 = true;
   _supports_atomic_getadd8 = true;
 
-  getPsrInfo_stub(&_psr_info);
+  get_os_cpu_info();
 
   int dcache_line = VM_Version::dcache_line_size();
 
@@ -182,45 +94,12 @@ void VM_Version::get_processor_features() {
     SoftwarePrefetchHintDistance &= ~7;
   }
 
-  uint64_t auxv = getauxval(AT_HWCAP);
-  uint64_t auxv2 = getauxval(AT_HWCAP2);
-
-  char buf[512];
-
-  _features = auxv;
-
-  int cpu_lines = 0;
-  if (FILE *f = fopen("/proc/cpuinfo", "r")) {
-    // need a large buffer as the flags line may include lots of text
-    char buf[1024], *p;
-    while (fgets(buf, sizeof (buf), f) != NULL) {
-      if ((p = strchr(buf, ':')) != NULL) {
-        long v = strtol(p+1, NULL, 0);
-        if (strncmp(buf, "CPU implementer", sizeof "CPU implementer" - 1) == 0) {
-          _cpu = v;
-          cpu_lines++;
-        } else if (strncmp(buf, "CPU variant", sizeof "CPU variant" - 1) == 0) {
-          _variant = v;
-        } else if (strncmp(buf, "CPU part", sizeof "CPU part" - 1) == 0) {
-          if (_model != v)  _model2 = _model;
-          _model = v;
-        } else if (strncmp(buf, "CPU revision", sizeof "CPU revision" - 1) == 0) {
-          _revision = v;
-        } else if (strncmp(buf, "flags", sizeof("flags") - 1) == 0) {
-          if (strstr(p+1, "dcpop")) {
-            _dcpop = true;
-          }
-        }
-      }
-    }
-    fclose(f);
-  }
 
   if (os::supports_map_sync()) {
     // if dcpop is available publish data cache line flush size via
     // generic field, otherwise let if default to zero thereby
     // disabling writeback
-    if (_dcpop) {
+    if (_features & CPU_DCPOP) {
       _data_cache_line_flush_size = dcache_line;
     }
   }
@@ -301,30 +180,31 @@ void VM_Version::get_processor_features() {
   }
 
   if (_cpu == CPU_ARM && (_model == 0xd07 || _model2 == 0xd07)) _features |= CPU_STXR_PREFETCH;
-  // If an olde style /proc/cpuinfo (cpu_lines == 1) then if _model is an A57 (0xd07)
+  // If an olde style /proc/cpuinfo (cores == 1) then if _model is an A57 (0xd07)
   // we assume the worst and assume we could be on a big little system and have
   // undisclosed A53 cores which we could be swapped to at any stage
-  if (_cpu == CPU_ARM && cpu_lines == 1 && _model == 0xd07) _features |= CPU_A53MAC;
+  if (_cpu == CPU_ARM && os::processor_count() == 1 && _model == 0xd07) _features |= CPU_A53MAC;
 
+  char buf[512];
   sprintf(buf, "0x%02x:0x%x:0x%03x:%d", _cpu, _variant, _model, _revision);
   if (_model2) sprintf(buf+strlen(buf), "(0x%03x)", _model2);
-  if (auxv & HWCAP_ASIMD) strcat(buf, ", simd");
-  if (auxv & HWCAP_CRC32) strcat(buf, ", crc");
-  if (auxv & HWCAP_AES)   strcat(buf, ", aes");
-  if (auxv & HWCAP_SHA1)  strcat(buf, ", sha1");
-  if (auxv & HWCAP_SHA2)  strcat(buf, ", sha256");
-  if (auxv & HWCAP_SHA512) strcat(buf, ", sha512");
-  if (auxv & HWCAP_ATOMICS) strcat(buf, ", lse");
-  if (auxv & HWCAP_SVE) strcat(buf, ", sve");
-  if (auxv2 & HWCAP2_SVE2) strcat(buf, ", sve2");
+  if (_features & CPU_ASIMD) strcat(buf, ", simd");
+  if (_features & CPU_CRC32) strcat(buf, ", crc");
+  if (_features & CPU_AES)   strcat(buf, ", aes");
+  if (_features & CPU_SHA1)  strcat(buf, ", sha1");
+  if (_features & CPU_SHA2)  strcat(buf, ", sha256");
+  if (_features & CPU_SHA512) strcat(buf, ", sha512");
+  if (_features & CPU_LSE) strcat(buf, ", lse");
+  if (_features & CPU_SVE) strcat(buf, ", sve");
+  if (_features & CPU_SVE2) strcat(buf, ", sve2");
 
   _features_string = os::strdup(buf);
 
   if (FLAG_IS_DEFAULT(UseCRC32)) {
-    UseCRC32 = (auxv & HWCAP_CRC32) != 0;
+    UseCRC32 = (_features & CPU_CRC32) != 0;
   }
 
-  if (UseCRC32 && (auxv & HWCAP_CRC32) == 0) {
+  if (UseCRC32 && (_features & CPU_CRC32) == 0) {
     warning("UseCRC32 specified, but not supported on this CPU");
     FLAG_SET_DEFAULT(UseCRC32, false);
   }
@@ -338,7 +218,7 @@ void VM_Version::get_processor_features() {
     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
   }
 
-  if (auxv & HWCAP_ATOMICS) {
+  if (_features & CPU_LSE) {
     if (FLAG_IS_DEFAULT(UseLSE))
       FLAG_SET_DEFAULT(UseLSE, true);
   } else {
@@ -348,7 +228,7 @@ void VM_Version::get_processor_features() {
     }
   }
 
-  if (auxv & HWCAP_AES) {
+  if (_features & CPU_AES) {
     UseAES = UseAES || FLAG_IS_DEFAULT(UseAES);
     UseAESIntrinsics =
         UseAESIntrinsics || (UseAES && FLAG_IS_DEFAULT(UseAESIntrinsics));
@@ -376,7 +256,7 @@ void VM_Version::get_processor_features() {
     UseCRC32Intrinsics = true;
   }
 
-  if (auxv & HWCAP_CRC32) {
+  if (_features & CPU_CRC32) {
     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
       FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
     }
@@ -394,7 +274,7 @@ void VM_Version::get_processor_features() {
     FLAG_SET_DEFAULT(UseMD5Intrinsics, false);
   }
 
-  if (auxv & (HWCAP_SHA1 | HWCAP_SHA2)) {
+  if (_features & (CPU_SHA1 | CPU_SHA2)) {
     if (FLAG_IS_DEFAULT(UseSHA)) {
       FLAG_SET_DEFAULT(UseSHA, true);
     }
@@ -403,7 +283,7 @@ void VM_Version::get_processor_features() {
     FLAG_SET_DEFAULT(UseSHA, false);
   }
 
-  if (UseSHA && (auxv & HWCAP_SHA1)) {
+  if (UseSHA && (_features & CPU_SHA1)) {
     if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {
       FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);
     }
@@ -412,7 +292,7 @@ void VM_Version::get_processor_features() {
     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
   }
 
-  if (UseSHA && (auxv & HWCAP_SHA2)) {
+  if (UseSHA && (_features & CPU_SHA2)) {
     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
     }
@@ -421,7 +301,7 @@ void VM_Version::get_processor_features() {
     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
   }
 
-  if (UseSHA && (auxv & HWCAP_SHA512)) {
+  if (UseSHA && (_features & CPU_SHA512)) {
     // Do not auto-enable UseSHA512Intrinsics until it has been fully tested on hardware
     // if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
       // FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
@@ -435,7 +315,7 @@ void VM_Version::get_processor_features() {
     FLAG_SET_DEFAULT(UseSHA, false);
   }
 
-  if (auxv & HWCAP_PMULL) {
+  if (_features & CPU_PMULL) {
     if (FLAG_IS_DEFAULT(UseGHASHIntrinsics)) {
       FLAG_SET_DEFAULT(UseGHASHIntrinsics, true);
     }
@@ -456,12 +336,12 @@ void VM_Version::get_processor_features() {
     FLAG_SET_DEFAULT(UseBlockZeroing, false);
   }
 
-  if (auxv & HWCAP_SVE) {
+  if (_features & CPU_SVE) {
     if (FLAG_IS_DEFAULT(UseSVE)) {
-      FLAG_SET_DEFAULT(UseSVE, (auxv2 & HWCAP2_SVE2) ? 2 : 1);
+      FLAG_SET_DEFAULT(UseSVE, (_features & CPU_SVE2) ? 2 : 1);
     }
     if (UseSVE > 0) {
-      _initial_sve_vector_length = prctl(PR_SVE_GET_VL);
+      _initial_sve_vector_length = get_current_sve_vector_length();
     }
   } else if (UseSVE > 0) {
     warning("UseSVE specified, but not supported on current CPU. Disabling SVE.");
@@ -509,11 +389,9 @@ void VM_Version::get_processor_features() {
       warning("SVE does not support vector length less than 16 bytes. Disabling SVE.");
       UseSVE = 0;
     } else if ((MaxVectorSize % 16) == 0 && is_power_of_2(MaxVectorSize)) {
-      int new_vl = prctl(PR_SVE_SET_VL, MaxVectorSize);
+      int new_vl = set_and_get_current_sve_vector_lenght(MaxVectorSize);
       _initial_sve_vector_length = new_vl;
-      // If MaxVectorSize is larger than system largest supported SVE vector length, above prctl()
-      // call will set task vector length to the system largest supported value. So, we also update
-      // MaxVectorSize to that largest supported value.
+      // Update MaxVectorSize to the largest supported value.
       if (new_vl < 0) {
         vm_exit_during_initialization(
           err_msg("Current system does not support SVE vector length for MaxVectorSize: %d",
@@ -554,22 +432,6 @@ void VM_Version::get_processor_features() {
     AlignVector = AvoidUnalignedAccesses;
   }
 #endif
-}
-
-void VM_Version::initialize() {
-  ResourceMark rm;
-
-  stub_blob = BufferBlob::create("getPsrInfo_stub", stub_size);
-  if (stub_blob == NULL) {
-    vm_exit_during_initialization("Unable to allocate getPsrInfo_stub");
-  }
-
-  CodeBuffer c(stub_blob);
-  VM_Version_StubGenerator g(&c);
-  getPsrInfo_stub = CAST_TO_FN_PTR(getPsrInfo_stub_t,
-                                   g.generate_getPsrInfo());
-
-  get_processor_features();
 
   UNSUPPORTED_OPTION(CriticalJNINatives);
 }
diff --git a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
index 9870b24ecb5..b8fa7b27796 100644
--- a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
@@ -40,15 +40,20 @@ class VM_Version : public Abstract_VM_Version {
   static int _variant;
   static int _revision;
   static int _stepping;
-  static bool _dcpop;
+
+  static int _zva_length;
+  static int _dcache_line_size;
+  static int _icache_line_size;
   static int _initial_sve_vector_length;
 
-  struct PsrInfo {
-    uint32_t dczid_el0;
-    uint32_t ctr_el0;
-  };
-  static PsrInfo _psr_info;
-  static void get_processor_features();
+  // Read additional info using OS-specific interfaces
+  static void get_os_cpu_info();
+
+  // Sets the SVE length and returns a new actual value or negative on error.
+  // If the len is larger than the system largest supported SVE vector length,
+  // the function sets the largest supported value.
+  static int set_and_get_current_sve_vector_lenght(int len);
+  static int get_current_sve_vector_length();
 
 public:
   // Initialization
@@ -98,8 +103,13 @@ class VM_Version : public Abstract_VM_Version {
     CPU_SHA2         = (1<<6),
     CPU_CRC32        = (1<<7),
     CPU_LSE          = (1<<8),
-    CPU_STXR_PREFETCH= (1 << 29),
-    CPU_A53MAC       = (1 << 30),
+    CPU_DCPOP        = (1<<16),
+    CPU_SHA512       = (1<<21),
+    CPU_SVE          = (1<<22),
+    // flags above must follow Linux HWCAP
+    CPU_SVE2         = (1<<28),
+    CPU_STXR_PREFETCH= (1<<29),
+    CPU_A53MAC       = (1<<30),
   };
 
   static int cpu_family()                     { return _cpu; }
@@ -107,26 +117,17 @@ class VM_Version : public Abstract_VM_Version {
   static int cpu_model2()                     { return _model2; }
   static int cpu_variant()                    { return _variant; }
   static int cpu_revision()                   { return _revision; }
-  static bool supports_dcpop()                { return _dcpop; }
-  static int get_initial_sve_vector_length()  { return _initial_sve_vector_length; };
-  static ByteSize dczid_el0_offset() { return byte_offset_of(PsrInfo, dczid_el0); }
-  static ByteSize ctr_el0_offset()   { return byte_offset_of(PsrInfo, ctr_el0); }
-  static bool is_zva_enabled() {
-    // Check the DZP bit (bit 4) of dczid_el0 is zero
-    // and block size (bit 0~3) is not zero.
-    return ((_psr_info.dczid_el0 & 0x10) == 0 &&
-            (_psr_info.dczid_el0 & 0xf) != 0);
-  }
+
+  static bool is_zva_enabled() { return 0 <= _zva_length; }
   static int zva_length() {
     assert(is_zva_enabled(), "ZVA not available");
-    return 4 << (_psr_info.dczid_el0 & 0xf);
-  }
-  static int icache_line_size() {
-    return (1 << (_psr_info.ctr_el0 & 0x0f)) * 4;
-  }
-  static int dcache_line_size() {
-    return (1 << ((_psr_info.ctr_el0 >> 16) & 0x0f)) * 4;
+    return _zva_length;
   }
+
+  static int icache_line_size() { return _icache_line_size; }
+  static int dcache_line_size() { return _dcache_line_size; }
+  static int get_initial_sve_vector_length()  { return _initial_sve_vector_length; };
+
   static bool supports_fast_class_init_checks() { return true; }
 };
 
diff --git a/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp b/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp
index e4ae30c4cff..d5fb3f4680b 100644
--- a/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp
+++ b/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp
@@ -27,3 +27,140 @@
 #include "runtime/os.hpp"
 #include "runtime/vm_version.hpp"
 
+#include <asm/hwcap.h>
+#include <sys/auxv.h>
+#include <sys/prctl.h>
+
+#ifndef HWCAP_AES
+#define HWCAP_AES   (1<<3)
+#endif
+
+#ifndef HWCAP_PMULL
+#define HWCAP_PMULL (1<<4)
+#endif
+
+#ifndef HWCAP_SHA1
+#define HWCAP_SHA1  (1<<5)
+#endif
+
+#ifndef HWCAP_SHA2
+#define HWCAP_SHA2  (1<<6)
+#endif
+
+#ifndef HWCAP_CRC32
+#define HWCAP_CRC32 (1<<7)
+#endif
+
+#ifndef HWCAP_ATOMICS
+#define HWCAP_ATOMICS (1<<8)
+#endif
+
+#ifndef HWCAP_DCPOP
+#define HWCAP_DCPOP (1<<16)
+#endif
+
+#ifndef HWCAP_SHA512
+#define HWCAP_SHA512 (1 << 21)
+#endif
+
+#ifndef HWCAP_SVE
+#define HWCAP_SVE (1 << 22)
+#endif
+
+#ifndef HWCAP2_SVE2
+#define HWCAP2_SVE2 (1 << 1)
+#endif
+
+#ifndef PR_SVE_GET_VL
+// For old toolchains which do not have SVE related macros defined.
+#define PR_SVE_SET_VL   50
+#define PR_SVE_GET_VL   51
+#endif
+
+int VM_Version::get_current_sve_vector_length() {
+  assert(_features & CPU_SVE, "should not call this");
+  return prctl(PR_SVE_GET_VL);
+}
+
+int VM_Version::set_and_get_current_sve_vector_lenght(int length) {
+  assert(_features & CPU_SVE, "should not call this");
+  int new_length = prctl(PR_SVE_SET_VL, length);
+  return new_length;
+}
+
+void VM_Version::get_os_cpu_info() {
+
+  uint64_t auxv = getauxval(AT_HWCAP);
+  uint64_t auxv2 = getauxval(AT_HWCAP2);
+
+  static_assert(CPU_FP      == HWCAP_FP);
+  static_assert(CPU_ASIMD   == HWCAP_ASIMD);
+  static_assert(CPU_EVTSTRM == HWCAP_EVTSTRM);
+  static_assert(CPU_AES     == HWCAP_AES);
+  static_assert(CPU_PMULL   == HWCAP_PMULL);
+  static_assert(CPU_SHA1    == HWCAP_SHA1);
+  static_assert(CPU_SHA2    == HWCAP_SHA2);
+  static_assert(CPU_CRC32   == HWCAP_CRC32);
+  static_assert(CPU_LSE     == HWCAP_ATOMICS);
+  static_assert(CPU_DCPOP   == HWCAP_DCPOP);
+  static_assert(CPU_SHA512  == HWCAP_SHA512);
+  static_assert(CPU_SVE     == HWCAP_SVE);
+  _features = auxv & (
+      HWCAP_FP      |
+      HWCAP_ASIMD   |
+      HWCAP_EVTSTRM |
+      HWCAP_AES     |
+      HWCAP_PMULL   |
+      HWCAP_SHA1    |
+      HWCAP_SHA2    |
+      HWCAP_CRC32   |
+      HWCAP_ATOMICS |
+      HWCAP_DCPOP   |
+      HWCAP_SHA512  |
+      HWCAP_SVE);
+
+  if (auxv2 & HWCAP2_SVE2) _features |= CPU_SVE2;
+
+  uint64_t ctr_el0;
+  uint64_t dczid_el0;
+  __asm__ (
+    "mrs %0, CTR_EL0\n"
+    "mrs %1, DCZID_EL0\n"
+    : "=r"(ctr_el0), "=r"(dczid_el0)
+  );
+
+  _icache_line_size = (1 << (ctr_el0 & 0x0f)) * 4;
+  _dcache_line_size = (1 << ((ctr_el0 >> 16) & 0x0f)) * 4;
+
+  if (!(dczid_el0 & 0x10)) {
+    _zva_length = 4 << (dczid_el0 & 0xf);
+  }
+
+  int cpu_lines = 0;
+  if (FILE *f = fopen("/proc/cpuinfo", "r")) {
+    // need a large buffer as the flags line may include lots of text
+    char buf[1024], *p;
+    while (fgets(buf, sizeof (buf), f) != NULL) {
+      if ((p = strchr(buf, ':')) != NULL) {
+        long v = strtol(p+1, NULL, 0);
+        if (strncmp(buf, "CPU implementer", sizeof "CPU implementer" - 1) == 0) {
+          _cpu = v;
+          cpu_lines++;
+        } else if (strncmp(buf, "CPU variant", sizeof "CPU variant" - 1) == 0) {
+          _variant = v;
+        } else if (strncmp(buf, "CPU part", sizeof "CPU part" - 1) == 0) {
+          if (_model != v)  _model2 = _model;
+          _model = v;
+        } else if (strncmp(buf, "CPU revision", sizeof "CPU revision" - 1) == 0) {
+          _revision = v;
+        } else if (strncmp(buf, "flags", sizeof("flags") - 1) == 0) {
+          if (strstr(p+1, "dcpop")) {
+            guarantee(_features & CPU_DCPOP, "dcpop availability should be consistent");
+          }
+        }
+      }
+    }
+    fclose(f);
+  }
+  guarantee(cpu_lines == os::processor_count(), "core count should be consistent");
+}
diff --git a/src/hotspot/share/jvmci/vmStructs_jvmci.cpp b/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
index 3a4b776d0a1..9edc530d802 100644
--- a/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
+++ b/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
@@ -724,7 +724,7 @@
 #ifdef AARCH64
 
 #define VM_STRUCTS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \
-  static_field(VM_Version, _psr_info.dczid_el0, uint32_t)               \
+  static_field(VM_Version, _zva_length, int)                            \
   volatile_nonstatic_field(JavaFrameAnchor, _last_Java_fp, intptr_t*)
 
 #define VM_INT_CONSTANTS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant) \
diff --git a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotLIRGenerator.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotLIRGenerator.java
index 6f197f47d5e..0139bbc4124 100644
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotLIRGenerator.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotLIRGenerator.java
@@ -551,14 +551,22 @@ public LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConsta
 
     @Override
     public void emitZeroMemory(Value address, Value length, boolean isAligned) {
-        int dczidValue = config.psrInfoDczidValue;
-        EnumSet<AArch64.Flag> flags = ((AArch64) target().arch).getFlags();
-
-        // ARMv8-A architecture reference manual D12.2.35 Data Cache Zero ID register says:
-        // * BS, bits [3:0] indicate log2 of the DC ZVA block size in (4-byte) words.
-        // * DZP, bit [4] of indicates whether use of DC ZVA instruction is prohibited.
-        int zvaLength = 4 << (dczidValue & 0xF);
-        boolean isDcZvaProhibited = ((dczidValue & 0x10) != 0);
+        final EnumSet<AArch64.Flag> flags = ((AArch64) target().arch).getFlags();
+
+        boolean isDcZvaProhibited = true;
+        int zvaLength = 0;
+        if (GraalHotSpotVMConfig.JDK >= 16) {
+            zvaLength = config.zvaLength;
+            isDcZvaProhibited = 0 == config.zvaLength;
+        } else {
+            int dczidValue = config.psrInfoDczidValue;
+
+            // ARMv8-A architecture reference manual D12.2.35 Data Cache Zero ID register says:
+            // * BS, bits [3:0] indicate log2 of the DC ZVA block size in (4-byte) words.
+            // * DZP, bit [4] of indicates whether use of DC ZVA instruction is prohibited.
+            zvaLength = 4 << (dczidValue & 0xF);
+            isDcZvaProhibited = ((dczidValue & 0x10) != 0);
+        }
 
         // Use DC ZVA if it's not prohibited and AArch64 HotSpot flag UseBlockZeroing is on.
         boolean useDcZva = !isDcZvaProhibited && flags.contains(AArch64.Flag.UseBlockZeroing);
diff --git a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java
index 000a0043ee9..55288743b61 100644
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java
@@ -719,7 +719,9 @@ public int threadTlabPfTopOffset() {
     // ARMv8-A architecture reference manual D12.2.35 Data Cache Zero ID register says:
     // * BS, bits [3:0] indicate log2 of the DC ZVA block size in (4-byte) words.
     // * DZP, bit [4] of indicates whether use of DC ZVA instruction is prohibited.
-    public final int psrInfoDczidValue = getFieldValue("VM_Version::_psr_info.dczid_el0", Integer.class, "uint32_t", 0x10, (JVMCI ? jvmciGE(JVMCI_19_3_b04) : JDK >= 14) && osArch.equals("aarch64"));
+    public final int psrInfoDczidValue = getFieldValue("VM_Version::_psr_info.dczid_el0", Integer.class, "uint32_t", 0x10, (JVMCI ? jvmciGE(JVMCI_19_3_b04) : (JDK == 14 || JDK == 15)) && osArch.equals("aarch64"));
+
+    public final int zvaLength = getFieldValue("VM_Version::_zva_length", Integer.class, "int", 0, JDK >= 16 && osArch.equals("aarch64"));
 
     // FIXME This is only temporary until the GC code is changed.
     public final boolean inlineContiguousAllocationSupported = getFieldValue("CompilerToVM::Data::_supports_inline_contig_alloc", Boolean.class);

From 3b98dba67bbed82ed74e40523efdef996a4d9c7b Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@openjdk.org>
Date: Thu, 20 Aug 2020 04:55:36 -0700
Subject: [PATCH 02/94] JDK-8248500: AArch64: Remove the r18 dependency on
 Windows AArch64

ZULU-17387
---
 src/hotspot/cpu/aarch64/aarch64.ad            |  8 ++
 src/hotspot/cpu/aarch64/c1_Defs_aarch64.hpp   | 12 +--
 .../cpu/aarch64/c1_FrameMap_aarch64.cpp       |  8 ++
 .../cpu/aarch64/macroAssembler_aarch64.cpp    |  6 +-
 .../aarch64/macroAssembler_aarch64_trig.cpp   |  2 +-
 .../cpu/aarch64/stubGenerator_aarch64.cpp     | 89 ++++++++++---------
 6 files changed, 75 insertions(+), 50 deletions(-)

diff --git a/src/hotspot/cpu/aarch64/aarch64.ad b/src/hotspot/cpu/aarch64/aarch64.ad
index 5970a898bf2..5bc4e9b7299 100644
--- a/src/hotspot/cpu/aarch64/aarch64.ad
+++ b/src/hotspot/cpu/aarch64/aarch64.ad
@@ -716,6 +716,11 @@ reg_class any_reg %{
 
 // Class for non-allocatable 32 bit registers
 reg_class non_allocatable_reg32(
+#ifdef __APPLE__
+    //On macOS-aarch64, the register x18 is reserved for the platform.
+    //Conforming software should not make use of it
+    R18,
+#endif
     R28,                        // thread
     R30,                        // lr
     R31                         // sp
@@ -723,6 +728,9 @@ reg_class non_allocatable_reg32(
 
 // Class for non-allocatable 64 bit registers
 reg_class non_allocatable_reg(
+#ifdef __APPLE__
+    R18, R18_H
+#endif
     R28, R28_H,                 // thread
     R30, R30_H,                 // lr
     R31, R31_H                  // sp
diff --git a/src/hotspot/cpu/aarch64/c1_Defs_aarch64.hpp b/src/hotspot/cpu/aarch64/c1_Defs_aarch64.hpp
index fae09ac1a8d..bc7314b41c2 100644
--- a/src/hotspot/cpu/aarch64/c1_Defs_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/c1_Defs_aarch64.hpp
@@ -44,13 +44,13 @@ enum {
   pd_nof_cpu_regs_frame_map = RegisterImpl::number_of_registers,       // number of registers used during code emission
   pd_nof_fpu_regs_frame_map = FloatRegisterImpl::number_of_registers,  // number of registers used during code emission
 
-  pd_nof_caller_save_cpu_regs_frame_map = 19 - 2,  // number of registers killed by calls
+  pd_nof_caller_save_cpu_regs_frame_map = 19 - 2 BSD_ONLY(- 1 /* r18 */),  // number of registers killed by calls
   pd_nof_caller_save_fpu_regs_frame_map = 32,  // number of registers killed by calls
 
-  pd_first_callee_saved_reg = 19 - 2,
-  pd_last_callee_saved_reg = 26 - 2,
+  pd_first_callee_saved_reg = 19 - 2 BSD_ONLY(- 1 /* r18 */),
+  pd_last_callee_saved_reg = 26 - 2 BSD_ONLY(- 1 /* r18 */),
 
-  pd_last_allocatable_cpu_reg = 16,
+  pd_last_allocatable_cpu_reg = 16 BSD_ONLY(- 1 /* r18 */),
 
   pd_nof_cpu_regs_reg_alloc
     = pd_last_allocatable_cpu_reg + 1,  // number of registers that are visible to register allocator
@@ -60,9 +60,9 @@ enum {
   pd_nof_fpu_regs_linearscan = pd_nof_fpu_regs_frame_map, // number of registers visible to linear scan
   pd_nof_xmm_regs_linearscan = 0,  // don't have vector registers
   pd_first_cpu_reg = 0,
-  pd_last_cpu_reg = 16,
+  pd_last_cpu_reg = 16 BSD_ONLY(- 1 /* r18 */),
   pd_first_byte_reg = 0,
-  pd_last_byte_reg = 16,
+  pd_last_byte_reg = 16 BSD_ONLY(- 1 /* r18 */),
   pd_first_fpu_reg = pd_nof_cpu_regs_frame_map,
   pd_last_fpu_reg =  pd_first_fpu_reg + 31,
 
diff --git a/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp b/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp
index 4257e3445ea..8216901df30 100644
--- a/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp
@@ -181,7 +181,9 @@ void FrameMap::initialize() {
   map_register(i, r15); r15_opr = LIR_OprFact::single_cpu(i); i++;
   map_register(i, r16); r16_opr = LIR_OprFact::single_cpu(i); i++;
   map_register(i, r17); r17_opr = LIR_OprFact::single_cpu(i); i++;
+#ifndef __APPLE__
   map_register(i, r18); r18_opr = LIR_OprFact::single_cpu(i); i++;
+#endif
   map_register(i, r19); r19_opr = LIR_OprFact::single_cpu(i); i++;
   map_register(i, r20); r20_opr = LIR_OprFact::single_cpu(i); i++;
   map_register(i, r21); r21_opr = LIR_OprFact::single_cpu(i); i++;
@@ -199,6 +201,10 @@ void FrameMap::initialize() {
   map_register(i, r8); r8_opr = LIR_OprFact::single_cpu(i); i++;   // rscratch1
   map_register(i, r9); r9_opr = LIR_OprFact::single_cpu(i); i++;   // rscratch2
 
+#ifdef __APPLE__
+  map_register(i, r18); r18_opr = LIR_OprFact::single_cpu(i); i++;   // rscratch2
+#endif
+
   rscratch1_opr = r8_opr;
   rscratch2_opr = r9_opr;
   rscratch1_long_opr = LIR_OprFact::double_cpu(r8_opr->cpu_regnr(), r8_opr->cpu_regnr());
@@ -227,7 +233,9 @@ void FrameMap::initialize() {
   _caller_save_cpu_regs[13] = r15_opr;
   _caller_save_cpu_regs[14] = r16_opr;
   _caller_save_cpu_regs[15] = r17_opr;
+#ifndef __APPLE__
   _caller_save_cpu_regs[16] = r18_opr;
+#endif
 
   for (int i = 0; i < 8; i++) {
     _caller_save_fpu_regs[i] = LIR_OprFact::single_fpu(i);
diff --git a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
index ee9c321c00c..4758eec6448 100644
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
@@ -2658,7 +2658,7 @@ void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[])
 
 void MacroAssembler::push_call_clobbered_registers_except(RegSet exclude) {
   int step = 4 * wordSize;
-  push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) - exclude, sp);
+  push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) BSD_ONLY(- r18) - exclude, sp);
   sub(sp, sp, step);
   mov(rscratch1, -step);
   // Push v0-v7, v16-v31.
@@ -2678,7 +2678,7 @@ void MacroAssembler::pop_call_clobbered_registers_except(RegSet exclude) {
           as_FloatRegister(i+3), T1D, Address(post(sp, 4 * wordSize)));
   }
 
-  pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) - exclude, sp);
+  pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) BSD_ONLY(- r18) - exclude, sp);
 }
 
 void MacroAssembler::push_CPU_state(bool save_vectors, bool use_sve,
@@ -5253,7 +5253,7 @@ void MacroAssembler::char_array_compress(Register src, Register dst, Register le
 // aarch64_get_thread_helper() clobbers only r0, r1, and flags.
 //
 void MacroAssembler::get_thread(Register dst) {
-  RegSet saved_regs = RegSet::range(r0, r1) + lr - dst;
+  RegSet saved_regs = RegSet::range(r0, r1) + BSD_ONLY(RegSet::range(r2, r17)) + lr - dst;
   push(saved_regs, sp);
 
   mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));
diff --git a/src/hotspot/cpu/aarch64/macroAssembler_aarch64_trig.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64_trig.cpp
index 46473ac39d9..83ad824db55 100644
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64_trig.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64_trig.cpp
@@ -689,7 +689,7 @@ void MacroAssembler::generate__kernel_rem_pio2(address two_over_pi, address pio2
       RECOMP_FOR1_CHECK;
   Register tmp2 = r1, n = r2, jv = r4, tmp5 = r5, jx = r6,
       tmp3 = r7, iqBase = r10, ih = r11, tmp4 = r12, tmp1 = r13,
-      jz = r14, j = r15, twoOverPiBase = r16, i = r17, qBase = r18;
+      jz = r14, j = r15, twoOverPiBase = r16, i = r17, qBase = r20;
     // jp = jk == init_jk[prec] = init_jk[2] == {2,3,4,6}[2] == 4
     // jx = nx - 1
     lea(twoOverPiBase, ExternalAddress(two_over_pi));
diff --git a/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp b/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
index e5d02756a82..3c302a20ef4 100644
--- a/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
@@ -1092,7 +1092,7 @@ class StubGenerator: public StubCodeGenerator {
     Label copy4, copy8, copy16, copy32, copy80, copy_big, finish;
     const Register t2 = r5, t3 = r6, t4 = r7, t5 = r8;
     const Register t6 = r9, t7 = r10, t8 = r11, t9 = r12;
-    const Register send = r17, dend = r18;
+    const Register send = r17, dend = r16;
 
     if (PrefetchCopyIntervalInBytes > 0)
       __ prfm(Address(s, 0), PLDL1KEEP);
@@ -1284,7 +1284,7 @@ class StubGenerator: public StubCodeGenerator {
 #ifdef ASSERT
     __ mov(rscratch1, (uint64_t)0xdeadbeef);
     __ orr(rscratch1, rscratch1, rscratch1, Assembler::LSL, 32);
-    for (Register r = r3; r <= r18; r++)
+    for (Register r = r3; r <= NOT_BSD(r18) BSD_ONLY(r17); r++)
       if (r != rscratch1) __ mov(r, rscratch1);
 #endif
   }
@@ -1719,10 +1719,10 @@ class StubGenerator: public StubCodeGenerator {
     RegSet wb_pre_saved_regs = RegSet::range(c_rarg0, c_rarg4);
     RegSet wb_post_saved_regs = RegSet::of(count);
 
-    // Registers used as temps (r18, r19, r20 are save-on-entry)
+    // Registers used as temps (r19, r20, r21, r22 are save-on-entry)
+    const Register copied_oop  = r22;       // actual oop copied
     const Register count_save  = r21;       // orig elementscount
     const Register start_to    = r20;       // destination array start address
-    const Register copied_oop  = r18;       // actual oop copied
     const Register r19_klass   = r19;       // oop._klass
 
     //---------------------------------------------------------------
@@ -1760,7 +1760,7 @@ class StubGenerator: public StubCodeGenerator {
      // Empty array:  Nothing to do.
     __ cbz(count, L_done);
 
-    __ push(RegSet::of(r18, r19, r20, r21), sp);
+    __ push(RegSet::of(r19, r20, r21, r22), sp);
 
 #ifdef ASSERT
     BLOCK_COMMENT("assert consistent ckoff/ckval");
@@ -1829,7 +1829,7 @@ class StubGenerator: public StubCodeGenerator {
     bs->arraycopy_epilogue(_masm, decorators, is_oop, start_to, count_save, rscratch1, wb_post_saved_regs);
 
     __ bind(L_done_pop);
-    __ pop(RegSet::of(r18, r19, r20, r21), sp);
+    __ pop(RegSet::of(r19, r20, r21, r22), sp);
     inc_counter_np(SharedRuntime::_checkcast_array_copy_ctr);
 
     __ bind(L_done);
@@ -2006,7 +2006,7 @@ class StubGenerator: public StubCodeGenerator {
     // registers used as temp
     const Register scratch_length    = r16; // elements count to copy
     const Register scratch_src_klass = r17; // array klass
-    const Register lh                = r18; // layout helper
+    const Register lh                = r15; // layout helper
 
     //  if (length < 0) return -1;
     __ movw(scratch_length, length);        // length (elements count, 32-bits value)
@@ -2077,7 +2077,7 @@ class StubGenerator: public StubCodeGenerator {
     //
 
     const Register rscratch1_offset = rscratch1;    // array offset
-    const Register r18_elsize = lh; // element size
+    const Register r15_elsize = lh; // element size
 
     __ ubfx(rscratch1_offset, lh, Klass::_lh_header_size_shift,
            exact_log2(Klass::_lh_header_size_mask+1));   // array_offset
@@ -2098,8 +2098,8 @@ class StubGenerator: public StubCodeGenerator {
     // The possible values of elsize are 0-3, i.e. exact_log2(element
     // size in bytes).  We do a simple bitwise binary search.
   __ BIND(L_copy_bytes);
-    __ tbnz(r18_elsize, 1, L_copy_ints);
-    __ tbnz(r18_elsize, 0, L_copy_shorts);
+    __ tbnz(r15_elsize, 1, L_copy_ints);
+    __ tbnz(r15_elsize, 0, L_copy_shorts);
     __ lea(from, Address(src, src_pos));// src_addr
     __ lea(to,   Address(dst, dst_pos));// dst_addr
     __ movw(count, scratch_length); // length
@@ -2112,7 +2112,7 @@ class StubGenerator: public StubCodeGenerator {
     __ b(RuntimeAddress(short_copy_entry));
 
   __ BIND(L_copy_ints);
-    __ tbnz(r18_elsize, 0, L_copy_longs);
+    __ tbnz(r15_elsize, 0, L_copy_longs);
     __ lea(from, Address(src, src_pos, Address::lsl(2)));// src_addr
     __ lea(to,   Address(dst, dst_pos, Address::lsl(2)));// dst_addr
     __ movw(count, scratch_length); // length
@@ -2123,8 +2123,8 @@ class StubGenerator: public StubCodeGenerator {
     {
       BLOCK_COMMENT("assert long copy {");
       Label L;
-      __ andw(lh, lh, Klass::_lh_log2_element_size_mask); // lh -> r18_elsize
-      __ cmpw(r18_elsize, LogBytesPerLong);
+      __ andw(lh, lh, Klass::_lh_log2_element_size_mask); // lh -> r15_elsize
+      __ cmpw(r15_elsize, LogBytesPerLong);
       __ br(Assembler::EQ, L);
       __ stop("must be long copy, but elsize is wrong");
       __ bind(L);
@@ -2142,8 +2142,8 @@ class StubGenerator: public StubCodeGenerator {
 
     Label L_plain_copy, L_checkcast_copy;
     //  test array classes for subtyping
-    __ load_klass(r18, dst);
-    __ cmp(scratch_src_klass, r18); // usual case is exact equality
+    __ load_klass(r15, dst);
+    __ cmp(scratch_src_klass, r15); // usual case is exact equality
     __ br(Assembler::NE, L_checkcast_copy);
 
     // Identically typed arrays can be copied without element-wise checks.
@@ -2159,17 +2159,17 @@ class StubGenerator: public StubCodeGenerator {
     __ b(RuntimeAddress(oop_copy_entry));
 
   __ BIND(L_checkcast_copy);
-    // live at this point:  scratch_src_klass, scratch_length, r18 (dst_klass)
+    // live at this point:  scratch_src_klass, scratch_length, r15 (dst_klass)
     {
       // Before looking at dst.length, make sure dst is also an objArray.
-      __ ldrw(rscratch1, Address(r18, lh_offset));
+      __ ldrw(rscratch1, Address(r15, lh_offset));
       __ movw(rscratch2, objArray_lh);
       __ eorw(rscratch1, rscratch1, rscratch2);
       __ cbnzw(rscratch1, L_failed);
 
       // It is safe to examine both src.length and dst.length.
       arraycopy_range_checks(src, src_pos, dst, dst_pos, scratch_length,
-                             r18, L_failed);
+                             r15, L_failed);
 
       __ load_klass(dst_klass, dst); // reload
 
@@ -5071,40 +5071,49 @@ class StubGenerator: public StubCodeGenerator {
       if (squaring)
         Pb_base = Pa_base;
       else
-        Pb_base = ++reg;
-      Pn_base = ++reg;
-      Rlen= ++reg;
-      inv = ++reg;
-      Pm_base = ++reg;
+        Pb_base = next_reg(reg);
+      Pn_base = next_reg(reg);
+      Rlen= next_reg(reg);
+      inv = next_reg(reg);
+      Pm_base = next_reg(reg);
 
                           // Working registers:
-      Ra =  ++reg;        // The current digit of a, b, n, and m.
-      Rb =  ++reg;
-      Rm =  ++reg;
-      Rn =  ++reg;
+      Ra =  next_reg(reg);        // The current digit of a, b, n, and m.
+      Rb =  next_reg(reg);
+      Rm =  next_reg(reg);
+      Rn =  next_reg(reg);
 
-      Pa =  ++reg;        // Pointers to the current/next digit of a, b, n, and m.
-      Pb =  ++reg;
-      Pm =  ++reg;
-      Pn =  ++reg;
+      Pa =  next_reg(reg);        // Pointers to the current/next digit of a, b, n, and m.
+      Pb =  next_reg(reg);
+      Pm =  next_reg(reg);
+      Pn =  next_reg(reg);
 
-      t0 =  ++reg;        // Three registers which form a
-      t1 =  ++reg;        // triple-precision accumuator.
-      t2 =  ++reg;
+      t0 =  next_reg(reg);        // Three registers which form a
+      t1 =  next_reg(reg);        // triple-precision accumuator.
+      t2 =  next_reg(reg);
 
-      Ri =  ++reg;        // Inner and outer loop indexes.
-      Rj =  ++reg;
+      Ri =  next_reg(reg);        // Inner and outer loop indexes.
+      Rj =  next_reg(reg);
 
-      Rhi_ab = ++reg;     // Product registers: low and high parts
-      Rlo_ab = ++reg;     // of a*b and m*n.
-      Rhi_mn = ++reg;
-      Rlo_mn = ++reg;
+      Rhi_ab = next_reg(reg);     // Product registers: low and high parts
+      Rlo_ab = next_reg(reg);     // of a*b and m*n.
+      Rhi_mn = next_reg(reg);
+      Rlo_mn = next_reg(reg);
 
       // r19 and up are callee-saved.
       _toSave = RegSet::range(r19, reg) + Pm_base;
     }
 
   private:
+    Register next_reg(Register &reg) {
+#ifdef __APPLE__
+      // skip r18 on macOSs, it should not be used
+      return ++reg == r18 ? ++reg : reg;
+#else
+      return ++reg;
+#endif
+    }
+
     void save_regs() {
       push(_toSave, sp);
     }

From 7092a0656924af5bd3fc4ad7c738393c85e1b193 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@openjdk.org>
Date: Tue, 25 Aug 2020 07:12:38 -0700
Subject: [PATCH 03/94] Import JDK-8234930 v1: Use MAP_JIT when allocating
 pages for code cache on macOS

ZULU-17910
http://cr.openjdk.java.net/~akozlov/8234930/webrev.00/
---
 src/hotspot/os/aix/os_aix.cpp                 |  4 +-
 src/hotspot/os/bsd/os_bsd.cpp                 | 38 +++++++++++++++----
 src/hotspot/os/linux/os_linux.cpp             |  7 ++--
 src/hotspot/os/windows/os_windows.cpp         |  6 +--
 .../share/gc/g1/g1PageBasedVirtualSpace.cpp   |  2 +-
 src/hotspot/share/gc/parallel/psCardTable.cpp |  3 +-
 .../share/gc/parallel/psVirtualspace.cpp      |  2 +-
 src/hotspot/share/gc/shared/cardTable.cpp     |  3 +-
 .../share/gc/shenandoah/shenandoahHeap.cpp    |  4 +-
 .../gc/shenandoah/shenandoahHeapRegion.cpp    |  2 +-
 src/hotspot/share/memory/virtualspace.cpp     |  8 ++--
 src/hotspot/share/prims/whitebox.cpp          |  2 +-
 src/hotspot/share/runtime/os.cpp              | 10 ++---
 src/hotspot/share/runtime/os.hpp              | 10 +++--
 src/hotspot/share/runtime/thread.cpp          |  2 +-
 15 files changed, 65 insertions(+), 38 deletions(-)

diff --git a/src/hotspot/os/aix/os_aix.cpp b/src/hotspot/os/aix/os_aix.cpp
index 64face5268a..9d161bc9dab 100644
--- a/src/hotspot/os/aix/os_aix.cpp
+++ b/src/hotspot/os/aix/os_aix.cpp
@@ -2269,7 +2269,7 @@ void os::pd_commit_memory_or_exit(char* addr, size_t size,
   pd_commit_memory_or_exit(addr, size, exec, mesg);
 }
 
-bool os::pd_uncommit_memory(char* addr, size_t size) {
+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
   assert(is_aligned_to(addr, os::vm_page_size()),
     "addr " PTR_FORMAT " not aligned to vm_page_size (" PTR_FORMAT ")",
     p2i(addr), os::vm_page_size());
@@ -2347,7 +2347,7 @@ char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info
 
 // Reserves and attaches a shared memory segment.
 // Will assert if a wish address is given and could not be obtained.
-char* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {
+char* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint, bool executable) {
 
   // All other Unices do a mmap(MAP_FIXED) if the addr is given,
   // thereby clobbering old mappings at that place. That is probably
diff --git a/src/hotspot/os/bsd/os_bsd.cpp b/src/hotspot/os/bsd/os_bsd.cpp
index 943133e27e5..5b049c15d04 100644
--- a/src/hotspot/os/bsd/os_bsd.cpp
+++ b/src/hotspot/os/bsd/os_bsd.cpp
@@ -1907,12 +1907,16 @@ static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
 //       problem.
 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
-#ifdef __OpenBSD__
+#if defined(__OpenBSD__)
   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
   Events::log(NULL, "Protecting memory [" INTPTR_FORMAT "," INTPTR_FORMAT "] with protection modes %x", p2i(addr), p2i(addr+size), prot);
   if (::mprotect(addr, size, prot) == 0) {
     return true;
   }
+#elif defined(__APPLE__)
+  if (::mprotect(addr, size, prot) == 0) {
+    return true;
+  }
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
                                      MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
@@ -1995,11 +1999,22 @@ char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info
 }
 
 
-bool os::pd_uncommit_memory(char* addr, size_t size) {
-#ifdef __OpenBSD__
+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
+#if defined(__OpenBSD__)
   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
   Events::log(NULL, "Protecting memory [" INTPTR_FORMAT "," INTPTR_FORMAT "] with PROT_NONE", p2i(addr), p2i(addr+size));
   return ::mprotect(addr, size, PROT_NONE) == 0;
+#elif defined(__APPLE__)
+  if (exec) {
+    if (::madvise(addr, size, MADV_FREE) != 0) {
+      return false;
+    }
+    return ::mprotect(addr, size, PROT_NONE) == 0;
+  } else {
+    uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
+        MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
+    return res  != (uintptr_t) MAP_FAILED;
+  }
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
@@ -2014,7 +2029,7 @@ bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
 // If this is a growable mapping, remove the guard pages entirely by
 // munmap()ping them.  If not, just call uncommit_memory().
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  return os::uncommit_memory(addr, size);
+  return os::uncommit_memory(addr, size, !ExecMem);
 }
 
 // If 'fixed' is true, anon_mmap() will attempt to reserve anonymous memory
@@ -2023,11 +2038,17 @@ bool os::remove_stack_guard_pages(char* addr, size_t size) {
 // 'requested_addr' is only treated as a hint, the return value may or
 // may not start from the requested address. Unlike Bsd mmap(), this
 // function returns NULL to indicate failure.
-static char* anon_mmap(char* requested_addr, size_t bytes, bool fixed) {
+static char* anon_mmap(char* requested_addr, size_t bytes, bool fixed, bool executable) {
   char * addr;
   int flags;
 
   flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
+#ifdef __APPLE__
+  if (executable) {
+    guarantee(!fixed, "MAP_JIT (for execute) is incompatible with MAP_FIXED");
+    flags |= MAP_JIT;
+  }
+#endif
   if (fixed) {
     assert((uintptr_t)requested_addr % os::Bsd::page_size() == 0, "unaligned address");
     flags |= MAP_FIXED;
@@ -2047,8 +2068,9 @@ static int anon_munmap(char * addr, size_t size) {
 }
 
 char* os::pd_reserve_memory(size_t bytes, char* requested_addr,
-                            size_t alignment_hint) {
-  return anon_mmap(requested_addr, bytes, (requested_addr != NULL));
+                            size_t alignment_hint,
+                            bool executable) {
+  return anon_mmap(requested_addr, bytes, (requested_addr != NULL), executable);
 }
 
 bool os::pd_release_memory(char* addr, size_t size) {
@@ -2158,7 +2180,7 @@ char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
 
   // Bsd mmap allows caller to pass an address as hint; give it a try first,
   // if kernel honors the hint then we can return immediately.
-  char * addr = anon_mmap(requested_addr, bytes, false);
+  char * addr = anon_mmap(requested_addr, bytes, false/*fixed*/, false/*executable*/);
   if (addr == requested_addr) {
     return requested_addr;
   }
diff --git a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
index be6dfef313a..216e39384dc 100644
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -3456,7 +3456,7 @@ struct bitmask* os::Linux::_numa_nodes_ptr;
 struct bitmask* os::Linux::_numa_interleave_bitmask;
 struct bitmask* os::Linux::_numa_membind_bitmask;
 
-bool os::pd_uncommit_memory(char* addr, size_t size) {
+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
   return res  != (uintptr_t) MAP_FAILED;
@@ -3641,7 +3641,7 @@ bool os::remove_stack_guard_pages(char* addr, size_t size) {
     return ::munmap(addr, size) == 0;
   }
 
-  return os::uncommit_memory(addr, size);
+  return os::uncommit_memory(addr, size, !ExecMem);
 }
 
 // If 'fixed' is true, anon_mmap() will attempt to reserve anonymous memory
@@ -3716,7 +3716,8 @@ static int anon_munmap(char * addr, size_t size) {
 }
 
 char* os::pd_reserve_memory(size_t bytes, char* requested_addr,
-                            size_t alignment_hint) {
+                            size_t alignment_hint,
+                            bool executable) {
   return anon_mmap(requested_addr, bytes, (requested_addr != NULL));
 }
 
diff --git a/src/hotspot/os/windows/os_windows.cpp b/src/hotspot/os/windows/os_windows.cpp
index e687521022e..332e99ca014 100644
--- a/src/hotspot/os/windows/os_windows.cpp
+++ b/src/hotspot/os/windows/os_windows.cpp
@@ -3105,7 +3105,7 @@ char* os::reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {
   return aligned_base;
 }
 
-char* os::pd_reserve_memory(size_t bytes, char* addr, size_t alignment_hint) {
+char* os::pd_reserve_memory(size_t bytes, char* addr, size_t alignment_hint, bool executable) {
   assert((size_t)addr % os::vm_allocation_granularity() == 0,
          "reserve alignment");
   assert(bytes % os::vm_page_size() == 0, "reserve page size");
@@ -3308,7 +3308,7 @@ void os::pd_commit_memory_or_exit(char* addr, size_t size,
   pd_commit_memory_or_exit(addr, size, exec, mesg);
 }
 
-bool os::pd_uncommit_memory(char* addr, size_t bytes) {
+bool os::pd_uncommit_memory(char* addr, size_t bytes, bool exec) {
   if (bytes == 0) {
     // Don't bother the OS with noops.
     return true;
@@ -3327,7 +3327,7 @@ bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
 }
 
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  return os::uncommit_memory(addr, size);
+  return os::uncommit_memory(addr, size, !ExecMem);
 }
 
 static bool protect_pages_individually(char* addr, size_t bytes, unsigned int p, DWORD *old_status) {
diff --git a/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp b/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
index be7fa937ed2..ca86478a5e2 100644
--- a/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
+++ b/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
@@ -216,7 +216,7 @@ void G1PageBasedVirtualSpace::uncommit_internal(size_t start_page, size_t end_pa
             "Given start page " SIZE_FORMAT " is larger or equal to end page " SIZE_FORMAT, start_page, end_page);
 
   char* start_addr = page_start(start_page);
-  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)));
+  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)), !ExecMem);
 }
 
 void G1PageBasedVirtualSpace::uncommit(size_t start_page, size_t size_in_pages) {
diff --git a/src/hotspot/share/gc/parallel/psCardTable.cpp b/src/hotspot/share/gc/parallel/psCardTable.cpp
index 9ad29779ed7..322802a92c8 100644
--- a/src/hotspot/share/gc/parallel/psCardTable.cpp
+++ b/src/hotspot/share/gc/parallel/psCardTable.cpp
@@ -587,7 +587,8 @@ bool PSCardTable::resize_commit_uncommit(int changed_region,
       MemRegion(cur_committed.start(), new_start_aligned));
     if (!uncommit_region.is_empty()) {
       if (!os::uncommit_memory((char*)uncommit_region.start(),
-                               uncommit_region.byte_size())) {
+                               uncommit_region.byte_size(),
+                               !ExecMem)) {
         // If the uncommit fails, ignore it.  Let the
         // committed table resizing go even though the committed
         // table will over state the committed space.
diff --git a/src/hotspot/share/gc/parallel/psVirtualspace.cpp b/src/hotspot/share/gc/parallel/psVirtualspace.cpp
index 473a1f26854..f25d295093a 100644
--- a/src/hotspot/share/gc/parallel/psVirtualspace.cpp
+++ b/src/hotspot/share/gc/parallel/psVirtualspace.cpp
@@ -113,7 +113,7 @@ bool PSVirtualSpace::shrink_by(size_t bytes) {
   }
 
   char* const base_addr = committed_high_addr() - bytes;
-  bool result = special() || os::uncommit_memory(base_addr, bytes);
+  bool result = special() || os::uncommit_memory(base_addr, bytes, !ExecMem);
   if (result) {
     _committed_high_addr -= bytes;
   }
diff --git a/src/hotspot/share/gc/shared/cardTable.cpp b/src/hotspot/share/gc/shared/cardTable.cpp
index b2a7118e8aa..a74070c8d47 100644
--- a/src/hotspot/share/gc/shared/cardTable.cpp
+++ b/src/hotspot/share/gc/shared/cardTable.cpp
@@ -254,7 +254,8 @@ void CardTable::resize_covered_region(MemRegion new_region) {
                                                 cur_committed.end()));
       if (!uncommit_region.is_empty()) {
         if (!os::uncommit_memory((char*)uncommit_region.start(),
-                                 uncommit_region.byte_size())) {
+                                 uncommit_region.byte_size(),
+                                 !ExecMem)) {
           assert(false, "Card table contraction failed");
           // The call failed so don't change the end of the
           // committed region.  This is better than taking the
diff --git a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
index 7df181fa2ca..d016ee33310 100644
--- a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
@@ -1338,7 +1338,7 @@ void ShenandoahHeap::object_iterate(ObjectClosure* cl) {
 
   assert(oop_stack.is_empty(), "should be empty");
 
-  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
+  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), !ExecMem)) {
     log_warning(gc)("Could not uncommit native memory for auxiliary marking bitmap for heap iteration");
   }
 }
@@ -2690,7 +2690,7 @@ bool ShenandoahHeap::uncommit_bitmap_slice(ShenandoahHeapRegion *r) {
   size_t slice = r->index() / _bitmap_regions_per_slice;
   size_t off = _bitmap_bytes_per_slice * slice;
   size_t len = _bitmap_bytes_per_slice;
-  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len)) {
+  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len, !ExecMem)) {
     return false;
   }
   return true;
diff --git a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
index d50353eb455..dd8fbd87d31 100644
--- a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
@@ -627,7 +627,7 @@ void ShenandoahHeapRegion::do_commit() {
 
 void ShenandoahHeapRegion::do_uncommit() {
   ShenandoahHeap* heap = ShenandoahHeap::heap();
-  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {
+  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes, !ExecMem)) {
     report_java_out_of_memory("Unable to uncommit region");
   }
   if (!heap->uncommit_bitmap_slice(this)) {
diff --git a/src/hotspot/share/memory/virtualspace.cpp b/src/hotspot/share/memory/virtualspace.cpp
index 7f88f0dcf50..e148e7575fb 100644
--- a/src/hotspot/share/memory/virtualspace.cpp
+++ b/src/hotspot/share/memory/virtualspace.cpp
@@ -193,7 +193,7 @@ void ReservedSpace::initialize(size_t size, size_t alignment, bool large,
         base = NULL;
       }
     } else {
-      base = os::reserve_memory(size, NULL, alignment, _fd_for_heap);
+      base = os::reserve_memory(size, NULL, alignment, _fd_for_heap, _executable);
     }
 
     if (base == NULL) return;
@@ -985,7 +985,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(middle_high_boundary() <= aligned_upper_new_high &&
            aligned_upper_new_high + upper_needs <= upper_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs)) {
+    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs, _executable)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
@@ -996,7 +996,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(lower_high_boundary() <= aligned_middle_new_high &&
            aligned_middle_new_high + middle_needs <= middle_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs)) {
+    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs, _executable)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
@@ -1007,7 +1007,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(low_boundary() <= aligned_lower_new_high &&
            aligned_lower_new_high + lower_needs <= lower_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs)) {
+    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs, _executable)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
diff --git a/src/hotspot/share/prims/whitebox.cpp b/src/hotspot/share/prims/whitebox.cpp
index 586c2b7d9cc..6a606cc6400 100644
--- a/src/hotspot/share/prims/whitebox.cpp
+++ b/src/hotspot/share/prims/whitebox.cpp
@@ -773,7 +773,7 @@ WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size
 WB_END
 
 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
-  os::uncommit_memory((char *)(uintptr_t)addr, size);
+  os::uncommit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 WB_END
 
 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
diff --git a/src/hotspot/share/runtime/os.cpp b/src/hotspot/share/runtime/os.cpp
index 2a3621f3712..df7be196d96 100644
--- a/src/hotspot/share/runtime/os.cpp
+++ b/src/hotspot/share/runtime/os.cpp
@@ -1652,7 +1652,7 @@ bool os::create_stack_guard_pages(char* addr, size_t bytes) {
   return os::pd_create_stack_guard_pages(addr, bytes);
 }
 
-char* os::reserve_memory(size_t bytes, char* addr, size_t alignment_hint, int file_desc) {
+char* os::reserve_memory(size_t bytes, char* addr, size_t alignment_hint, int file_desc, bool executable) {
   char* result = NULL;
 
   if (file_desc != -1) {
@@ -1663,7 +1663,7 @@ char* os::reserve_memory(size_t bytes, char* addr, size_t alignment_hint, int fi
       MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC);
     }
   } else {
-    result = pd_reserve_memory(bytes, addr, alignment_hint);
+    result = pd_reserve_memory(bytes, addr, alignment_hint, executable);
     if (result != NULL) {
       MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);
     }
@@ -1728,16 +1728,16 @@ void os::commit_memory_or_exit(char* addr, size_t size, size_t alignment_hint,
   MemTracker::record_virtual_memory_commit((address)addr, size, CALLER_PC);
 }
 
-bool os::uncommit_memory(char* addr, size_t bytes) {
+bool os::uncommit_memory(char* addr, size_t bytes, bool exec) {
   bool res;
   if (MemTracker::tracking_level() > NMT_minimal) {
     Tracker tkr(Tracker::uncommit);
-    res = pd_uncommit_memory(addr, bytes);
+    res = pd_uncommit_memory(addr, bytes, exec);
     if (res) {
       tkr.record((address)addr, bytes);
     }
   } else {
-    res = pd_uncommit_memory(addr, bytes);
+    res = pd_uncommit_memory(addr, bytes, exec);
   }
   return res;
 }
diff --git a/src/hotspot/share/runtime/os.hpp b/src/hotspot/share/runtime/os.hpp
index 21031656aa5..7d9a91f5ffa 100644
--- a/src/hotspot/share/runtime/os.hpp
+++ b/src/hotspot/share/runtime/os.hpp
@@ -114,7 +114,8 @@ class os: AllStatic {
   }
 
   static char*  pd_reserve_memory(size_t bytes, char* addr = 0,
-                                  size_t alignment_hint = 0);
+                                  size_t alignment_hint = 0,
+                                  bool executable = false);
   static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr);
   static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc);
   static bool   pd_commit_memory(char* addr, size_t bytes, bool executable);
@@ -127,7 +128,7 @@ class os: AllStatic {
   static void   pd_commit_memory_or_exit(char* addr, size_t size,
                                          size_t alignment_hint,
                                          bool executable, const char* mesg);
-  static bool   pd_uncommit_memory(char* addr, size_t bytes);
+  static bool   pd_uncommit_memory(char* addr, size_t bytes, bool exec);
   static bool   pd_release_memory(char* addr, size_t bytes);
 
   static char*  pd_map_memory(int fd, const char* file_name, size_t file_offset,
@@ -311,7 +312,8 @@ class os: AllStatic {
 
   static int    vm_allocation_granularity();
   static char*  reserve_memory(size_t bytes, char* addr = 0,
-                               size_t alignment_hint = 0, int file_desc = -1);
+                               size_t alignment_hint = 0, int file_desc = -1,
+                               bool executable = false);
   static char*  reserve_memory(size_t bytes, char* addr,
                                size_t alignment_hint, MEMFLAGS flags);
   static char*  reserve_memory_aligned(size_t size, size_t alignment, int file_desc = -1);
@@ -338,7 +340,7 @@ class os: AllStatic {
   static void   commit_memory_or_exit(char* addr, size_t size,
                                       size_t alignment_hint,
                                       bool executable, const char* mesg);
-  static bool   uncommit_memory(char* addr, size_t bytes);
+  static bool   uncommit_memory(char* addr, size_t bytes, bool exec);
   static bool   release_memory(char* addr, size_t bytes);
 
   // Touch memory pages that cover the memory range from start to end (exclusive)
diff --git a/src/hotspot/share/runtime/thread.cpp b/src/hotspot/share/runtime/thread.cpp
index 204cd033589..5f8c9100927 100644
--- a/src/hotspot/share/runtime/thread.cpp
+++ b/src/hotspot/share/runtime/thread.cpp
@@ -2754,7 +2754,7 @@ void JavaThread::create_stack_guard_pages() {
   } else {
     log_warning(os, thread)("Attempt to protect stack guard pages failed ("
       PTR_FORMAT "-" PTR_FORMAT ").", p2i(low_addr), p2i(low_addr + len));
-    if (os::uncommit_memory((char *) low_addr, len)) {
+    if (os::uncommit_memory((char *) low_addr, len, !ExecMem)) {
       log_warning(os, thread)("Attempt to deallocate stack guard pages failed.");
     }
     return;

From 368f06e1cb965a68997cad0722aabcbe1068aad7 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@openjdk.org>
Date: Mon, 24 Aug 2020 08:24:22 -0700
Subject: [PATCH 04/94] JDK-8253817: Support macOS Aarch64 ABI in Interpreter

ZULU-17389, ZULU-18130, ZULU-18625, ZULU-18639
---
 .../cpu/aarch64/interpreterRT_aarch64.cpp     | 174 ++++++++++++++++--
 .../cpu/aarch64/interpreterRT_aarch64.hpp     |   2 +
 .../cpu/aarch64/sharedRuntime_aarch64.cpp     |  14 ++
 src/hotspot/share/interpreter/oopMapCache.cpp |   2 +
 src/hotspot/share/runtime/signature.hpp       |  10 +-
 5 files changed, 189 insertions(+), 13 deletions(-)

diff --git a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
index 8a89fb56a83..8318393bcb8 100644
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
@@ -38,6 +38,30 @@
 
 #define __ _masm->
 
+//describe amount of space in bytes occupied by type on native stack
+#ifdef __APPLE__
+    const int nativeByteSpace        = sizeof(jbyte);
+    const int nativeShortSpace       = sizeof(jshort);
+    const int nativeIntSpace         = sizeof(jint);
+    const int nativeLongSpace        = wordSize;
+    const int nativeFloatSpace       = nativeIntSpace;
+    const int nativeDoubleSpace      = nativeLongSpace;
+#else
+    const int nativeByteSpace        = wordSize;
+    const int nativeShortSpace       = wordSize;
+    const int nativeIntSpace         = wordSize;
+    const int nativeLongSpace        = wordSize;
+    const int nativeFloatSpace       = nativeIntSpace;
+    const int nativeDoubleSpace      = nativeLongSpace;
+#endif
+
+template <typename T>
+static inline void store_and_inc(char* &to, T value, int inc_size) {
+  to = align_up(to, inc_size);
+  *(T *)to = value;
+  to = to + inc_size;
+}
+
 // Implementation of SignatureHandlerGenerator
 Register InterpreterRuntime::SignatureHandlerGenerator::from() { return rlocals; }
 Register InterpreterRuntime::SignatureHandlerGenerator::to()   { return sp; }
@@ -51,6 +75,95 @@ InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
   _stack_offset = 0;
 }
 
+// On macos/aarch64 native stack is packed, int/float are using only 4 bytes
+// on stack. Natural alignment for types are still in place,
+// for example double/long should be 8 bytes alligned
+
+void InterpreterRuntime::SignatureHandlerGenerator::pass_byte() {
+  const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
+
+  switch (_num_int_args) {
+  case 0:
+    __ ldr(c_rarg1, src);
+    _num_int_args++;
+    break;
+  case 1:
+    __ ldr(c_rarg2, src);
+    _num_int_args++;
+    break;
+  case 2:
+    __ ldr(c_rarg3, src);
+    _num_int_args++;
+    break;
+  case 3:
+    __ ldr(c_rarg4, src);
+    _num_int_args++;
+    break;
+  case 4:
+    __ ldr(c_rarg5, src);
+    _num_int_args++;
+    break;
+  case 5:
+    __ ldr(c_rarg6, src);
+    _num_int_args++;
+    break;
+  case 6:
+    __ ldr(c_rarg7, src);
+    _num_int_args++;
+    break;
+  default:
+    __ ldrb(r0, src);
+    __ strb(r0, Address(to(), _stack_offset));
+    _stack_offset += nativeByteSpace;
+
+    _num_int_args++;
+    break;
+  }
+}
+
+void InterpreterRuntime::SignatureHandlerGenerator::pass_short() {
+  const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
+
+  switch (_num_int_args) {
+  case 0:
+    __ ldr(c_rarg1, src);
+    _num_int_args++;
+    break;
+  case 1:
+    __ ldr(c_rarg2, src);
+    _num_int_args++;
+    break;
+  case 2:
+    __ ldr(c_rarg3, src);
+    _num_int_args++;
+    break;
+  case 3:
+    __ ldr(c_rarg4, src);
+    _num_int_args++;
+    break;
+  case 4:
+    __ ldr(c_rarg5, src);
+    _num_int_args++;
+    break;
+  case 5:
+    __ ldr(c_rarg6, src);
+    _num_int_args++;
+    break;
+  case 6:
+    __ ldr(c_rarg7, src);
+    _num_int_args++;
+    break;
+  default:
+    _stack_offset = align_up(_stack_offset, nativeShortSpace);
+    __ ldrh(r0, src);
+    __ strh(r0, Address(to(), _stack_offset));
+    _stack_offset += nativeShortSpace;
+
+    _num_int_args++;
+    break;
+  }
+}
+
 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
@@ -84,9 +197,10 @@ void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
     _num_int_args++;
     break;
   default:
+    _stack_offset = align_up(_stack_offset, nativeIntSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += wordSize;
+    _stack_offset += nativeIntSpace;
     _num_int_args++;
     break;
   }
@@ -125,9 +239,10 @@ void InterpreterRuntime::SignatureHandlerGenerator::pass_long() {
     _num_int_args++;
     break;
   default:
+    _stack_offset = align_up(_stack_offset, nativeLongSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += wordSize;
+    _stack_offset += nativeLongSpace;
     _num_int_args++;
     break;
   }
@@ -139,9 +254,10 @@ void InterpreterRuntime::SignatureHandlerGenerator::pass_float() {
   if (_num_fp_args < Argument::n_float_register_parameters_c) {
     __ ldrs(as_FloatRegister(_num_fp_args++), src);
   } else {
+      _stack_offset = align_up(_stack_offset, nativeFloatSpace);
     __ ldrw(r0, src);
     __ strw(r0, Address(to(), _stack_offset));
-    _stack_offset += wordSize;
+    _stack_offset += nativeFloatSpace;
     _num_fp_args++;
   }
 }
@@ -152,9 +268,10 @@ void InterpreterRuntime::SignatureHandlerGenerator::pass_double() {
   if (_num_fp_args < Argument::n_float_register_parameters_c) {
     __ ldrd(as_FloatRegister(_num_fp_args++), src);
   } else {
+    _stack_offset = align_up(_stack_offset, nativeDoubleSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += wordSize;
+    _stack_offset += nativeDoubleSpace;
     _num_fp_args++;
   }
 }
@@ -247,6 +364,7 @@ void InterpreterRuntime::SignatureHandlerGenerator::pass_object() {
       __ cbnz(temp(), L);
       __ mov(r0, zr);
       __ bind(L);
+      _stack_offset = align_up(_stack_offset, wordSize);
       __ str(r0, Address(to(), _stack_offset));
       _stack_offset += wordSize;
       _num_int_args++;
@@ -276,13 +394,45 @@ class SlowSignatureHandler
   : public NativeSignatureIterator {
  private:
   address   _from;
-  intptr_t* _to;
+  char*     _to;
   intptr_t* _int_args;
   intptr_t* _fp_args;
   intptr_t* _fp_identifiers;
   unsigned int _num_int_args;
   unsigned int _num_fp_args;
 
+
+  virtual void pass_byte()
+  {
+    NOT_MACOS(return pass_int();)
+    jbyte from_obj = *(jbyte *)(_from+Interpreter::local_offset_in_bytes(0));
+    _from -= Interpreter::stackElementSize;
+
+    if (_num_int_args < Argument::n_int_register_parameters_c-1) {
+      *_int_args++ = from_obj;
+      _num_int_args++;
+    } else {
+      store_and_inc(_to, from_obj, nativeByteSpace);
+
+      _num_int_args++;
+    }
+  }
+
+  virtual void pass_short()
+  {
+    NOT_MACOS(return pass_int();)
+    jshort from_obj = *(jshort *)(_from+Interpreter::local_offset_in_bytes(0));
+    _from -= Interpreter::stackElementSize;
+
+    if (_num_int_args < Argument::n_int_register_parameters_c-1) {
+      *_int_args++ = from_obj;
+      _num_int_args++;
+    } else {
+      store_and_inc(_to, from_obj, nativeShortSpace);
+
+      _num_int_args++;
+    }
+  }
   virtual void pass_int()
   {
     jint from_obj = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
@@ -292,7 +442,8 @@ class SlowSignatureHandler
       *_int_args++ = from_obj;
       _num_int_args++;
     } else {
-      *_to++ = from_obj;
+      store_and_inc(_to, from_obj, nativeIntSpace);
+
       _num_int_args++;
     }
   }
@@ -306,7 +457,7 @@ class SlowSignatureHandler
       *_int_args++ = from_obj;
       _num_int_args++;
     } else {
-      *_to++ = from_obj;
+      store_and_inc(_to, from_obj, nativeLongSpace);
       _num_int_args++;
     }
   }
@@ -320,7 +471,7 @@ class SlowSignatureHandler
       *_int_args++ = (*from_addr == 0) ? NULL : (intptr_t)from_addr;
       _num_int_args++;
     } else {
-      *_to++ = (*from_addr == 0) ? NULL : (intptr_t) from_addr;
+      store_and_inc(_to, (*from_addr == 0) ? (intptr_t)NULL : (intptr_t) from_addr, wordSize);
       _num_int_args++;
     }
   }
@@ -334,7 +485,8 @@ class SlowSignatureHandler
       *_fp_args++ = from_obj;
       _num_fp_args++;
     } else {
-      *_to++ = from_obj;
+      store_and_inc(_to, from_obj, nativeFloatSpace);
+
       _num_fp_args++;
     }
   }
@@ -349,7 +501,7 @@ class SlowSignatureHandler
       *_fp_identifiers |= (1ull << _num_fp_args); // mark as double
       _num_fp_args++;
     } else {
-      *_to++ = from_obj;
+      store_and_inc(_to, from_obj, nativeDoubleSpace);
       _num_fp_args++;
     }
   }
@@ -359,7 +511,7 @@ class SlowSignatureHandler
     : NativeSignatureIterator(method)
   {
     _from = from;
-    _to   = to;
+    _to   = (char *)to;
 
     _int_args = to - (method->is_static() ? 16 : 17);
     _fp_args =  to - 8;
diff --git a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp
index ee7c2d1bf76..2190cf269f6 100644
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp
@@ -38,6 +38,8 @@ class SignatureHandlerGenerator: public NativeSignatureIterator {
   unsigned int _num_int_args;
   int _stack_offset;
 
+  void pass_byte();
+  void pass_short();
   void pass_int();
   void pass_long();
   void pass_float();
diff --git a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
index 8984b855613..3dcb643588a 100644
--- a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
@@ -801,6 +801,11 @@ int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
         if (int_args < Argument::n_int_register_parameters_c) {
           regs[i].set1(INT_ArgReg[int_args++]->as_VMReg());
         } else {
+#ifdef __APPLE__
+          // Less-than word types are stored one after another.
+          // The code unable to handle this, bailout.
+          return -1;
+#endif
           regs[i].set1(VMRegImpl::stack2reg(stk_args));
           stk_args += 2;
         }
@@ -823,6 +828,11 @@ int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
         if (fp_args < Argument::n_float_register_parameters_c) {
           regs[i].set1(FP_ArgReg[fp_args++]->as_VMReg());
         } else {
+#ifdef __APPLE__
+          // Less-than word types are stored one after another.
+          // The code unable to handle this, bailout.
+          return -1;
+#endif
           regs[i].set1(VMRegImpl::stack2reg(stk_args));
           stk_args += 2;
         }
@@ -1384,6 +1394,10 @@ nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
   int out_arg_slots;
   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
 
+  if (out_arg_slots < 0) {
+    return NULL;
+  }
+
   // Compute framesize for the wrapper.  We need to handlize all oops in
   // incoming registers
 
diff --git a/src/hotspot/share/interpreter/oopMapCache.cpp b/src/hotspot/share/interpreter/oopMapCache.cpp
index 5ba1500257f..fcadc4457ae 100644
--- a/src/hotspot/share/interpreter/oopMapCache.cpp
+++ b/src/hotspot/share/interpreter/oopMapCache.cpp
@@ -242,6 +242,8 @@ class MaskFillerForNative: public NativeSignatureIterator {
   }
 
  public:
+  void pass_byte()                               { /* ignore */ }
+  void pass_short()                              { /* ignore */ }
   void pass_int()                                { /* ignore */ }
   void pass_long()                               { /* ignore */ }
   void pass_float()                              { /* ignore */ }
diff --git a/src/hotspot/share/runtime/signature.hpp b/src/hotspot/share/runtime/signature.hpp
index c4b6167989a..0ed57e424a6 100644
--- a/src/hotspot/share/runtime/signature.hpp
+++ b/src/hotspot/share/runtime/signature.hpp
@@ -381,10 +381,14 @@ class NativeSignatureIterator: public SignatureIterator {
   void do_type(BasicType type) {
     switch (type) {
     case T_BYTE:
-    case T_SHORT:
-    case T_INT:
     case T_BOOLEAN:
+      pass_byte();  _jni_offset++; _offset++;
+      break;
     case T_CHAR:
+    case T_SHORT:
+      pass_short();  _jni_offset++; _offset++;
+      break;
+    case T_INT:
       pass_int();    _jni_offset++; _offset++;
       break;
     case T_FLOAT:
@@ -418,6 +422,8 @@ class NativeSignatureIterator: public SignatureIterator {
   virtual void pass_long()             = 0;
   virtual void pass_object()           = 0;  // objects, arrays, inlines
   virtual void pass_float()            = 0;
+  virtual void pass_byte()             { pass_int(); };
+  virtual void pass_short()            { pass_int(); };
 #ifdef _LP64
   virtual void pass_double()           = 0;
 #else

From f888accb52c5cdd142e8a6498b53a4870c5466e2 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@openjdk.org>
Date: Mon, 10 Aug 2020 08:08:45 -0700
Subject: [PATCH 05/94] JDK-8253816: Support macOS W^X

ZULU-17141, ZULU-18388
---
 src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp     |  6 ++
 src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp     |  6 ++
 src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp   |  6 ++
 .../os_cpu/linux_aarch64/os_linux_aarch64.hpp |  6 ++
 src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp |  6 ++
 src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp |  6 ++
 .../os_cpu/linux_s390/os_linux_s390.hpp       |  6 ++
 src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp |  6 ++
 .../os_cpu/linux_zero/os_linux_zero.hpp       |  6 ++
 .../os_cpu/windows_x86/os_windows_x86.hpp     |  6 ++
 src/hotspot/share/ci/ciUtilities.inline.hpp   |  2 +
 src/hotspot/share/classfile/classLoader.cpp   |  4 +
 src/hotspot/share/classfile/javaClasses.cpp   |  2 +
 src/hotspot/share/classfile/verifier.cpp      |  1 +
 src/hotspot/share/compiler/compileBroker.cpp  |  3 +
 .../share/gc/shared/barrierSetNMethod.cpp     |  2 +
 src/hotspot/share/gc/shared/oopStorage.cpp    |  2 +-
 .../jfr/instrumentation/jfrJvmtiAgent.cpp     |  3 +
 .../share/jvmci/jniAccessMark.inline.hpp      |  3 +-
 .../share/jvmci/jvmciCodeInstaller.cpp        |  1 +
 src/hotspot/share/jvmci/jvmciCompilerToVM.cpp |  1 +
 src/hotspot/share/jvmci/jvmciRuntime.cpp      |  2 +
 src/hotspot/share/opto/runtime.cpp            |  2 +
 src/hotspot/share/prims/jni.cpp               |  5 ++
 src/hotspot/share/prims/jniCheck.cpp          |  1 +
 src/hotspot/share/prims/jvm.cpp               |  1 +
 src/hotspot/share/prims/jvmtiEnter.xsl        |  2 +
 src/hotspot/share/prims/jvmtiEnv.cpp          |  1 +
 src/hotspot/share/prims/jvmtiExport.cpp       |  6 +-
 src/hotspot/share/prims/jvmtiImpl.cpp         |  1 +
 src/hotspot/share/prims/jvmtiRawMonitor.cpp   |  2 +
 src/hotspot/share/prims/methodHandles.cpp     |  1 +
 src/hotspot/share/prims/nativeLookup.cpp      |  1 +
 src/hotspot/share/prims/perf.cpp              |  9 +++
 src/hotspot/share/prims/unsafe.cpp            |  4 +
 src/hotspot/share/prims/whitebox.cpp          | 31 ++++++++
 src/hotspot/share/runtime/deoptimization.cpp  |  1 +
 .../share/runtime/interfaceSupport.inline.hpp | 11 ++-
 src/hotspot/share/runtime/javaCalls.cpp       |  5 +-
 src/hotspot/share/runtime/objectMonitor.cpp   |  2 +-
 src/hotspot/share/runtime/os.cpp              |  2 +-
 src/hotspot/share/runtime/os.hpp              | 12 ++-
 src/hotspot/share/runtime/safepoint.cpp       |  2 +
 src/hotspot/share/runtime/sharedRuntime.cpp   |  3 +
 src/hotspot/share/runtime/stubRoutines.cpp    |  6 +-
 src/hotspot/share/runtime/stubRoutines.hpp    | 20 -----
 .../share/runtime/stubRoutines.inline.hpp     | 54 +++++++++++++
 src/hotspot/share/runtime/thread.cpp          | 13 ++++
 src/hotspot/share/runtime/thread.hpp          | 75 +++++++++++++++++++
 .../share/services/diagnosticCommand.cpp      |  1 +
 src/hotspot/share/utilities/vmError.cpp       |  1 +
 51 files changed, 332 insertions(+), 29 deletions(-)
 create mode 100644 src/hotspot/share/runtime/stubRoutines.inline.hpp

diff --git a/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp b/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp
index a3d89699135..e8b16b4ad59 100644
--- a/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp
+++ b/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp
@@ -36,4 +36,10 @@
 static bool platform_print_native_stack(outputStream* st, void* context,
                                         char *buf, int buf_size);
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_AIX_PPC_OS_AIX_PPC_HPP
diff --git a/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp b/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp
index bd7ad6344f9..19a62da5585 100644
--- a/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp
+++ b/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp
@@ -37,4 +37,10 @@
   // Note: Currently only used in 64 bit Windows implementations
   static bool register_code_area(char *low, char *high) { return true; }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_BSD_X86_OS_BSD_X86_HPP
diff --git a/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp b/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp
index 511400ae0d2..9914eb031a0 100644
--- a/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp
+++ b/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp
@@ -53,4 +53,10 @@
 #endif
   }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_BSD_ZERO_OS_BSD_ZERO_HPP
diff --git a/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp b/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp
index c341be21185..a3e935da386 100644
--- a/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp
+++ b/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp
@@ -39,4 +39,10 @@
     *(jlong *) dst = *(const jlong *) src;
   }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_LINUX_AARCH64_OS_LINUX_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp b/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp
index 9c5d629b095..95087836868 100644
--- a/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp
+++ b/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp
@@ -70,4 +70,10 @@
                                            int32_t exchange_value,
                                            volatile int32_t *dest);
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_LINUX_ARM_OS_LINUX_ARM_HPP
diff --git a/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp b/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp
index 1c108de12a0..6644e727a0b 100644
--- a/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp
+++ b/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp
@@ -32,4 +32,10 @@
   // Note: Currently only used in 64 bit Windows implementations
   static bool register_code_area(char *low, char *high) { return true; }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_LINUX_PPC_OS_LINUX_PPC_HPP
diff --git a/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp b/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp
index 35618f4e8f4..2417f7b17ff 100644
--- a/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp
+++ b/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp
@@ -31,4 +31,10 @@
   // Used to register dynamic code cache area with the OS.
   static bool register_code_area(char *low, char *high) { return true; }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_LINUX_S390_OS_LINUX_S390_HPP
diff --git a/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp b/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp
index a60394f9a73..6a8525c7301 100644
--- a/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp
+++ b/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp
@@ -50,4 +50,10 @@
    */
   static void workaround_expand_exec_shield_cs_limit();
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_LINUX_X86_OS_LINUX_X86_HPP
diff --git a/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp b/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp
index 2e7e7ed6d41..a875e53843a 100644
--- a/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp
+++ b/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp
@@ -82,4 +82,10 @@
 #endif
   }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+private:
+
 #endif // OS_CPU_LINUX_ZERO_OS_LINUX_ZERO_HPP
diff --git a/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp b/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp
index 7fdd068219c..867ddb23099 100644
--- a/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp
+++ b/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp
@@ -43,4 +43,10 @@ static bool platform_print_native_stack(outputStream* st, const void* context,
                                         char *buf, int buf_size);
 #endif
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_WINDOWS_X86_OS_WINDOWS_X86_HPP
diff --git a/src/hotspot/share/ci/ciUtilities.inline.hpp b/src/hotspot/share/ci/ciUtilities.inline.hpp
index 8b752cd812a..652bf2e400c 100644
--- a/src/hotspot/share/ci/ciUtilities.inline.hpp
+++ b/src/hotspot/share/ci/ciUtilities.inline.hpp
@@ -34,6 +34,7 @@
 #define VM_ENTRY_MARK                       \
   CompilerThread* thread=CompilerThread::current(); \
   ThreadInVMfromNative __tiv(thread);       \
+  Thread::WXWriteVerifier __wx_write;       \
   ResetNoHandleMark rnhm;                   \
   HandleMarkCleaner __hm(thread);           \
   Thread* THREAD = thread;                  \
@@ -45,6 +46,7 @@
 #define VM_QUICK_ENTRY_MARK                 \
   CompilerThread* thread=CompilerThread::current(); \
   ThreadInVMfromNative __tiv(thread);       \
+  Thread::WXWriteVerifier __wx_write;       \
 /*                                          \
  * [TODO] The NoHandleMark line does nothing but declare a function prototype \
  * The NoHandkeMark constructor is NOT executed. If the ()'s are   \
diff --git a/src/hotspot/share/classfile/classLoader.cpp b/src/hotspot/share/classfile/classLoader.cpp
index 7b34ef939c5..72b0b727269 100644
--- a/src/hotspot/share/classfile/classLoader.cpp
+++ b/src/hotspot/share/classfile/classLoader.cpp
@@ -290,6 +290,7 @@ u1* ClassPathZipEntry::open_entry(const char* name, jint* filesize, bool nul_ter
     // enable call to C land
   JavaThread* thread = JavaThread::current();
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   // check whether zip archive contains name
   jint name_len;
   jzentry* entry = (*FindEntry)(_zip, name, filesize, &name_len);
@@ -336,6 +337,7 @@ void ClassPathZipEntry::contents_do(void f(const char* name, void* context), voi
   JavaThread* thread = JavaThread::current();
   HandleMark  handle_mark(thread);
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   for (int n = 0; ; n++) {
     jzentry * ze = ((*GetNextEntry)(_zip, n));
     if (ze == NULL) break;
@@ -748,6 +750,7 @@ ClassPathEntry* ClassLoader::create_class_path_entry(const char *path, const str
       {
         // enable call to C land
         ThreadToNativeFromVM ttn(thread);
+        Thread::WXExecFromWriteSetter wx_exec;
         HandleMark hm(thread);
         load_zip_library_if_needed();
         zip = (*ZipOpen)(canonical_path, &error_msg);
@@ -798,6 +801,7 @@ ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path, bo
           // enable call to C land
           JavaThread* thread = JavaThread::current();
           ThreadToNativeFromVM ttn(thread);
+          Thread::WXExecFromWriteSetter wx_exec;
           HandleMark hm(thread);
           load_zip_library_if_needed();
           zip = (*ZipOpen)(canonical_path, &error_msg);
diff --git a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
index abaf2fb4f6e..e50d7e84e3a 100644
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -411,6 +411,7 @@ Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRA
     JavaThread* thread = THREAD->as_Java_thread();
     HandleMark hm(thread);
     ThreadToNativeFromVM ttn(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     js = (_to_java_string_fn)(thread->jni_environment(), str);
   }
 
@@ -439,6 +440,7 @@ char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
     bool is_copy;
     HandleMark hm(thread);
     ThreadToNativeFromVM ttn(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     JNIEnv *env = thread->jni_environment();
     native_platform_string = (_to_platform_string_fn)(env, js, &is_copy);
     assert(is_copy == JNI_TRUE, "is_copy value changed");
diff --git a/src/hotspot/share/classfile/verifier.cpp b/src/hotspot/share/classfile/verifier.cpp
index 25511485a6c..f57f1424a74 100644
--- a/src/hotspot/share/classfile/verifier.cpp
+++ b/src/hotspot/share/classfile/verifier.cpp
@@ -314,6 +314,7 @@ Symbol* Verifier::inference_verify(
   {
     HandleMark hm(thread);
     ThreadToNativeFromVM ttn(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     // ThreadToNativeFromVM takes care of changing thread_state, so safepoint
     // code knows that we have left the VM
     JNIEnv *env = thread->jni_environment();
diff --git a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp
index 97cc1c35a19..df2debd1525 100644
--- a/src/hotspot/share/compiler/compileBroker.cpp
+++ b/src/hotspot/share/compiler/compileBroker.cpp
@@ -1699,6 +1699,7 @@ bool CompileBroker::init_compiler_runtime() {
   {
     // Must switch to native to allocate ci_env
     ThreadToNativeFromVM ttn(thread);
+    Thread::WXWriteVerifier wx_write;
     ciEnv ci_env((CompileTask*)NULL);
     // Cache Jvmti state
     ci_env.cache_jvmti_state();
@@ -1995,6 +1996,7 @@ void CompileBroker::maybe_block() {
       tty->print_cr("compiler thread " INTPTR_FORMAT " poll detects block request", p2i(Thread::current()));
 #endif
     ThreadInVMfromNative tivfn(JavaThread::current());
+    Thread::WXWriteVerifier wx_write;
   }
 }
 
@@ -2185,6 +2187,7 @@ void CompileBroker::invoke_compiler_on_method(CompileTask* task) {
   {
     NoHandleMark  nhm;
     ThreadToNativeFromVM ttn(thread);
+    Thread::WXWriteVerifier wx_write;
 
     ciEnv ci_env(task);
     if (should_break) {
diff --git a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
index 9c6ba3867f1..425bcdb26ea 100644
--- a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
+++ b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
@@ -48,6 +48,8 @@ bool BarrierSetNMethod::supports_entry_barrier(nmethod* nm) {
 }
 
 int BarrierSetNMethod::nmethod_stub_entry_barrier(address* return_address_ptr) {
+  Thread::WXWriteFromExecSetter wx_write;
+
   address return_address = *return_address_ptr;
   CodeBlob* cb = CodeCache::find_blob(return_address);
   assert(cb != NULL, "invariant");
diff --git a/src/hotspot/share/gc/shared/oopStorage.cpp b/src/hotspot/share/gc/shared/oopStorage.cpp
index 1f8dbeaa61c..7bde199329e 100644
--- a/src/hotspot/share/gc/shared/oopStorage.cpp
+++ b/src/hotspot/share/gc/shared/oopStorage.cpp
@@ -37,7 +37,7 @@
 #include "runtime/orderAccess.hpp"
 #include "runtime/os.hpp"
 #include "runtime/safepoint.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.hpp"
 #include "services/memTracker.hpp"
 #include "utilities/align.hpp"
diff --git a/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp b/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp
index 4dc9fba7ae5..2bca6f1ace8 100644
--- a/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp
+++ b/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp
@@ -84,6 +84,7 @@ extern "C" void JNICALL jfr_on_class_file_load_hook(jvmtiEnv *jvmti_env,
   }
   JavaThread* jt = JavaThread::thread_from_jni_environment(jni_env);
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));;
+  Thread::WXWriteFromExecSetter wx_write;
   ThreadInVMfromNative tvmfn(jt);
   JfrUpcalls::on_retransform(JfrTraceId::load_raw(class_being_redefined),
                              class_being_redefined,
@@ -231,6 +232,7 @@ JfrJvmtiAgent::~JfrJvmtiAgent() {
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
   if (jfr_jvmti_env != NULL) {
     ThreadToNativeFromVM transition(jt);
+    Thread::WXExecFromWriteSetter wx_exec;
     update_class_file_load_hook_event(JVMTI_DISABLE);
     unregister_callbacks(jt);
     jfr_jvmti_env->DisposeEnvironment();
@@ -242,6 +244,7 @@ static bool initialize(JavaThread* jt) {
   assert(jt != NULL, "invariant");
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
   ThreadToNativeFromVM transition(jt);
+  Thread::WXExecFromWriteSetter wx_exec;
   if (create_jvmti_env(jt) != JNI_OK) {
     assert(jfr_jvmti_env == NULL, "invariant");
     return false;
diff --git a/src/hotspot/share/jvmci/jniAccessMark.inline.hpp b/src/hotspot/share/jvmci/jniAccessMark.inline.hpp
index 9e691313c99..f9b8e8960e0 100644
--- a/src/hotspot/share/jvmci/jniAccessMark.inline.hpp
+++ b/src/hotspot/share/jvmci/jniAccessMark.inline.hpp
@@ -36,11 +36,12 @@
 class JNIAccessMark : public StackObj {
  private:
   ThreadToNativeFromVM _ttnfv;
+  Thread::WXExecFromWriteSetter _wx_exec;
   HandleMark _hm;
   JNIEnv* _env;
  public:
   inline JNIAccessMark(JVMCIEnv* jvmci_env, JavaThread* thread=JavaThread::current()) :
-    _ttnfv(thread), _hm(thread) {
+    _ttnfv(thread), _wx_exec(), _hm(thread) {
     _env = jvmci_env->_env;
   }
   JNIEnv* env() const { return _env; }
diff --git a/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp b/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
index 5ca1aeb6a95..21547a6800d 100644
--- a/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
+++ b/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
@@ -922,6 +922,7 @@ JVMCI::CodeInstallResult CodeInstaller::initialize_buffer(CodeBuffer& buffer, bo
     if (SafepointMechanism::should_process(thread)) {
       // this is a hacky way to force a safepoint check but nothing else was jumping out at me.
       ThreadToNativeFromVM ttnfv(thread);
+      Thread::WXWriteVerifier wx_write;
     }
   }
 
diff --git a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
index a2adfc37031..9024fa25eb8 100644
--- a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
+++ b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
@@ -121,6 +121,7 @@ Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 
 // Bring the JVMCI compiler thread into the VM state.
 #define JVMCI_VM_ENTRY_MARK                   \
+  Thread::WXWriteFromExecSetter __wx_write;   \
   ThreadInVMfromNative __tiv(thread);         \
   ResetNoHandleMark rnhm;                     \
   HandleMarkCleaner __hm(thread);             \
diff --git a/src/hotspot/share/jvmci/jvmciRuntime.cpp b/src/hotspot/share/jvmci/jvmciRuntime.cpp
index 2135cc3ca17..4fe0495690b 100644
--- a/src/hotspot/share/jvmci/jvmciRuntime.cpp
+++ b/src/hotspot/share/jvmci/jvmciRuntime.cpp
@@ -861,6 +861,7 @@ void JVMCIRuntime::init_JavaVM_info(jlongArray info, JVMCI_TRAPS) {
 #define JAVAVM_CALL_BLOCK                                             \
   guarantee(thread != NULL && _shared_library_javavm != NULL, "npe"); \
   ThreadToNativeFromVM ttnfv(thread);                                 \
+  Thread::WXExecFromWriteSetter wx_exec;                              \
   JavaVM* javavm = (JavaVM*) _shared_library_javavm;
 
 jint JVMCIRuntime::AttachCurrentThread(JavaThread* thread, void **penv, void *args) {
@@ -1021,6 +1022,7 @@ JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
     ResourceMark rm(thread);
     HandleMark hm(thread);
     ThreadToNativeFromVM trans(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
 
     // Ensure _non_oop_bits is initialized
     Universe::non_oop_word();
diff --git a/src/hotspot/share/opto/runtime.cpp b/src/hotspot/share/opto/runtime.cpp
index fa84e3bd0b2..83ff5a2905b 100644
--- a/src/hotspot/share/opto/runtime.cpp
+++ b/src/hotspot/share/opto/runtime.cpp
@@ -1475,6 +1475,8 @@ address OptoRuntime::rethrow_C(oopDesc* exception, JavaThread* thread, address r
   }
 #endif
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   thread->set_vm_result(exception);
   // Frame not compiled (handles deoptimization blob)
   return SharedRuntime::raw_exception_handler_for_return_address(thread, ret_pc);
diff --git a/src/hotspot/share/prims/jni.cpp b/src/hotspot/share/prims/jni.cpp
index f0f779e3a87..104f9a9f0e5 100644
--- a/src/hotspot/share/prims/jni.cpp
+++ b/src/hotspot/share/prims/jni.cpp
@@ -3803,6 +3803,7 @@ static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
 
     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
+    Thread::enable_wx_from_write(WXExec);
   } else {
     // If create_vm exits because of a pending exception, exit with that
     // exception.  In the future when we figure out how to reclaim memory,
@@ -3898,6 +3899,7 @@ static jint JNICALL jni_DestroyJavaVM_inner(JavaVM *vm) {
   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
   JavaThread* thread = JavaThread::current();
   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
+  Thread::enable_wx_from_exec(WXWrite);
   if (Threads::destroy_vm()) {
     // Should not change thread state, VM is gone
     vm_created = 0;
@@ -3958,6 +3960,7 @@ static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool dae
   thread->record_stack_base_and_size();
   thread->register_thread_stack_with_NMT();
   thread->initialize_thread_current();
+  thread->init_wx();
 
   if (!os::create_attached_thread(thread)) {
     thread->smr_delete();
@@ -4031,6 +4034,7 @@ static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool dae
   // needed.
 
   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
+  Thread::enable_wx_from_write(WXExec);
 
   // Perform any platform dependent FPU setup
   os::setup_fpu();
@@ -4088,6 +4092,7 @@ jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
   // Safepoint support. Have to do call-back to safepoint code, if in the
   // middle of a safepoint operation
   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
+  Thread::enable_wx_from_exec(WXWrite);
 
   // XXX: Note that JavaThread::exit() call below removes the guards on the
   // stack pages set up via enable_stack_{red,yellow}_zone() calls
diff --git a/src/hotspot/share/prims/jniCheck.cpp b/src/hotspot/share/prims/jniCheck.cpp
index fd9e2e3bab7..10a222954e2 100644
--- a/src/hotspot/share/prims/jniCheck.cpp
+++ b/src/hotspot/share/prims/jniCheck.cpp
@@ -64,6 +64,7 @@
 
 #define IN_VM(source_code)   {                                         \
     {                                                                  \
+      Thread::WXWriteFromExecSetter __wx_write;                        \
       ThreadInVMfromNative __tiv(thr);                                 \
       source_code                                                      \
     }                                                                  \
diff --git a/src/hotspot/share/prims/jvm.cpp b/src/hotspot/share/prims/jvm.cpp
index 0e1a5e0ab9f..3a172f3b23d 100644
--- a/src/hotspot/share/prims/jvm.cpp
+++ b/src/hotspot/share/prims/jvm.cpp
@@ -3560,6 +3560,7 @@ JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
   void *load_result;
   {
     ThreadToNativeFromVM ttnfvm(thread);
+    Thread::WXWriteVerifier wx_write;
     load_result = os::dll_load(name, ebuf, sizeof ebuf);
   }
   if (load_result == NULL) {
diff --git a/src/hotspot/share/prims/jvmtiEnter.xsl b/src/hotspot/share/prims/jvmtiEnter.xsl
index 2ed29d5cb6f..714dbad295e 100644
--- a/src/hotspot/share/prims/jvmtiEnter.xsl
+++ b/src/hotspot/share/prims/jvmtiEnter.xsl
@@ -433,6 +433,8 @@ struct jvmtiInterface_1_ jvmti</xsl:text>
   <xsl:if test="count(@impl)=0 or not(contains(@impl,'innative'))">
     <xsl:text>JavaThread* current_thread = this_thread->as_Java_thread();</xsl:text>
     <xsl:value-of select="$space"/>
+    <xsl:text>Thread::WXWriteFromExecSetter __wx_write;</xsl:text>
+    <xsl:value-of select="$space"/>
     <xsl:text>ThreadInVMfromNative __tiv(current_thread);</xsl:text>
     <xsl:value-of select="$space"/>
     <xsl:text>VM_ENTRY_BASE(jvmtiError, </xsl:text>
diff --git a/src/hotspot/share/prims/jvmtiEnv.cpp b/src/hotspot/share/prims/jvmtiEnv.cpp
index d50f903c7df..037b1b1fcb5 100644
--- a/src/hotspot/share/prims/jvmtiEnv.cpp
+++ b/src/hotspot/share/prims/jvmtiEnv.cpp
@@ -176,6 +176,7 @@ JvmtiEnv::GetThreadLocalStorage(jthread thread, void** data_ptr) {
     // from native so as to resolve the jthread.
 
     ThreadInVMfromNative __tiv(current_thread);
+    Thread::WXExecVerifier __wx_exec;
     VM_ENTRY_BASE(jvmtiError, JvmtiEnv::GetThreadLocalStorage , current_thread)
     debug_only(VMNativeEntryWrapper __vew;)
 
diff --git a/src/hotspot/share/prims/jvmtiExport.cpp b/src/hotspot/share/prims/jvmtiExport.cpp
index bfe5d574a7c..178dee35064 100644
--- a/src/hotspot/share/prims/jvmtiExport.cpp
+++ b/src/hotspot/share/prims/jvmtiExport.cpp
@@ -87,12 +87,14 @@ class JvmtiJavaThreadEventTransition : StackObj {
 private:
   ResourceMark _rm;
   ThreadToNativeFromVM _transition;
+  Thread::WXExecFromWriteSetter _wx_exec;
   HandleMark _hm;
 
 public:
   JvmtiJavaThreadEventTransition(JavaThread *thread) :
     _rm(),
     _transition(thread),
+    _wx_exec(),
     _hm(thread)  {};
 };
 
@@ -102,11 +104,12 @@ class JvmtiThreadEventTransition : StackObj {
 private:
   ResourceMark _rm;
   HandleMark _hm;
+  Thread::WXExecFromWriteSetter _wx_exec;
   JavaThreadState _saved_state;
   JavaThread *_jthread;
 
 public:
-  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm(thread) {
+  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm(thread), _wx_exec() {
     if (thread->is_Java_thread()) {
        _jthread = thread->as_Java_thread();
        _saved_state = _jthread->thread_state();
@@ -396,6 +399,7 @@ JvmtiExport::get_jvmti_interface(JavaVM *jvm, void **penv, jint version) {
     JavaThread* current_thread = JavaThread::current();
     // transition code: native to VM
     ThreadInVMfromNative __tiv(current_thread);
+    Thread::WXExecVerifier __wx_exec;
     VM_ENTRY_BASE(jvmtiEnv*, JvmtiExport::get_jvmti_interface, current_thread)
     debug_only(VMNativeEntryWrapper __vew;)
 
diff --git a/src/hotspot/share/prims/jvmtiImpl.cpp b/src/hotspot/share/prims/jvmtiImpl.cpp
index 68f589ac3d2..70973f6412d 100644
--- a/src/hotspot/share/prims/jvmtiImpl.cpp
+++ b/src/hotspot/share/prims/jvmtiImpl.cpp
@@ -82,6 +82,7 @@ JvmtiAgentThread::start_function_wrapper(JavaThread *thread, TRAPS) {
 void
 JvmtiAgentThread::call_start_function() {
     ThreadToNativeFromVM transition(this);
+    Thread::WXExecFromWriteSetter wx_exec;
     _start_fn(_env->jvmti_external(), jni_environment(), (void*)_start_arg);
 }
 
diff --git a/src/hotspot/share/prims/jvmtiRawMonitor.cpp b/src/hotspot/share/prims/jvmtiRawMonitor.cpp
index 06efea26c5f..f5992080a50 100644
--- a/src/hotspot/share/prims/jvmtiRawMonitor.cpp
+++ b/src/hotspot/share/prims/jvmtiRawMonitor.cpp
@@ -237,6 +237,7 @@ int JvmtiRawMonitor::simple_wait(Thread* self, jlong millis) {
     JavaThread* jt = self->as_Java_thread();
     // Transition to VM so we can check interrupt state
     ThreadInVMfromNative tivm(jt);
+    Thread::WXExecVerifier wx_exec;
     if (jt->is_interrupted(true)) {
         ret = M_INTERRUPTED;
     } else {
@@ -424,6 +425,7 @@ int JvmtiRawMonitor::raw_wait(jlong millis, Thread* self) {
         simple_exit(jt);
         {
           ThreadInVMfromNative tivm(jt);
+          Thread::WXExecVerifier wx_exec;
           {
             ThreadBlockInVM tbivm(jt);
             jt->java_suspend_self();
diff --git a/src/hotspot/share/prims/methodHandles.cpp b/src/hotspot/share/prims/methodHandles.cpp
index 0fe64b027af..a847779b31a 100644
--- a/src/hotspot/share/prims/methodHandles.cpp
+++ b/src/hotspot/share/prims/methodHandles.cpp
@@ -1573,6 +1573,7 @@ JVM_ENTRY(void, JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass MHN_class))
 
   {
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
 
     int status = env->RegisterNatives(MHN_class, MHN_methods, sizeof(MHN_methods)/sizeof(JNINativeMethod));
     guarantee(status == JNI_OK && !env->ExceptionOccurred(),
diff --git a/src/hotspot/share/prims/nativeLookup.cpp b/src/hotspot/share/prims/nativeLookup.cpp
index 9e3e96f2953..f48601593da 100644
--- a/src/hotspot/share/prims/nativeLookup.cpp
+++ b/src/hotspot/share/prims/nativeLookup.cpp
@@ -289,6 +289,7 @@ address NativeLookup::lookup_critical_entry(const methodHandle& method) {
 
   // dll handling requires I/O. Don't do that while in _thread_in_vm (safepoint may get requested).
   ThreadToNativeFromVM thread_in_native(JavaThread::current());
+  Thread::WXWriteVerifier wx_write;
 
   void* dll = dll_load(method);
   address entry = NULL;
diff --git a/src/hotspot/share/prims/perf.cpp b/src/hotspot/share/prims/perf.cpp
index 895c45200cd..84517a8a06c 100644
--- a/src/hotspot/share/prims/perf.cpp
+++ b/src/hotspot/share/prims/perf.cpp
@@ -54,6 +54,8 @@ static char* jstr_to_utf(JNIEnv *env, jstring str, TRAPS) {
     //throw_new(env,"NullPointerException");
   }
 
+  Thread::WXExecFromWriteSetter wx_exec;
+
   int len = env->GetStringUTFLength(str);
   int unicode_len = env->GetStringLength(str);
 
@@ -91,6 +93,7 @@ PERF_ENTRY(jobject, Perf_Attach(JNIEnv *env, jobject unused, jstring user, int v
 
   {
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return env->NewDirectByteBuffer(address, (jlong)capacity);
   }
 
@@ -111,6 +114,7 @@ PERF_ENTRY(void, Perf_Detach(JNIEnv *env, jobject unused, jobject buffer))
   // get buffer address and capacity
   {
    ThreadToNativeFromVM ttnfv(thread);
+   Thread::WXExecFromWriteSetter wx_exec;
    address = env->GetDirectBufferAddress(buffer);
    capacity = env->GetDirectBufferCapacity(buffer);
   }
@@ -175,6 +179,7 @@ PERF_ENTRY(jobject, Perf_CreateLong(JNIEnv *env, jobject perf, jstring name,
 
   {
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return env->NewDirectByteBuffer(lp, sizeof(jlong));
   }
 
@@ -217,6 +222,8 @@ PERF_ENTRY(jobject, Perf_CreateByteArray(JNIEnv *env, jobject perf,
 
     name_utf = jstr_to_utf(env, name, CHECK_NULL);
 
+    Thread::WXExecFromWriteSetter wx_exec;
+
     value_length = env->GetArrayLength(value);
 
     value_local = NEW_RESOURCE_ARRAY(jbyte, value_length + 1);
@@ -258,6 +265,7 @@ PERF_ENTRY(jobject, Perf_CreateByteArray(JNIEnv *env, jobject perf,
 
   {
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return env->NewDirectByteBuffer(cp, maxlength+1);
   }
 
@@ -320,6 +328,7 @@ JVM_ENTRY(void, JVM_RegisterPerfMethods(JNIEnv *env, jclass perfclass))
   PerfWrapper("JVM_RegisterPerfMethods");
   {
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     int ok = env->RegisterNatives(perfclass, perfmethods, sizeof(perfmethods)/sizeof(JNINativeMethod));
     guarantee(ok == 0, "register perf natives");
   }
diff --git a/src/hotspot/share/prims/unsafe.cpp b/src/hotspot/share/prims/unsafe.cpp
index 068078c58c3..528275350a7 100644
--- a/src/hotspot/share/prims/unsafe.cpp
+++ b/src/hotspot/share/prims/unsafe.cpp
@@ -406,6 +406,7 @@ UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcOb
   void* dst = index_oop_from_field_offset_long(dstp, dstOffset);
   {
     GuardUnsafeAccess guard(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     if (StubRoutines::unsafe_arraycopy() != NULL) {
       StubRoutines::UnsafeArrayCopy_stub()(src, dst, sz);
     } else {
@@ -719,6 +720,7 @@ static jclass Unsafe_DefineClass_impl(JNIEnv *env, jstring name, jbyteArray data
 
 UNSAFE_ENTRY(jclass, Unsafe_DefineClass0(JNIEnv *env, jobject unsafe, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd)) {
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
 
   return Unsafe_DefineClass_impl(env, name, data, offset, length, loader, pd);
 } UNSAFE_END
@@ -904,6 +906,7 @@ UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, j
 
 UNSAFE_ENTRY(void, Unsafe_ThrowException(JNIEnv *env, jobject unsafe, jthrowable thr)) {
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   env->Throw(thr);
 } UNSAFE_END
 
@@ -1161,6 +1164,7 @@ static JNINativeMethod jdk_internal_misc_Unsafe_methods[] = {
 
 JVM_ENTRY(void, JVM_RegisterJDKInternalMiscUnsafeMethods(JNIEnv *env, jclass unsafeclass)) {
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
 
   int ok = env->RegisterNatives(unsafeclass, jdk_internal_misc_Unsafe_methods, sizeof(jdk_internal_misc_Unsafe_methods)/sizeof(JNINativeMethod));
   guarantee(ok == 0, "register jdk.internal.misc.Unsafe natives");
diff --git a/src/hotspot/share/prims/whitebox.cpp b/src/hotspot/share/prims/whitebox.cpp
index 6a606cc6400..cf3fb84617a 100644
--- a/src/hotspot/share/prims/whitebox.cpp
+++ b/src/hotspot/share/prims/whitebox.cpp
@@ -836,6 +836,7 @@ WB_END
 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
   assert(method != NULL, "method should not be null");
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   return env->FromReflectedMethod(method);
 }
 
@@ -1211,6 +1212,7 @@ static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, J
     return false;
   }
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, false);
   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);
@@ -1225,6 +1227,7 @@ static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, J
     return false;
   }
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, false);
   JVMFlag* flag = JVMFlag::find_flag(flag_name);
@@ -1265,6 +1268,7 @@ static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
 
 static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, NULL);
   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);
@@ -1286,6 +1290,7 @@ WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
   bool result;
   if (GetVMFlag <bool> (thread, env, name, &result, &JVMFlag::boolAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return booleanBox(thread, env, result);
   }
   return NULL;
@@ -1295,6 +1300,7 @@ WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
   int result;
   if (GetVMFlag <int> (thread, env, name, &result, &JVMFlag::intAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1304,6 +1310,7 @@ WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
   uint result;
   if (GetVMFlag <uint> (thread, env, name, &result, &JVMFlag::uintAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1313,6 +1320,7 @@ WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
   intx result;
   if (GetVMFlag <intx> (thread, env, name, &result, &JVMFlag::intxAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1322,6 +1330,7 @@ WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
   uintx result;
   if (GetVMFlag <uintx> (thread, env, name, &result, &JVMFlag::uintxAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1331,6 +1340,7 @@ WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
   uint64_t result;
   if (GetVMFlag <uint64_t> (thread, env, name, &result, &JVMFlag::uint64_tAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1340,6 +1350,7 @@ WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
   size_t result;
   if (GetVMFlag <size_t> (thread, env, name, &result, &JVMFlag::size_tAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1349,6 +1360,7 @@ WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
   double result;
   if (GetVMFlag <double> (thread, env, name, &result, &JVMFlag::doubleAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return doubleBox(thread, env, result);
   }
   return NULL;
@@ -1358,6 +1370,7 @@ WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
   ccstr ccstrResult;
   if (GetVMFlag <ccstr> (thread, env, name, &ccstrResult, &JVMFlag::ccstrAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     jstring result = env->NewStringUTF(ccstrResult);
     CHECK_JNI_EXCEPTION_(env, NULL);
     return result;
@@ -1407,6 +1420,7 @@ WB_END
 
 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* ccstrValue;
   if (value == NULL) {
     ccstrValue = NULL;
@@ -1418,6 +1432,7 @@ WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring
   ccstr ccstrResult = ccstrValue;
   bool needFree;
   {
+    Thread::WXWriteFromExecSetter wx_write;
     ThreadInVMfromNative ttvfn(thread); // back to VM
     needFree = SetVMFlag <ccstr> (thread, env, name, &ccstrResult, &JVMFlag::ccstrAtPut);
   }
@@ -1483,6 +1498,7 @@ WB_END
 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
   const char* features = VM_Version::features_string();
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   jstring features_string = env->NewStringUTF(features);
 
   CHECK_JNI_EXCEPTION_(env, NULL);
@@ -1555,6 +1571,7 @@ WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jbo
   int insts_size = comp_level == CompLevel_aot ? code->code_end() - code->code_begin() : code->insts_size();
 
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   jclass clazz = env->FindClass(vmSymbols::java_lang_Object()->as_C_string());
   CHECK_JNI_EXCEPTION_(env, NULL);
   result = env->NewObjectArray(5, clazz, NULL);
@@ -1638,6 +1655,7 @@ WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_t
     }
   }
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   jobjectArray result = NULL;
   jclass clazz = env->FindClass(vmSymbols::java_lang_Object()->as_C_string());
   CHECK_JNI_EXCEPTION_(env, NULL);
@@ -1668,6 +1686,7 @@ WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
       "WB_GetCodeBlob: addr is null");
   }
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   CodeBlobStub stub((CodeBlob*) addr);
   return codeBlob2objectArray(thread, env, &stub);
 WB_END
@@ -1837,6 +1856,7 @@ static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jst
   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
   // can't be in VM when we call JNI
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, false);
   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
@@ -1849,6 +1869,7 @@ WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject me
   if (GetMethodOption<bool> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return booleanBox(thread, env, result);
   }
   return NULL;
@@ -1859,6 +1880,7 @@ WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method
   if (GetMethodOption <intx> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1869,6 +1891,7 @@ WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject metho
   if (GetMethodOption <uintx> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1879,6 +1902,7 @@ WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject meth
   if (GetMethodOption <double> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return doubleBox(thread, env, result);
   }
   return NULL;
@@ -1889,6 +1913,7 @@ WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject meth
   if (GetMethodOption <ccstr> (thread, env, method, name, &ccstrResult)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     jstring result = env->NewStringUTF(ccstrResult);
     CHECK_JNI_EXCEPTION_(env, NULL);
     return result;
@@ -1899,6 +1924,7 @@ WB_END
 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
   const char* p = Arguments::get_default_shared_archive_path();
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   jstring path_string = env->NewStringUTF(p);
 
   CHECK_JNI_EXCEPTION_(env, NULL);
@@ -2077,6 +2103,7 @@ bool WhiteBox::lookup_bool(const char* field_name, oop object) {
 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
   ResourceMark rm;
   ThreadToNativeFromVM ttnfv(thread); // can't be in VM when we call JNI
+  Thread::WXExecFromWriteSetter wx_exec;
 
   //  one by one registration natives for exception catching
   jclass no_such_method_error_klass = env->FindClass(vmSymbols::java_lang_NoSuchMethodError()->as_C_string());
@@ -2108,11 +2135,13 @@ void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread,
 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
   // can't be in VM when we call JNI
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* dir = env->GetStringUTFChars(compDirect, NULL);
   CHECK_JNI_EXCEPTION_(env, 0);
   int ret;
   {
     ThreadInVMfromNative ttvfn(thread); // back to VM
+    Thread::WXExecVerifier wx_exec;
     ret = DirectivesParser::parse_string(dir, tty);
   }
   env->ReleaseStringUTFChars(compDirect, dir);
@@ -2133,6 +2162,7 @@ WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstri
 #ifdef LINUX
   // Can't be in VM when we call JNI.
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* lf = env->GetStringUTFChars(libfile, NULL);
   CHECK_JNI_EXCEPTION_(env, 0);
   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
@@ -2154,6 +2184,7 @@ WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,
   jint ret = 0;
 #ifdef LINUX
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* p_cgroups = env->GetStringUTFChars(proc_cgroups, NULL);
   CHECK_JNI_EXCEPTION_(env, 0);
   const char* p_s_cgroup = env->GetStringUTFChars(proc_self_cgroup, NULL);
diff --git a/src/hotspot/share/runtime/deoptimization.cpp b/src/hotspot/share/runtime/deoptimization.cpp
index 7e9d23e9c6a..13c51da227b 100644
--- a/src/hotspot/share/runtime/deoptimization.cpp
+++ b/src/hotspot/share/runtime/deoptimization.cpp
@@ -2326,6 +2326,7 @@ Deoptimization::UnrollBlock* Deoptimization::uncommon_trap(JavaThread* thread, j
     // This enters VM and may safepoint
     uncommon_trap_inner(thread, trap_request);
   }
+  Thread::WXWriteFromExecSetter wx_write;
   return fetch_unroll_info_helper(thread, exec_mode);
 }
 
diff --git a/src/hotspot/share/runtime/interfaceSupport.inline.hpp b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
index cb7154f7192..31459f5298a 100644
--- a/src/hotspot/share/runtime/interfaceSupport.inline.hpp
+++ b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
@@ -305,8 +305,9 @@ class ThreadBlockInVMWithDeadlockCheck : public ThreadStateTransition {
 // from being installed on vm exit in situations where we can't tolerate them.
 // See bugs: 4324348, 4854693, 4998314, 5040492, 5050705.
 class ThreadInVMfromJavaNoAsyncException : public ThreadStateTransition {
+  Thread::WXWriteVerifier _wx_write;
  public:
-  ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread) {
+  ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread), _wx_write() {
     trans_from_java(_thread_in_vm);
   }
   ~ThreadInVMfromJavaNoAsyncException()  {
@@ -392,6 +393,7 @@ class RuntimeHistogramElement : public HistogramElement {
 
 #define JRT_ENTRY(result_type, header)                               \
   result_type header {                                               \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromJava __tiv(thread);                                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -418,6 +420,7 @@ class RuntimeHistogramElement : public HistogramElement {
 
 #define JRT_ENTRY_NO_ASYNC(result_type, header)                      \
   result_type header {                                               \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -427,6 +430,7 @@ class RuntimeHistogramElement : public HistogramElement {
 #define JRT_BLOCK_ENTRY(result_type, header)                         \
   result_type header {                                               \
     TRACE_CALL(result_type, header)                                  \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     HandleMarkCleaner __hm(thread);
 
 #define JRT_BLOCK                                                    \
@@ -456,6 +460,7 @@ extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
     assert( !VerifyJNIEnvThread || (thread == Thread::current()), "JNIEnv is only valid in same thread"); \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -466,6 +471,7 @@ extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
     assert( !VerifyJNIEnvThread || (thread == Thread::current()), "JNIEnv is only valid in same thread"); \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     VM_LEAF_BASE(result_type, header)
 
 
@@ -480,6 +486,7 @@ extern "C" {                                                         \
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -489,6 +496,7 @@ extern "C" {                                                         \
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread = JavaThread::current();                      \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -498,6 +506,7 @@ extern "C" {                                                         \
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     VM_Exit::block_if_vm_exited();                                   \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     VM_LEAF_BASE(result_type, header)
 
 
diff --git a/src/hotspot/share/runtime/javaCalls.cpp b/src/hotspot/share/runtime/javaCalls.cpp
index 72a87d6b9fc..e2eff59916d 100644
--- a/src/hotspot/share/runtime/javaCalls.cpp
+++ b/src/hotspot/share/runtime/javaCalls.cpp
@@ -78,7 +78,6 @@ JavaCallWrapper::JavaCallWrapper(const methodHandle& callee_method, Handle recei
     }
   }
 
-
   // Make sure to set the oop's after the thread transition - since we can block there. No one is GC'ing
   // the JavaCallWrapper before the entry frame is on the stack.
   _callee_method = callee_method();
@@ -112,12 +111,16 @@ JavaCallWrapper::JavaCallWrapper(const methodHandle& callee_method, Handle recei
   if (_anchor.last_Java_sp() == NULL) {
     _thread->record_base_of_stack_pointer();
   }
+
+  Thread::enable_wx_from_write(WXExec);
 }
 
 
 JavaCallWrapper::~JavaCallWrapper() {
   assert(_thread == JavaThread::current(), "must still be the same thread");
 
+  Thread::enable_wx_from_exec(WXWrite);
+
   // restore previous handle block & Java frame linkage
   JNIHandleBlock *_old_handles = _thread->active_handles();
   _thread->set_active_handles(_handles);
diff --git a/src/hotspot/share/runtime/objectMonitor.cpp b/src/hotspot/share/runtime/objectMonitor.cpp
index b558e3f6252..dd9bbf29b76 100644
--- a/src/hotspot/share/runtime/objectMonitor.cpp
+++ b/src/hotspot/share/runtime/objectMonitor.cpp
@@ -42,7 +42,7 @@
 #include "runtime/osThread.hpp"
 #include "runtime/safepointMechanism.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "services/threadService.hpp"
 #include "utilities/dtrace.hpp"
diff --git a/src/hotspot/share/runtime/os.cpp b/src/hotspot/share/runtime/os.cpp
index df7be196d96..46562d6a5fa 100644
--- a/src/hotspot/share/runtime/os.cpp
+++ b/src/hotspot/share/runtime/os.cpp
@@ -54,7 +54,7 @@
 #include "runtime/mutexLocker.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 #include "runtime/vm_version.hpp"
diff --git a/src/hotspot/share/runtime/os.hpp b/src/hotspot/share/runtime/os.hpp
index 7d9a91f5ffa..31b953814d1 100644
--- a/src/hotspot/share/runtime/os.hpp
+++ b/src/hotspot/share/runtime/os.hpp
@@ -76,6 +76,11 @@ enum ThreadPriority {        // JLS 20.20.1-3
   CriticalPriority = 11      // Critical thread priority
 };
 
+enum WXMode {
+  WXWrite,
+  WXExec
+};
+
 // Executable parameter flag for os::commit_memory() and
 // os::commit_memory_or_exit().
 const bool ExecMem = true;
@@ -889,6 +894,12 @@ class os: AllStatic {
     bool _done;
   };
 
+  // If the JVM is running in W^X mode, enable write or execute access to
+  // writeable and executable pages. No-op otherwise.
+  static inline void current_thread_enable_wx(WXMode mode) {
+    current_thread_enable_wx_impl(mode);
+  }
+
 #ifndef _WINDOWS
   // Suspend/resume support
   // Protocol:
@@ -958,7 +969,6 @@ class os: AllStatic {
   };
 #endif // !WINDOWS
 
-
  protected:
   static volatile unsigned int _rand_seed;    // seed for random number generator
   static int _processor_count;                // number of processors
diff --git a/src/hotspot/share/runtime/safepoint.cpp b/src/hotspot/share/runtime/safepoint.cpp
index bc25b4032fb..cde287cd4b3 100644
--- a/src/hotspot/share/runtime/safepoint.cpp
+++ b/src/hotspot/share/runtime/safepoint.cpp
@@ -784,6 +784,8 @@ void SafepointSynchronize::block(JavaThread *thread) {
 void SafepointSynchronize::handle_polling_page_exception(JavaThread *thread) {
   assert(thread->thread_state() == _thread_in_Java, "should come from Java code");
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   if (log_is_enabled(Info, safepoint, stats)) {
     Atomic::inc(&_nof_threads_hit_polling_page);
   }
diff --git a/src/hotspot/share/runtime/sharedRuntime.cpp b/src/hotspot/share/runtime/sharedRuntime.cpp
index 63922c34c0f..19c9bbe0a3b 100644
--- a/src/hotspot/share/runtime/sharedRuntime.cpp
+++ b/src/hotspot/share/runtime/sharedRuntime.cpp
@@ -518,6 +518,7 @@ address SharedRuntime::raw_exception_handler_for_return_address(JavaThread* thre
 
 
 JRT_LEAF(address, SharedRuntime::exception_handler_for_return_address(JavaThread* thread, address return_address))
+  Thread::WXWriteFromExecSetter wx_write;
   return raw_exception_handler_for_return_address(thread, return_address);
 JRT_END
 
@@ -1907,6 +1908,8 @@ bool SharedRuntime::should_fixup_call_destination(address destination, address e
 JRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))
   Method* moop(method);
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   address entry_point = moop->from_compiled_entry_no_trampoline();
 
   // It's possible that deoptimization can occur at a call site which hasn't
diff --git a/src/hotspot/share/runtime/stubRoutines.cpp b/src/hotspot/share/runtime/stubRoutines.cpp
index 5fd47ff57ac..f382ed2c54c 100644
--- a/src/hotspot/share/runtime/stubRoutines.cpp
+++ b/src/hotspot/share/runtime/stubRoutines.cpp
@@ -31,7 +31,7 @@
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/timerTrace.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "utilities/align.hpp"
 #include "utilities/copy.hpp"
 #include "utilities/vmError.hpp"
@@ -319,6 +319,8 @@ void StubRoutines::initialize2() {
 
 #ifdef ASSERT
 
+  os::current_thread_enable_wx(WXExec);
+
 #define TEST_ARRAYCOPY(type)                                                    \
   test_arraycopy_func(          type##_arraycopy(),          sizeof(type));     \
   test_arraycopy_func(          type##_disjoint_arraycopy(), sizeof(type));     \
@@ -399,6 +401,8 @@ void StubRoutines::initialize2() {
   test_safefetchN();
 #endif
 
+  os::current_thread_enable_wx(WXWrite);
+
 #endif
 }
 
diff --git a/src/hotspot/share/runtime/stubRoutines.hpp b/src/hotspot/share/runtime/stubRoutines.hpp
index 6af4caaaa14..5e84e9aafbe 100644
--- a/src/hotspot/share/runtime/stubRoutines.hpp
+++ b/src/hotspot/share/runtime/stubRoutines.hpp
@@ -487,24 +487,4 @@ class StubRoutines: AllStatic {
   static void arrayof_oop_copy_uninit(HeapWord* src, HeapWord* dest, size_t count);
 };
 
-// Safefetch allows to load a value from a location that's not known
-// to be valid. If the load causes a fault, the error value is returned.
-inline int SafeFetch32(int* adr, int errValue) {
-  assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
-  return StubRoutines::SafeFetch32_stub()(adr, errValue);
-}
-inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
-  assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
-  return StubRoutines::SafeFetchN_stub()(adr, errValue);
-}
-
-
-// returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)
-inline bool CanUseSafeFetch32() {
-  return StubRoutines::SafeFetch32_stub() ? true : false;
-}
-
-inline bool CanUseSafeFetchN() {
-  return StubRoutines::SafeFetchN_stub() ? true : false;
-}
 #endif // SHARE_RUNTIME_STUBROUTINES_HPP
diff --git a/src/hotspot/share/runtime/stubRoutines.inline.hpp b/src/hotspot/share/runtime/stubRoutines.inline.hpp
new file mode 100644
index 00000000000..4ce59480300
--- /dev/null
+++ b/src/hotspot/share/runtime/stubRoutines.inline.hpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
+#define SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
+
+#include <runtime/thread.hpp>
+#include <runtime/stubRoutines.hpp>
+
+// Safefetch allows to load a value from a location that's not known
+// to be valid. If the load causes a fault, the error value is returned.
+inline int SafeFetch32(int* adr, int errValue) {
+  assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
+  Thread::WXExecFromWriteSetter wx_exec;
+  return StubRoutines::SafeFetch32_stub()(adr, errValue);
+}
+inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
+  assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
+  Thread::WXExecFromWriteSetter wx_exec;
+  return StubRoutines::SafeFetchN_stub()(adr, errValue);
+}
+
+
+// returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)
+inline bool CanUseSafeFetch32() {
+  return StubRoutines::SafeFetch32_stub() ? true : false;
+}
+
+inline bool CanUseSafeFetchN() {
+  return StubRoutines::SafeFetchN_stub() ? true : false;
+}
+
+#endif // SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
diff --git a/src/hotspot/share/runtime/thread.cpp b/src/hotspot/share/runtime/thread.cpp
index 5f8c9100927..121545c22b7 100644
--- a/src/hotspot/share/runtime/thread.cpp
+++ b/src/hotspot/share/runtime/thread.cpp
@@ -325,6 +325,8 @@ Thread::Thread() {
     // If the main thread creates other threads before the barrier set that is an error.
     assert(Thread::current_or_null() == NULL, "creating thread before barrier set");
   }
+
+  DEBUG_ONLY(_wx_init = false);
 }
 
 void Thread::initialize_thread_current() {
@@ -379,6 +381,8 @@ void Thread::call_run() {
 
   register_thread_stack_with_NMT();
 
+  this->init_wx();
+
   JFR_ONLY(Jfr::on_thread_start(this);)
 
   log_debug(os, thread)("Thread " UINTX_FORMAT " stack dimensions: "
@@ -2670,6 +2674,8 @@ void JavaThread::check_safepoint_and_suspend_for_native_trans(JavaThread *thread
 // Note only the native==>VM/Java barriers can call this function and when
 // thread state is _thread_in_native_trans.
 void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {
+  Thread::WXWriteFromExecSetter wx_write;
+
   check_safepoint_and_suspend_for_native_trans(thread);
 
   if (thread->has_async_exception()) {
@@ -2689,6 +2695,8 @@ void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {
 void JavaThread::check_special_condition_for_native_trans_and_transition(JavaThread *thread) {
   check_special_condition_for_native_trans(thread);
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   // Finish the transition
   thread->set_thread_state(_thread_in_Java);
 
@@ -3809,6 +3817,8 @@ jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) {
   // Initialize the os module
   os::init();
 
+  os::current_thread_enable_wx(WXWrite);
+
   // Record VM creation timing statistics
   TraceVmCreationTime create_vm_timer;
   create_vm_timer.start();
@@ -3912,6 +3922,7 @@ jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) {
   main_thread->record_stack_base_and_size();
   main_thread->register_thread_stack_with_NMT();
   main_thread->set_active_handles(JNIHandleBlock::allocate_block());
+  main_thread->init_wx();
 
   if (!main_thread->set_as_starting_thread()) {
     vm_shutdown_during_initialization(
@@ -4344,6 +4355,7 @@ void Threads::shutdown_vm_agents() {
     if (unload_entry != NULL) {
       JavaThread* thread = JavaThread::current();
       ThreadToNativeFromVM ttn(thread);
+      Thread::WXExecFromWriteSetter wx_exec;
       HandleMark hm(thread);
       (*unload_entry)(&main_vm);
     }
@@ -4363,6 +4375,7 @@ void Threads::create_vm_init_libraries() {
       // Invoke the JVM_OnLoad function
       JavaThread* thread = JavaThread::current();
       ThreadToNativeFromVM ttn(thread);
+      Thread::WXExecFromWriteSetter wx_exec;
       HandleMark hm(thread);
       jint err = (*on_load_entry)(&main_vm, agent->options(), NULL);
       if (err != JNI_OK) {
diff --git a/src/hotspot/share/runtime/thread.hpp b/src/hotspot/share/runtime/thread.hpp
index 0c4668ce9fc..24e901761fe 100644
--- a/src/hotspot/share/runtime/thread.hpp
+++ b/src/hotspot/share/runtime/thread.hpp
@@ -850,6 +850,81 @@ class Thread: public ThreadShadow {
   static void SpinRelease(volatile int * Lock);
   static void muxAcquire(volatile intptr_t * Lock, const char * Name);
   static void muxRelease(volatile intptr_t * Lock);
+
+private:
+#ifdef ASSERT
+  bool _wx_init;
+  WXMode _wx_state;
+  static inline void verify_wx_init(WXMode state) {
+    Thread* current = Thread::current();
+    assert(!current->_wx_init, "second init");
+    current->_wx_init = true;
+    current->_wx_state = state;
+  }
+  static inline void verify_wx_transition(WXMode from, WXMode to) {
+    Thread* current = Thread::current();
+    assert(current->_wx_init, "no init");
+    assert(current->_wx_state == from, "wrong state");
+    current->_wx_init = true;
+    current->_wx_state = to;
+  }
+  static inline void verify_wx_state(WXMode now) {
+    Thread* current = Thread::current();
+    assert(current->_wx_init, "no init");
+    assert(current->_wx_state == now, "wrong state");
+  }
+#else
+  static inline void verify_wx_init(WXMode state) { }
+  static inline void verify_wx_transition(WXMode from, WXMode to) { }
+  static inline void verify_wx_state(WXMode now) { }
+#endif // ASSERT
+public:
+  void init_wx() {
+    WXMode init_mode = WXWrite;
+    verify_wx_init(init_mode);
+    os::current_thread_enable_wx(init_mode);
+  }
+  static inline void enable_wx_from_write(WXMode to) {
+    verify_wx_transition(WXWrite, to);
+    os::current_thread_enable_wx(to);
+  }
+  static inline void enable_wx_from_exec(WXMode to) {
+    verify_wx_transition(WXExec, to);
+    os::current_thread_enable_wx(to);
+  }
+
+  class WXWriteFromExecSetter {
+  public:
+    WXWriteFromExecSetter() {
+      enable_wx_from_exec(WXWrite);
+    }
+    ~WXWriteFromExecSetter() {
+      enable_wx_from_write(WXExec);
+    }
+  };
+
+  class WXExecFromWriteSetter {
+  public:
+    WXExecFromWriteSetter() {
+      enable_wx_from_write(WXExec);
+    }
+    ~WXExecFromWriteSetter() {
+      enable_wx_from_exec(WXWrite);
+    }
+  };
+
+  class WXWriteVerifier {
+  public:
+    WXWriteVerifier() {
+      verify_wx_state(WXWrite);
+    }
+  };
+  class WXExecVerifier {
+  public:
+    WXExecVerifier() {
+      verify_wx_state(WXExec);
+    }
+  };
 };
 
 // Inline implementation of Thread::current()
diff --git a/src/hotspot/share/services/diagnosticCommand.cpp b/src/hotspot/share/services/diagnosticCommand.cpp
index e884a3f3580..e0032886e02 100644
--- a/src/hotspot/share/services/diagnosticCommand.cpp
+++ b/src/hotspot/share/services/diagnosticCommand.cpp
@@ -1076,6 +1076,7 @@ void DebugOnCmdStartDCmd::execute(DCmdSource source, TRAPS) {
   JavaThread* thread = THREAD->as_Java_thread();
   jthread jt = JNIHandles::make_local(thread->threadObj());
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   const char *error = "Could not find jdwp agent.";
 
   if (!dvc_start_ptr) {
diff --git a/src/hotspot/share/utilities/vmError.cpp b/src/hotspot/share/utilities/vmError.cpp
index f767cdad803..33ae7f30a34 100644
--- a/src/hotspot/share/utilities/vmError.cpp
+++ b/src/hotspot/share/utilities/vmError.cpp
@@ -42,6 +42,7 @@
 #include "runtime/init.hpp"
 #include "runtime/os.hpp"
 #include "runtime/safepointMechanism.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 #include "runtime/vmThread.hpp"

From 80847e98f410210c7825f505f714fc1c3c90dbaa Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@openjdk.org>
Date: Fri, 11 Sep 2020 01:08:33 +0300
Subject: [PATCH 06/94] JDK-8253839: Update tests and JDK code for
 macOS/Aarch64

ZULU-18251, ZULU-18290
---
 .../nsk/share/jdi/ArgumentHandler.java           | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/ArgumentHandler.java b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/ArgumentHandler.java
index ebf8ae0d27d..c1c5ff6e740 100644
--- a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/ArgumentHandler.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/ArgumentHandler.java
@@ -531,6 +531,8 @@ protected void checkOptions() {
         {"linux-s390x",     "com.sun.jdi.SharedMemoryAttach"},
         {"macosx-amd64",    "com.sun.jdi.SharedMemoryAttach"},
         {"mac-x64",         "com.sun.jdi.SharedMemoryAttach"},
+        {"macosx-aarch64",  "com.sun.jdi.SharedMemoryAttach"},
+        {"mac-aarch64",     "com.sun.jdi.SharedMemoryAttach"},
         {"aix-ppc64",       "com.sun.jdi.SharedMemoryAttach"},
 
             // listening connectors
@@ -554,6 +556,8 @@ protected void checkOptions() {
         {"linux-s390x",     "com.sun.jdi.SharedMemoryListen"},
         {"macosx-amd64",    "com.sun.jdi.SharedMemoryListen"},
         {"mac-x64",         "com.sun.jdi.SharedMemoryListen"},
+        {"macosx-aarch64",  "com.sun.jdi.SharedMemoryListen"},
+        {"mac-aarch64",     "com.sun.jdi.SharedMemoryListen"},
         {"aix-ppc64",       "com.sun.jdi.SharedMemoryListen"},
 
             // launching connectors
@@ -611,8 +615,14 @@ protected void checkOptions() {
         {"macosx-amd64",     "com.sun.jdi.CommandLineLaunch", "dt_shmem"},
         {"macosx-amd64",     "com.sun.jdi.RawCommandLineLaunch", "dt_shmem"},
 
-        {"mac-x64",         "com.sun.jdi.CommandLineLaunch", "dt_shmem"},
-        {"mac-x64",         "com.sun.jdi.RawCommandLineLaunch", "dt_shmem"},
+        {"mac-x64",          "com.sun.jdi.CommandLineLaunch", "dt_shmem"},
+        {"mac-x64",          "com.sun.jdi.RawCommandLineLaunch", "dt_shmem"},
+
+        {"macosx-aarch64",   "com.sun.jdi.CommandLineLaunch", "dt_shmem"},
+        {"macosx-aarch64",   "com.sun.jdi.RawCommandLineLaunch", "dt_shmem"},
+
+        {"mac-aarch64",      "com.sun.jdi.CommandLineLaunch", "dt_shmem"},
+        {"mac-aarch64",      "com.sun.jdi.RawCommandLineLaunch", "dt_shmem"},
 
         {"aix-ppc64",       "com.sun.jdi.CommandLineLaunch", "dt_shmem"},
         {"aix-ppc64",       "com.sun.jdi.RawCommandLineLaunch", "dt_shmem"},
@@ -629,6 +639,8 @@ protected void checkOptions() {
         {"linux-s390x",     "dt_shmem"},
         {"macosx-amd64",    "dt_shmem"},
         {"mac-x64",         "dt_shmem"},
+        {"macosx-aarch64",  "dt_shmem"},
+        {"mac-aarch64",     "dt_shmem"},
         {"aix-ppc64",       "dt_shmem"},
     };
 }

From f9cdb3ffb5123ebbcd7a5ab3eee3db374b165f2f Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Wed, 30 Sep 2020 07:19:57 -0700
Subject: [PATCH 07/94] JDK-8253819: Copy linux_aarch64 to bsd_aarch64

---
 .../os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp | 105 +++
 .../bsd_aarch64/bytes_bsd_aarch64.inline.hpp  |  45 ++
 .../bsd_aarch64/copy_bsd_aarch64.inline.hpp   | 188 ++++++
 .../os_cpu/bsd_aarch64/copy_bsd_aarch64.s     | 236 +++++++
 .../bsd_aarch64/gc/z/zSyscall_bsd_aarch64.hpp |  40 ++
 .../bsd_aarch64/globals_bsd_aarch64.hpp       |  46 ++
 .../bsd_aarch64/orderAccess_bsd_aarch64.hpp   |  58 ++
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.cpp     | 611 ++++++++++++++++++
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.hpp     |  48 ++
 .../prefetch_bsd_aarch64.inline.hpp           |  42 ++
 .../os_cpu/bsd_aarch64/threadLS_bsd_aarch64.s |  44 ++
 .../os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp |  99 +++
 .../os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp |  80 +++
 .../bsd_aarch64/vmStructs_bsd_aarch64.hpp     |  55 ++
 .../bsd_aarch64/vm_version_bsd_aarch64.cpp    | 166 +++++
 15 files changed, 1863 insertions(+)
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/gc/z/zSyscall_bsd_aarch64.hpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/threadLS_bsd_aarch64.s
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
 create mode 100644 src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp

diff --git a/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
new file mode 100644
index 00000000000..cd8807c6a79
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP
+
+#include "runtime/vm_version.hpp"
+
+// Implementation of class atomic
+// Note that memory_order_conservative requires a full barrier after atomic stores.
+// See https://patchwork.kernel.org/patch/3575821/
+
+template<size_t byte_size>
+struct Atomic::PlatformAdd {
+  template<typename D, typename I>
+  D add_and_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {
+    D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);
+    FULL_MEM_BARRIER;
+    return res;
+  }
+
+  template<typename D, typename I>
+  D fetch_and_add(D volatile* dest, I add_value, atomic_memory_order order) const {
+    return add_and_fetch(dest, add_value, order) - add_value;
+  }
+};
+
+template<size_t byte_size>
+template<typename T>
+inline T Atomic::PlatformXchg<byte_size>::operator()(T volatile* dest,
+                                                     T exchange_value,
+                                                     atomic_memory_order order) const {
+  STATIC_ASSERT(byte_size == sizeof(T));
+  T res = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELEASE);
+  FULL_MEM_BARRIER;
+  return res;
+}
+
+// __attribute__((unused)) on dest is to get rid of spurious GCC warnings.
+template<size_t byte_size>
+template<typename T>
+inline T Atomic::PlatformCmpxchg<byte_size>::operator()(T volatile* dest __attribute__((unused)),
+                                                        T compare_value,
+                                                        T exchange_value,
+                                                        atomic_memory_order order) const {
+  STATIC_ASSERT(byte_size == sizeof(T));
+  if (order == memory_order_relaxed) {
+    T value = compare_value;
+    __atomic_compare_exchange(dest, &value, &exchange_value, /*weak*/false,
+                              __ATOMIC_RELAXED, __ATOMIC_RELAXED);
+    return value;
+  } else {
+    T value = compare_value;
+    FULL_MEM_BARRIER;
+    __atomic_compare_exchange(dest, &value, &exchange_value, /*weak*/false,
+                              __ATOMIC_RELAXED, __ATOMIC_RELAXED);
+    FULL_MEM_BARRIER;
+    return value;
+  }
+}
+
+template<size_t byte_size>
+struct Atomic::PlatformOrderedLoad<byte_size, X_ACQUIRE>
+{
+  template <typename T>
+  T operator()(const volatile T* p) const { T data; __atomic_load(const_cast<T*>(p), &data, __ATOMIC_ACQUIRE); return data; }
+};
+
+template<size_t byte_size>
+struct Atomic::PlatformOrderedStore<byte_size, RELEASE_X>
+{
+  template <typename T>
+  void operator()(volatile T* p, T v) const { __atomic_store(const_cast<T*>(p), &v, __ATOMIC_RELEASE); }
+};
+
+template<size_t byte_size>
+struct Atomic::PlatformOrderedStore<byte_size, RELEASE_X_FENCE>
+{
+  template <typename T>
+  void operator()(volatile T* p, T v) const { release_store(p, v); OrderAccess::fence(); }
+};
+
+#endif // OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp b/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
new file mode 100644
index 00000000000..6dea3134a8f
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_BYTES_BSD_AARCH64_INLINE_HPP
+#define OS_CPU_BSD_AARCH64_BYTES_BSD_AARCH64_INLINE_HPP
+
+#include <byteswap.h>
+
+// Efficient swapping of data bytes from Java byte
+// ordering to native byte ordering and vice versa.
+inline u2   Bytes::swap_u2(u2 x) {
+  return bswap_16(x);
+}
+
+inline u4   Bytes::swap_u4(u4 x) {
+  return bswap_32(x);
+}
+
+inline u8 Bytes::swap_u8(u8 x) {
+  return bswap_64(x);
+}
+
+#endif // OS_CPU_BSD_AARCH64_BYTES_BSD_AARCH64_INLINE_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
new file mode 100644
index 00000000000..ab4960aefd0
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
@@ -0,0 +1,188 @@
+/*
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_COPY_BSD_AARCH64_INLINE_HPP
+#define OS_CPU_BSD_AARCH64_COPY_BSD_AARCH64_INLINE_HPP
+
+#define COPY_SMALL(from, to, count)                                     \
+{                                                                       \
+        long tmp0, tmp1, tmp2, tmp3;                                    \
+        long tmp4, tmp5, tmp6, tmp7;                                    \
+  __asm volatile(                                                       \
+"       adr     %[t0], 0f;"                                             \
+"       add     %[t0], %[t0], %[cnt], lsl #5;"                          \
+"       br      %[t0];"                                                 \
+"       .align  5;"                                                     \
+"0:"                                                                    \
+"       b       1f;"                                                    \
+"       .align  5;"                                                     \
+"       ldr     %[t0], [%[s], #0];"                                     \
+"       str     %[t0], [%[d], #0];"                                     \
+"       b       1f;"                                                    \
+"       .align  5;"                                                     \
+"       ldp     %[t0], %[t1], [%[s], #0];"                              \
+"       stp     %[t0], %[t1], [%[d], #0];"                              \
+"       b       1f;"                                                    \
+"       .align  5;"                                                     \
+"       ldp     %[t0], %[t1], [%[s], #0];"                              \
+"       ldr     %[t2], [%[s], #16];"                                    \
+"       stp     %[t0], %[t1], [%[d], #0];"                              \
+"       str     %[t2], [%[d], #16];"                                    \
+"       b       1f;"                                                    \
+"       .align  5;"                                                     \
+"       ldp     %[t0], %[t1], [%[s], #0];"                              \
+"       ldp     %[t2], %[t3], [%[s], #16];"                             \
+"       stp     %[t0], %[t1], [%[d], #0];"                              \
+"       stp     %[t2], %[t3], [%[d], #16];"                             \
+"       b       1f;"                                                    \
+"       .align  5;"                                                     \
+"       ldp     %[t0], %[t1], [%[s], #0];"                              \
+"       ldp     %[t2], %[t3], [%[s], #16];"                             \
+"       ldr     %[t4], [%[s], #32];"                                    \
+"       stp     %[t0], %[t1], [%[d], #0];"                              \
+"       stp     %[t2], %[t3], [%[d], #16];"                             \
+"       str     %[t4], [%[d], #32];"                                    \
+"       b       1f;"                                                    \
+"       .align  5;"                                                     \
+"       ldp     %[t0], %[t1], [%[s], #0];"                              \
+"       ldp     %[t2], %[t3], [%[s], #16];"                             \
+"       ldp     %[t4], %[t5], [%[s], #32];"                             \
+"2:"                                                                    \
+"       stp     %[t0], %[t1], [%[d], #0];"                              \
+"       stp     %[t2], %[t3], [%[d], #16];"                             \
+"       stp     %[t4], %[t5], [%[d], #32];"                             \
+"       b       1f;"                                                    \
+"       .align  5;"                                                     \
+"       ldr     %[t6], [%[s], #0];"                                     \
+"       ldp     %[t0], %[t1], [%[s], #8];"                              \
+"       ldp     %[t2], %[t3], [%[s], #24];"                             \
+"       ldp     %[t4], %[t5], [%[s], #40];"                             \
+"       str     %[t6], [%[d]], #8;"                                     \
+"       b       2b;"                                                    \
+"       .align  5;"                                                     \
+"       ldp     %[t0], %[t1], [%[s], #0];"                              \
+"       ldp     %[t2], %[t3], [%[s], #16];"                             \
+"       ldp     %[t4], %[t5], [%[s], #32];"                             \
+"       ldp     %[t6], %[t7], [%[s], #48];"                             \
+"       stp     %[t0], %[t1], [%[d], #0];"                              \
+"       stp     %[t2], %[t3], [%[d], #16];"                             \
+"       stp     %[t4], %[t5], [%[d], #32];"                             \
+"       stp     %[t6], %[t7], [%[d], #48];"                             \
+"1:"                                                                    \
+                                                                        \
+  : [s]"+r"(from), [d]"+r"(to), [cnt]"+r"(count),                       \
+    [t0]"=&r"(tmp0), [t1]"=&r"(tmp1), [t2]"=&r"(tmp2), [t3]"=&r"(tmp3), \
+    [t4]"=&r"(tmp4), [t5]"=&r"(tmp5), [t6]"=&r"(tmp6), [t7]"=&r"(tmp7)  \
+  :                                                                     \
+  : "memory", "cc");                                                    \
+}
+
+static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {
+  __asm volatile( "prfm pldl1strm, [%[s], #0];" :: [s]"r"(from) : "memory");
+  if (__builtin_expect(count <= 8, 1)) {
+    COPY_SMALL(from, to, count);
+    return;
+  }
+  _Copy_conjoint_words(from, to, count);
+}
+
+static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {
+  if (__builtin_constant_p(count)) {
+    memcpy(to, from, count * sizeof(HeapWord));
+    return;
+  }
+  __asm volatile( "prfm pldl1strm, [%[s], #0];" :: [s]"r"(from) : "memory");
+  if (__builtin_expect(count <= 8, 1)) {
+    COPY_SMALL(from, to, count);
+    return;
+  }
+  _Copy_disjoint_words(from, to, count);
+}
+
+static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {
+  __asm volatile( "prfm pldl1strm, [%[s], #0];" :: [s]"r"(from) : "memory");
+  if (__builtin_expect(count <= 8, 1)) {
+    COPY_SMALL(from, to, count);
+    return;
+  }
+  _Copy_disjoint_words(from, to, count);
+}
+
+static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {
+  pd_conjoint_words(from, to, count);
+}
+
+static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {
+  pd_disjoint_words(from, to, count);
+}
+
+static void pd_conjoint_bytes(const void* from, void* to, size_t count) {
+  (void)memmove(to, from, count);
+}
+
+static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {
+  pd_conjoint_bytes(from, to, count);
+}
+
+static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {
+  _Copy_conjoint_jshorts_atomic(from, to, count);
+}
+
+static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {
+  _Copy_conjoint_jints_atomic(from, to, count);
+}
+
+static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {
+  _Copy_conjoint_jlongs_atomic(from, to, count);
+}
+
+static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {
+  assert(BytesPerLong == BytesPerOop, "jlongs and oops must be the same size");
+  _Copy_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);
+}
+
+static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {
+  _Copy_arrayof_conjoint_bytes(from, to, count);
+}
+
+static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {
+  _Copy_arrayof_conjoint_jshorts(from, to, count);
+}
+
+static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {
+   _Copy_arrayof_conjoint_jints(from, to, count);
+}
+
+static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {
+  _Copy_arrayof_conjoint_jlongs(from, to, count);
+}
+
+static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {
+  assert(!UseCompressedOops, "foo!");
+  assert(BytesPerLong == BytesPerOop, "jlongs and oops must be the same size");
+  _Copy_arrayof_conjoint_jlongs(from, to, count);
+}
+
+#endif // OS_CPU_BSD_AARCH64_COPY_BSD_AARCH64_INLINE_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s
new file mode 100644
index 00000000000..4b8ed597c59
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s
@@ -0,0 +1,236 @@
+/*
+ * Copyright (c) 2016, Linaro Ltd. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+        .global _Copy_conjoint_words
+        .global _Copy_disjoint_words
+
+s       .req    x0
+d       .req    x1
+count   .req    x2
+t0      .req    x3
+t1      .req    x4
+t2      .req    x5
+t3      .req    x6
+t4      .req    x7
+t5      .req    x8
+t6      .req    x9
+t7      .req    x10
+
+        .align  6
+_Copy_disjoint_words:
+        // Ensure 2 word aligned
+        tbz     s, #3, fwd_copy_aligned
+        ldr     t0, [s], #8
+        str     t0, [d], #8
+        sub     count, count, #1
+
+fwd_copy_aligned:
+        // Bias s & d so we only pre index on the last copy
+        sub     s, s, #16
+        sub     d, d, #16
+
+        ldp     t0, t1, [s, #16]
+        ldp     t2, t3, [s, #32]
+        ldp     t4, t5, [s, #48]
+        ldp     t6, t7, [s, #64]!
+
+        subs    count, count, #16
+        blo     fwd_copy_drain
+
+fwd_copy_again:
+        prfm    pldl1keep, [s, #256]
+        stp     t0, t1, [d, #16]
+        ldp     t0, t1, [s, #16]
+        stp     t2, t3, [d, #32]
+        ldp     t2, t3, [s, #32]
+        stp     t4, t5, [d, #48]
+        ldp     t4, t5, [s, #48]
+        stp     t6, t7, [d, #64]!
+        ldp     t6, t7, [s, #64]!
+        subs    count, count, #8
+        bhs     fwd_copy_again
+
+fwd_copy_drain:
+        stp     t0, t1, [d, #16]
+        stp     t2, t3, [d, #32]
+        stp     t4, t5, [d, #48]
+        stp     t6, t7, [d, #64]!
+
+        // count is now -8..-1 for 0..7 words to copy
+        adr     t0, 0f
+        add     t0, t0, count, lsl #5
+        br      t0
+
+        .align  5
+        ret                             // -8 == 0 words
+        .align  5
+        ldr     t0, [s, #16]            // -7 == 1 word
+        str     t0, [d, #16]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -6 = 2 words
+        stp     t0, t1, [d, #16]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -5 = 3 words
+        ldr     t2, [s, #32]
+        stp     t0, t1, [d, #16]
+        str     t2, [d, #32]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -4 = 4 words
+        ldp     t2, t3, [s, #32]
+        stp     t0, t1, [d, #16]
+        stp     t2, t3, [d, #32]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -3 = 5 words
+        ldp     t2, t3, [s, #32]
+        ldr     t4, [s, #48]
+        stp     t0, t1, [d, #16]
+        stp     t2, t3, [d, #32]
+        str     t4, [d, #48]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -2 = 6 words
+        ldp     t2, t3, [s, #32]
+        ldp     t4, t5, [s, #48]
+        stp     t0, t1, [d, #16]
+        stp     t2, t3, [d, #32]
+        stp     t4, t5, [d, #48]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -1 = 7 words
+        ldp     t2, t3, [s, #32]
+        ldp     t4, t5, [s, #48]
+        ldr     t6, [s, #64]
+        stp     t0, t1, [d, #16]
+        stp     t2, t3, [d, #32]
+        stp     t4, t5, [d, #48]
+        str     t6, [d, #64]
+        // Is always aligned here, code for 7 words is one instruction
+        // too large so it just falls through.
+        .align  5
+0:
+        ret
+
+        .align  6
+_Copy_conjoint_words:
+        sub     t0, d, s
+        cmp     t0, count, lsl #3
+        bhs     _Copy_disjoint_words
+
+        add     s, s, count, lsl #3
+        add     d, d, count, lsl #3
+
+        // Ensure 2 word aligned
+        tbz     s, #3, bwd_copy_aligned
+        ldr     t0, [s, #-8]!
+        str     t0, [d, #-8]!
+        sub     count, count, #1
+
+bwd_copy_aligned:
+        ldp     t0, t1, [s, #-16]
+        ldp     t2, t3, [s, #-32]
+        ldp     t4, t5, [s, #-48]
+        ldp     t6, t7, [s, #-64]!
+
+        subs    count, count, #16
+        blo     bwd_copy_drain
+
+bwd_copy_again:
+        prfum   pldl1keep, [s, #-256]
+        stp     t0, t1, [d, #-16]
+        ldp     t0, t1, [s, #-16]
+        stp     t2, t3, [d, #-32]
+        ldp     t2, t3, [s, #-32]
+        stp     t4, t5, [d, #-48]
+        ldp     t4, t5, [s, #-48]
+        stp     t6, t7, [d, #-64]!
+        ldp     t6, t7, [s, #-64]!
+        subs    count, count, #8
+        bhs     bwd_copy_again
+
+bwd_copy_drain:
+        stp     t0, t1, [d, #-16]
+        stp     t2, t3, [d, #-32]
+        stp     t4, t5, [d, #-48]
+        stp     t6, t7, [d, #-64]!
+
+        // count is now -8..-1 for 0..7 words to copy
+        adr     t0, 0f
+        add     t0, t0, count, lsl #5
+        br      t0
+
+        .align  5
+        ret                             // -8 == 0 words
+        .align  5
+        ldr     t0, [s, #-8]            // -7 == 1 word
+        str     t0, [d, #-8]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -6 = 2 words
+        stp     t0, t1, [d, #-16]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -5 = 3 words
+        ldr     t2, [s, #-24]
+        stp     t0, t1, [d, #-16]
+        str     t2, [d, #-24]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -4 = 4 words
+        ldp     t2, t3, [s, #-32]
+        stp     t0, t1, [d, #-16]
+        stp     t2, t3, [d, #-32]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -3 = 5 words
+        ldp     t2, t3, [s, #-32]
+        ldr     t4, [s, #-40]
+        stp     t0, t1, [d, #-16]
+        stp     t2, t3, [d, #-32]
+        str     t4, [d, #-40]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -2 = 6 words
+        ldp     t2, t3, [s, #-32]
+        ldp     t4, t5, [s, #-48]
+        stp     t0, t1, [d, #-16]
+        stp     t2, t3, [d, #-32]
+        stp     t4, t5, [d, #-48]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -1 = 7 words
+        ldp     t2, t3, [s, #-32]
+        ldp     t4, t5, [s, #-48]
+        ldr     t6, [s, #-56]
+        stp     t0, t1, [d, #-16]
+        stp     t2, t3, [d, #-32]
+        stp     t4, t5, [d, #-48]
+        str     t6, [d, #-56]
+        // Is always aligned here, code for 7 words is one instruction
+        // too large so it just falls through.
+        .align  5
+0:
+        ret
diff --git a/src/hotspot/os_cpu/bsd_aarch64/gc/z/zSyscall_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/gc/z/zSyscall_bsd_aarch64.hpp
new file mode 100644
index 00000000000..f99ba830c6d
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/gc/z/zSyscall_bsd_aarch64.hpp
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_GC_Z_ZSYSCALL_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_GC_Z_ZSYSCALL_BSD_AARCH64_HPP
+
+#include <sys/syscall.h>
+
+//
+// Support for building on older Linux systems
+//
+
+#ifndef SYS_memfd_create
+#define SYS_memfd_create     279
+#endif
+#ifndef SYS_fallocate
+#define SYS_fallocate        47
+#endif
+
+#endif // OS_CPU_BSD_AARCH64_GC_Z_ZSYSCALL_BSD_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
new file mode 100644
index 00000000000..26c7ab0f84d
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_GLOBALS_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_GLOBALS_BSD_AARCH64_HPP
+
+// Sets the default values for platform dependent flags used by the runtime system.
+// (see globals.hpp)
+
+define_pd_global(bool, DontYieldALot,            false);
+define_pd_global(intx, ThreadStackSize,          2048); // 0 => use system default
+define_pd_global(intx, VMThreadStackSize,        2048);
+
+define_pd_global(intx, CompilerThreadStackSize,  2048);
+
+define_pd_global(uintx,JVMInvokeMethodSlack,     8192);
+
+// Used on 64 bit platforms for UseCompressedOops base address
+define_pd_global(uintx,HeapBaseMinAddress,       2*G);
+
+class Thread;
+extern __thread Thread *aarch64_currentThread;
+
+#endif // OS_CPU_BSD_AARCH64_GLOBALS_BSD_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
new file mode 100644
index 00000000000..ab5886f9440
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_ORDERACCESS_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_ORDERACCESS_BSD_AARCH64_HPP
+
+// Included in orderAccess.hpp header file.
+
+#include "runtime/vm_version.hpp"
+
+// Implementation of class OrderAccess.
+
+inline void OrderAccess::loadload()   { acquire(); }
+inline void OrderAccess::storestore() { release(); }
+inline void OrderAccess::loadstore()  { acquire(); }
+inline void OrderAccess::storeload()  { fence(); }
+
+#define FULL_MEM_BARRIER  __sync_synchronize()
+#define READ_MEM_BARRIER  __atomic_thread_fence(__ATOMIC_ACQUIRE);
+#define WRITE_MEM_BARRIER __atomic_thread_fence(__ATOMIC_RELEASE);
+
+inline void OrderAccess::acquire() {
+  READ_MEM_BARRIER;
+}
+
+inline void OrderAccess::release() {
+  WRITE_MEM_BARRIER;
+}
+
+inline void OrderAccess::fence() {
+  FULL_MEM_BARRIER;
+}
+
+inline void OrderAccess::cross_modify_fence() { }
+
+#endif // OS_CPU_BSD_AARCH64_ORDERACCESS_BSD_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
new file mode 100644
index 00000000000..18651ae81b1
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -0,0 +1,611 @@
+/*
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+// no precompiled headers
+#include "jvm.h"
+#include "asm/macroAssembler.hpp"
+#include "classfile/classLoader.hpp"
+#include "classfile/systemDictionary.hpp"
+#include "classfile/vmSymbols.hpp"
+#include "code/codeCache.hpp"
+#include "code/icBuffer.hpp"
+#include "code/vtableStubs.hpp"
+#include "code/nativeInst.hpp"
+#include "interpreter/interpreter.hpp"
+#include "memory/allocation.inline.hpp"
+#include "os_share_linux.hpp"
+#include "prims/jniFastGetField.hpp"
+#include "prims/jvm_misc.hpp"
+#include "runtime/arguments.hpp"
+#include "runtime/frame.inline.hpp"
+#include "runtime/interfaceSupport.inline.hpp"
+#include "runtime/java.hpp"
+#include "runtime/javaCalls.hpp"
+#include "runtime/mutexLocker.hpp"
+#include "runtime/osThread.hpp"
+#include "runtime/safepointMechanism.hpp"
+#include "runtime/sharedRuntime.hpp"
+#include "runtime/stubRoutines.hpp"
+#include "runtime/thread.inline.hpp"
+#include "runtime/timer.hpp"
+#include "utilities/debug.hpp"
+#include "utilities/events.hpp"
+#include "utilities/vmError.hpp"
+
+// put OS-includes here
+# include <sys/types.h>
+# include <sys/mman.h>
+# include <pthread.h>
+# include <signal.h>
+# include <errno.h>
+# include <dlfcn.h>
+# include <stdlib.h>
+# include <stdio.h>
+# include <unistd.h>
+# include <sys/resource.h>
+# include <pthread.h>
+# include <sys/stat.h>
+# include <sys/time.h>
+# include <sys/utsname.h>
+# include <sys/socket.h>
+# include <sys/wait.h>
+# include <pwd.h>
+# include <poll.h>
+# include <ucontext.h>
+# include <fpu_control.h>
+
+#define REG_FP 29
+#define REG_LR 30
+
+NOINLINE address os::current_stack_pointer() {
+  return (address)__builtin_frame_address(0);
+}
+
+char* os::non_memory_address_word() {
+  // Must never look like an address returned by reserve_memory,
+  // even in its subfields (as defined by the CPU immediate fields,
+  // if the CPU splits constants across multiple instructions).
+
+  return (char*) 0xffffffffffff;
+}
+
+address os::Linux::ucontext_get_pc(const ucontext_t * uc) {
+  return (address)uc->uc_mcontext.pc;
+}
+
+void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
+  uc->uc_mcontext.pc = (intptr_t)pc;
+}
+
+intptr_t* os::Linux::ucontext_get_sp(const ucontext_t * uc) {
+  return (intptr_t*)uc->uc_mcontext.sp;
+}
+
+intptr_t* os::Linux::ucontext_get_fp(const ucontext_t * uc) {
+  return (intptr_t*)uc->uc_mcontext.regs[REG_FP];
+}
+
+address os::fetch_frame_from_context(const void* ucVoid,
+                    intptr_t** ret_sp, intptr_t** ret_fp) {
+
+  address epc;
+  const ucontext_t* uc = (const ucontext_t*)ucVoid;
+
+  if (uc != NULL) {
+    epc = os::Linux::ucontext_get_pc(uc);
+    if (ret_sp) *ret_sp = os::Linux::ucontext_get_sp(uc);
+    if (ret_fp) *ret_fp = os::Linux::ucontext_get_fp(uc);
+  } else {
+    epc = NULL;
+    if (ret_sp) *ret_sp = (intptr_t *)NULL;
+    if (ret_fp) *ret_fp = (intptr_t *)NULL;
+  }
+
+  return epc;
+}
+
+frame os::fetch_frame_from_context(const void* ucVoid) {
+  intptr_t* sp;
+  intptr_t* fp;
+  address epc = fetch_frame_from_context(ucVoid, &sp, &fp);
+  return frame(sp, fp, epc);
+}
+
+bool os::Linux::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
+  address pc = (address) os::Linux::ucontext_get_pc(uc);
+  if (Interpreter::contains(pc)) {
+    // interpreter performs stack banging after the fixed frame header has
+    // been generated while the compilers perform it before. To maintain
+    // semantic consistency between interpreted and compiled frames, the
+    // method returns the Java sender of the current frame.
+    *fr = os::fetch_frame_from_context(uc);
+    if (!fr->is_first_java_frame()) {
+      assert(fr->safe_for_sender(thread), "Safety check");
+      *fr = fr->java_sender();
+    }
+  } else {
+    // more complex code with compiled code
+    assert(!Interpreter::contains(pc), "Interpreted methods should have been handled above");
+    CodeBlob* cb = CodeCache::find_blob(pc);
+    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {
+      // Not sure where the pc points to, fallback to default
+      // stack overflow handling
+      return false;
+    } else {
+      // In compiled code, the stack banging is performed before LR
+      // has been saved in the frame.  LR is live, and SP and FP
+      // belong to the caller.
+      intptr_t* fp = os::Linux::ucontext_get_fp(uc);
+      intptr_t* sp = os::Linux::ucontext_get_sp(uc);
+      address pc = (address)(uc->uc_mcontext.regs[REG_LR]
+                         - NativeInstruction::instruction_size);
+      *fr = frame(sp, fp, pc);
+      if (!fr->is_java_frame()) {
+        assert(fr->safe_for_sender(thread), "Safety check");
+        assert(!fr->is_first_frame(), "Safety check");
+        *fr = fr->java_sender();
+      }
+    }
+  }
+  assert(fr->is_java_frame(), "Safety check");
+  return true;
+}
+
+// By default, gcc always saves frame pointer rfp on this stack. This
+// may get turned off by -fomit-frame-pointer.
+frame os::get_sender_for_C_frame(frame* fr) {
+  return frame(fr->link(), fr->link(), fr->sender_pc());
+}
+
+NOINLINE frame os::current_frame() {
+  intptr_t *fp = *(intptr_t **)__builtin_frame_address(0);
+  frame myframe((intptr_t*)os::current_stack_pointer(),
+                (intptr_t*)fp,
+                CAST_FROM_FN_PTR(address, os::current_frame));
+  if (os::is_first_C_frame(&myframe)) {
+    // stack is not walkable
+    return frame();
+  } else {
+    return os::get_sender_for_C_frame(&myframe);
+  }
+}
+
+extern "C" JNIEXPORT int
+JVM_handle_linux_signal(int sig,
+                        siginfo_t* info,
+                        void* ucVoid,
+                        int abort_if_unrecognized) {
+  ucontext_t* uc = (ucontext_t*) ucVoid;
+
+  Thread* t = Thread::current_or_null_safe();
+
+  // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
+  // (no destructors can be run)
+  os::ThreadCrashProtection::check_crash_protection(sig, t);
+
+  SignalHandlerMark shm(t);
+
+  // Note: it's not uncommon that JNI code uses signal/sigset to install
+  // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
+  // or have a SIGILL handler when detecting CPU type). When that happens,
+  // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To
+  // avoid unnecessary crash when libjsig is not preloaded, try handle signals
+  // that do not require siginfo/ucontext first.
+
+  if (sig == SIGPIPE || sig == SIGXFSZ) {
+    // allow chained handler to go first
+    if (os::Linux::chained_handler(sig, info, ucVoid)) {
+      return true;
+    } else {
+      // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
+      return true;
+    }
+  }
+
+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT
+  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {
+    if (handle_assert_poison_fault(ucVoid, info->si_addr)) {
+      return 1;
+    }
+  }
+#endif
+
+  JavaThread* thread = NULL;
+  VMThread* vmthread = NULL;
+  if (os::Linux::signal_handlers_are_installed) {
+    if (t != NULL ){
+      if(t->is_Java_thread()) {
+        thread = t->as_Java_thread();
+      }
+      else if(t->is_VM_thread()){
+        vmthread = (VMThread *)t;
+      }
+    }
+  }
+/*
+  NOTE: does not seem to work on linux.
+  if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {
+    // can't decode this kind of signal
+    info = NULL;
+  } else {
+    assert(sig == info->si_signo, "bad siginfo");
+  }
+*/
+  // decide if this trap can be handled by a stub
+  address stub = NULL;
+
+  address pc          = NULL;
+
+  //%note os_trap_1
+  if (info != NULL && uc != NULL && thread != NULL) {
+    pc = (address) os::Linux::ucontext_get_pc(uc);
+
+    if (StubRoutines::is_safefetch_fault(pc)) {
+      os::Linux::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
+      return 1;
+    }
+
+    address addr = (address) info->si_addr;
+
+    // Make sure the high order byte is sign extended, as it may be masked away by the hardware.
+    if ((uintptr_t(addr) & (uintptr_t(1) << 55)) != 0) {
+      addr = address(uintptr_t(addr) | (uintptr_t(0xFF) << 56));
+    }
+
+    // Handle ALL stack overflow variations here
+    if (sig == SIGSEGV) {
+      // check if fault address is within thread stack
+      if (thread->is_in_full_stack(addr)) {
+        // stack overflow
+        if (thread->in_stack_yellow_reserved_zone(addr)) {
+          if (thread->thread_state() == _thread_in_Java) {
+            if (thread->in_stack_reserved_zone(addr)) {
+              frame fr;
+              if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &fr)) {
+                assert(fr.is_java_frame(), "Must be a Java frame");
+                frame activation =
+                  SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
+                if (activation.sp() != NULL) {
+                  thread->disable_stack_reserved_zone();
+                  if (activation.is_interpreted_frame()) {
+                    thread->set_reserved_stack_activation((address)(
+                      activation.fp() + frame::interpreter_frame_initial_sp_offset));
+                  } else {
+                    thread->set_reserved_stack_activation((address)activation.unextended_sp());
+                  }
+                  return 1;
+                }
+              }
+            }
+            // Throw a stack overflow exception.  Guard pages will be reenabled
+            // while unwinding the stack.
+            thread->disable_stack_yellow_reserved_zone();
+            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
+          } else {
+            // Thread was in the vm or native code.  Return and try to finish.
+            thread->disable_stack_yellow_reserved_zone();
+            return 1;
+          }
+        } else if (thread->in_stack_red_zone(addr)) {
+          // Fatal red zone violation.  Disable the guard pages and fall through
+          // to handle_unexpected_exception way down below.
+          thread->disable_stack_red_zone();
+          tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
+
+          // This is a likely cause, but hard to verify. Let's just print
+          // it as a hint.
+          tty->print_raw_cr("Please check if any of your loaded .so files has "
+                            "enabled executable stack (see man page execstack(8))");
+        } else {
+          // Accessing stack address below sp may cause SEGV if current
+          // thread has MAP_GROWSDOWN stack. This should only happen when
+          // current thread was created by user code with MAP_GROWSDOWN flag
+          // and then attached to VM. See notes in os_linux.cpp.
+          if (thread->osthread()->expanding_stack() == 0) {
+             thread->osthread()->set_expanding_stack();
+             if (os::Linux::manually_expand_stack(thread, addr)) {
+               thread->osthread()->clear_expanding_stack();
+               return 1;
+             }
+             thread->osthread()->clear_expanding_stack();
+          } else {
+             fatal("recursive segv. expanding stack.");
+          }
+        }
+      }
+    }
+
+    if (thread->thread_state() == _thread_in_Java) {
+      // Java thread running in Java code => find exception handler if any
+      // a fault inside compiled code, the interpreter, or a stub
+
+      // Handle signal from NativeJump::patch_verified_entry().
+      if ((sig == SIGILL || sig == SIGTRAP)
+          && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {
+        if (TraceTraps) {
+          tty->print_cr("trap: zombie_not_entrant (%s)", (sig == SIGTRAP) ? "SIGTRAP" : "SIGILL");
+        }
+        stub = SharedRuntime::get_handle_wrong_method_stub();
+      } else if (sig == SIGSEGV && SafepointMechanism::is_poll_address((address)info->si_addr)) {
+        stub = SharedRuntime::get_poll_stub(pc);
+      } else if (sig == SIGBUS /* && info->si_code == BUS_OBJERR */) {
+        // BugId 4454115: A read from a MappedByteBuffer can fault
+        // here if the underlying file has been truncated.
+        // Do not crash the VM in such a case.
+        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
+        CompiledMethod* nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;
+        bool is_unsafe_arraycopy = (thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc));
+        if ((nm != NULL && nm->has_unsafe_access()) || is_unsafe_arraycopy) {
+          address next_pc = pc + NativeCall::instruction_size;
+          if (is_unsafe_arraycopy) {
+            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
+          }
+          stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
+        }
+      } else if (sig == SIGILL && nativeInstruction_at(pc)->is_stop()) {
+        // Pull a pointer to the error message out of the instruction
+        // stream.
+        const uint64_t *detail_msg_ptr
+          = (uint64_t*)(pc + NativeInstruction::instruction_size);
+        const char *detail_msg = (const char *)*detail_msg_ptr;
+        const char *msg = "stop";
+        if (TraceTraps) {
+          tty->print_cr("trap: %s: (SIGILL)", msg);
+        }
+
+        va_list detail_args;
+        VMError::report_and_die(INTERNAL_ERROR, msg, detail_msg, detail_args, thread,
+                                pc, info, ucVoid, NULL, 0, 0);
+        va_end(detail_args);
+      }
+      else
+
+      if (sig == SIGFPE  &&
+          (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {
+        stub =
+          SharedRuntime::
+          continuation_for_implicit_exception(thread,
+                                              pc,
+                                              SharedRuntime::
+                                              IMPLICIT_DIVIDE_BY_ZERO);
+      } else if (sig == SIGSEGV &&
+                 MacroAssembler::uses_implicit_null_check((void*)addr)) {
+          // Determination of interpreter/vtable stub/compiled code null exception
+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+      }
+    } else if ((thread->thread_state() == _thread_in_vm ||
+                 thread->thread_state() == _thread_in_native) &&
+               sig == SIGBUS && /* info->si_code == BUS_OBJERR && */
+               thread->doing_unsafe_access()) {
+      address next_pc = pc + NativeCall::instruction_size;
+      if (UnsafeCopyMemory::contains_pc(pc)) {
+        next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
+      }
+      stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
+    }
+
+    // jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in
+    // and the heap gets shrunk before the field access.
+    if ((sig == SIGSEGV) || (sig == SIGBUS)) {
+      address addr = JNI_FastGetField::find_slowcase_pc(pc);
+      if (addr != (address)-1) {
+        stub = addr;
+      }
+    }
+  }
+
+  if (stub != NULL) {
+    // save all thread context in case we need to restore it
+    if (thread != NULL) thread->set_saved_exception_pc(pc);
+
+    os::Linux::ucontext_set_pc(uc, stub);
+    return true;
+  }
+
+  // signal-chaining
+  if (os::Linux::chained_handler(sig, info, ucVoid)) {
+     return true;
+  }
+
+  if (!abort_if_unrecognized) {
+    // caller wants another chance, so give it to him
+    return false;
+  }
+
+  if (pc == NULL && uc != NULL) {
+    pc = os::Linux::ucontext_get_pc(uc);
+  }
+
+  // unmask current signal
+  sigset_t newset;
+  sigemptyset(&newset);
+  sigaddset(&newset, sig);
+  sigprocmask(SIG_UNBLOCK, &newset, NULL);
+
+  VMError::report_and_die(t, sig, pc, info, ucVoid);
+
+  ShouldNotReachHere();
+  return true; // Mute compiler
+}
+
+void os::Linux::init_thread_fpu_state(void) {
+}
+
+int os::Linux::get_fpu_control_word(void) {
+  return 0;
+}
+
+void os::Linux::set_fpu_control_word(int fpu_control) {
+}
+
+bool os::is_allocatable(size_t bytes) {
+  return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// thread stack
+
+// Minimum usable stack sizes required to get to user code. Space for
+// HotSpot guard pages is added later.
+size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;
+size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;
+size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;
+
+// return default stack size for thr_type
+size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
+  // default stack size (compiler thread needs larger stack)
+  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);
+  return s;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// helper functions for fatal error handler
+
+void os::print_context(outputStream *st, const void *context) {
+  if (context == NULL) return;
+
+  const ucontext_t *uc = (const ucontext_t*)context;
+  st->print_cr("Registers:");
+  for (int r = 0; r < 31; r++) {
+    st->print("R%-2d=", r);
+    print_location(st, uc->uc_mcontext.regs[r]);
+  }
+  st->cr();
+
+  intptr_t *sp = (intptr_t *)os::Linux::ucontext_get_sp(uc);
+  st->print_cr("Top of Stack: (sp=" PTR_FORMAT ")", p2i(sp));
+  print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));
+  st->cr();
+
+  // Note: it may be unsafe to inspect memory near pc. For example, pc may
+  // point to garbage if entry point in an nmethod is corrupted. Leave
+  // this at the end, and hope for the best.
+  address pc = os::Linux::ucontext_get_pc(uc);
+  print_instructions(st, pc, 4/*native instruction size*/);
+  st->cr();
+}
+
+void os::print_register_info(outputStream *st, const void *context) {
+  if (context == NULL) return;
+
+  const ucontext_t *uc = (const ucontext_t*)context;
+
+  st->print_cr("Register to memory mapping:");
+  st->cr();
+
+  // this is horrendously verbose but the layout of the registers in the
+  // context does not match how we defined our abstract Register set, so
+  // we can't just iterate through the gregs area
+
+  // this is only for the "general purpose" registers
+
+  for (int r = 0; r < 31; r++)
+    st->print_cr(  "R%d=" INTPTR_FORMAT, r, (uintptr_t)uc->uc_mcontext.regs[r]);
+  st->cr();
+}
+
+void os::setup_fpu() {
+}
+
+#ifndef PRODUCT
+void os::verify_stack_alignment() {
+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, "incorrect stack alignment");
+}
+#endif
+
+int os::extra_bang_size_in_bytes() {
+  // AArch64 does not require the additional stack bang.
+  return 0;
+}
+
+extern "C" {
+  int SpinPause() {
+    return 0;
+  }
+
+  void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {
+    if (from > to) {
+      const jshort *end = from + count;
+      while (from < end)
+        *(to++) = *(from++);
+    }
+    else if (from < to) {
+      const jshort *end = from;
+      from += count - 1;
+      to   += count - 1;
+      while (from >= end)
+        *(to--) = *(from--);
+    }
+  }
+  void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {
+    if (from > to) {
+      const jint *end = from + count;
+      while (from < end)
+        *(to++) = *(from++);
+    }
+    else if (from < to) {
+      const jint *end = from;
+      from += count - 1;
+      to   += count - 1;
+      while (from >= end)
+        *(to--) = *(from--);
+    }
+  }
+  void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {
+    if (from > to) {
+      const jlong *end = from + count;
+      while (from < end)
+        os::atomic_copy64(from++, to++);
+    }
+    else if (from < to) {
+      const jlong *end = from;
+      from += count - 1;
+      to   += count - 1;
+      while (from >= end)
+        os::atomic_copy64(from--, to--);
+    }
+  }
+
+  void _Copy_arrayof_conjoint_bytes(const HeapWord* from,
+                                    HeapWord* to,
+                                    size_t    count) {
+    memmove(to, from, count);
+  }
+  void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,
+                                      HeapWord* to,
+                                      size_t    count) {
+    memmove(to, from, count * 2);
+  }
+  void _Copy_arrayof_conjoint_jints(const HeapWord* from,
+                                    HeapWord* to,
+                                    size_t    count) {
+    memmove(to, from, count * 4);
+  }
+  void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,
+                                     HeapWord* to,
+                                     size_t    count) {
+    memmove(to, from, count * 8);
+  }
+};
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
new file mode 100644
index 00000000000..494a7e621b8
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_OS_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_OS_BSD_AARCH64_HPP
+
+  static void setup_fpu();
+
+  static bool is_allocatable(size_t bytes);
+
+  // Used to register dynamic code cache area with the OS
+  // Note: Currently only used in 64 bit Windows implementations
+  static bool register_code_area(char *low, char *high) { return true; }
+
+  // Atomically copy 64 bits of data
+  static void atomic_copy64(const volatile void *src, volatile void *dst) {
+    *(jlong *) dst = *(const jlong *) src;
+  }
+
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
+#endif // OS_CPU_BSD_AARCH64_OS_BSD_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp b/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp
new file mode 100644
index 00000000000..3b5f31b35b8
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_PREFETCH_BSD_AARCH64_INLINE_HPP
+#define OS_CPU_BSD_AARCH64_PREFETCH_BSD_AARCH64_INLINE_HPP
+
+#include "runtime/prefetch.hpp"
+
+
+inline void Prefetch::read (void *loc, intx interval) {
+  if (interval >= 0)
+    asm("prfm PLDL1KEEP, [%0, %1]" : : "r"(loc), "r"(interval));
+}
+
+inline void Prefetch::write(void *loc, intx interval) {
+  if (interval >= 0)
+    asm("prfm PSTL1KEEP, [%0, %1]" : : "r"(loc), "r"(interval));
+}
+
+#endif // OS_CPU_BSD_AARCH64_PREFETCH_BSD_AARCH64_INLINE_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/threadLS_bsd_aarch64.s b/src/hotspot/os_cpu/bsd_aarch64/threadLS_bsd_aarch64.s
new file mode 100644
index 00000000000..f541844b9d6
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/threadLS_bsd_aarch64.s
@@ -0,0 +1,44 @@
+// Copyright (c) 2015, Red Hat Inc. All rights reserved.
+// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+//
+// This code is free software; you can redistribute it and/or modify it
+// under the terms of the GNU General Public License version 2 only, as
+// published by the Free Software Foundation.
+//
+// This code is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// version 2 for more details (a copy is included in the LICENSE file that
+// accompanied this code).
+//
+// You should have received a copy of the GNU General Public License version
+// 2 along with this work; if not, write to the Free Software Foundation,
+// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+//
+// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+// or visit www.oracle.com if you need additional information or have any
+// questions.
+
+        // JavaThread::aarch64_get_thread_helper()
+        //
+        // Return the current thread pointer in x0.
+        // Clobber x1, flags.
+        // All other registers are preserved,
+
+	.global	_ZN10JavaThread25aarch64_get_thread_helperEv
+	.type	_ZN10JavaThread25aarch64_get_thread_helperEv, %function
+
+_ZN10JavaThread25aarch64_get_thread_helperEv:
+	stp x29, x30, [sp, -16]!
+	adrp x0, :tlsdesc:_ZN6Thread12_thr_currentE
+	ldr x1, [x0, #:tlsdesc_lo12:_ZN6Thread12_thr_currentE]
+	add x0, x0, :tlsdesc_lo12:_ZN6Thread12_thr_currentE
+	.tlsdesccall _ZN6Thread12_thr_currentE
+	blr x1
+	mrs x1, tpidr_el0
+	add x0, x1, x0
+	ldr x0, [x0]
+	ldp x29, x30, [sp], 16
+	ret
+
+	.size _ZN10JavaThread25aarch64_get_thread_helperEv, .-_ZN10JavaThread25aarch64_get_thread_helperEv
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
new file mode 100644
index 00000000000..799d2cf87d1
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "memory/metaspaceShared.hpp"
+#include "runtime/frame.inline.hpp"
+#include "runtime/thread.inline.hpp"
+
+frame JavaThread::pd_last_frame() {
+  assert(has_last_Java_frame(), "must have last_Java_sp() when suspended");
+  return frame(_anchor.last_Java_sp(), _anchor.last_Java_fp(), _anchor.last_Java_pc());
+}
+
+// For Forte Analyzer AsyncGetCallTrace profiling support - thread is
+// currently interrupted by SIGPROF
+bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr,
+  void* ucontext, bool isInJava) {
+
+  assert(Thread::current() == this, "caller must be current thread");
+  return pd_get_top_frame(fr_addr, ucontext, isInJava);
+}
+
+bool JavaThread::pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava) {
+  return pd_get_top_frame(fr_addr, ucontext, isInJava);
+}
+
+bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava) {
+  // If we have a last_Java_frame, then we should use it even if
+  // isInJava == true.  It should be more reliable than ucontext info.
+  if (has_last_Java_frame() && frame_anchor()->walkable()) {
+    *fr_addr = pd_last_frame();
+    return true;
+  }
+
+  // At this point, we don't have a last_Java_frame, so
+  // we try to glean some information out of the ucontext
+  // if we were running Java code when SIGPROF came in.
+  if (isInJava) {
+    ucontext_t* uc = (ucontext_t*) ucontext;
+
+    intptr_t* ret_fp;
+    intptr_t* ret_sp;
+    address addr = os::fetch_frame_from_context(uc, &ret_sp, &ret_fp);
+    if (addr == NULL || ret_sp == NULL ) {
+      // ucontext wasn't useful
+      return false;
+    }
+
+    if (MetaspaceShared::is_in_trampoline_frame(addr)) {
+      // In the middle of a trampoline call. Bail out for safety.
+      // This happens rarely so shouldn't affect profiling.
+      return false;
+    }
+
+    frame ret_frame(ret_sp, ret_fp, addr);
+    if (!ret_frame.safe_for_sender(this)) {
+#ifdef COMPILER2
+      frame ret_frame2(ret_sp, NULL, addr);
+      if (!ret_frame2.safe_for_sender(this)) {
+        // nothing else to try if the frame isn't good
+        return false;
+      }
+      ret_frame = ret_frame2;
+#else
+      // nothing else to try if the frame isn't good
+      return false;
+#endif /* COMPILER2 */
+    }
+    *fr_addr = ret_frame;
+    return true;
+  }
+
+  // nothing else to try
+  return false;
+}
+
+void JavaThread::cache_global_variables() { }
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
new file mode 100644
index 00000000000..945dceb6e2e
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP
+
+ private:
+#ifdef ASSERT
+  // spill stack holds N callee-save registers at each Java call and
+  // grows downwards towards limit
+  // we need limit to check we have space for a spill and base so we
+  // can identify all live spill frames at GC (eventually)
+  address          _spill_stack;
+  address          _spill_stack_base;
+  address          _spill_stack_limit;
+#endif // ASSERT
+
+  void pd_initialize() {
+    _anchor.clear();
+  }
+
+  frame pd_last_frame();
+
+ public:
+  // Mutators are highly dangerous....
+  intptr_t* last_Java_fp()                       { return _anchor.last_Java_fp(); }
+  void  set_last_Java_fp(intptr_t* fp)           { _anchor.set_last_Java_fp(fp);   }
+
+  void set_base_of_stack_pointer(intptr_t* base_sp) {
+  }
+
+  static ByteSize last_Java_fp_offset()          {
+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();
+  }
+
+  intptr_t* base_of_stack_pointer() {
+    return NULL;
+  }
+  void record_base_of_stack_pointer() {
+  }
+
+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,
+    bool isInJava);
+
+  bool pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava);
+private:
+  bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);
+public:
+
+  static Thread *aarch64_get_thread_helper();
+
+  // These routines are only used on cpu architectures that
+  // have separate register stacks (Itanium).
+  static bool register_stack_overflow() { return false; }
+  static void enable_register_stack_guard() {}
+  static void disable_register_stack_guard() {}
+
+#endif // OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
new file mode 100644
index 00000000000..7c483d685cb
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_VMSTRUCTS_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_VMSTRUCTS_BSD_AARCH64_HPP
+
+// These are the OS and CPU-specific fields, types and integer
+// constants required by the Serviceability Agent. This file is
+// referenced by vmStructs.cpp.
+
+#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \
+                                                                                                                                     \
+  /******************************/                                                                                                   \
+  /* Threads (NOTE: incomplete) */                                                                                                   \
+  /******************************/                                                                                                   \
+  nonstatic_field(OSThread,                      _thread_id,                                      OSThread::thread_id_t)             \
+  nonstatic_field(OSThread,                      _pthread_id,                                     pthread_t)
+
+
+#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \
+                                                                          \
+  /**********************/                                                \
+  /* Posix Thread IDs   */                                                \
+  /**********************/                                                \
+                                                                          \
+  declare_integer_type(OSThread::thread_id_t)                             \
+  declare_unsigned_integer_type(pthread_t)
+
+#define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)
+
+#define VM_LONG_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)
+
+#endif // OS_CPU_BSD_AARCH64_VMSTRUCTS_BSD_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
new file mode 100644
index 00000000000..d5fb3f4680b
--- /dev/null
+++ b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "runtime/os.hpp"
+#include "runtime/vm_version.hpp"
+
+#include <asm/hwcap.h>
+#include <sys/auxv.h>
+#include <sys/prctl.h>
+
+#ifndef HWCAP_AES
+#define HWCAP_AES   (1<<3)
+#endif
+
+#ifndef HWCAP_PMULL
+#define HWCAP_PMULL (1<<4)
+#endif
+
+#ifndef HWCAP_SHA1
+#define HWCAP_SHA1  (1<<5)
+#endif
+
+#ifndef HWCAP_SHA2
+#define HWCAP_SHA2  (1<<6)
+#endif
+
+#ifndef HWCAP_CRC32
+#define HWCAP_CRC32 (1<<7)
+#endif
+
+#ifndef HWCAP_ATOMICS
+#define HWCAP_ATOMICS (1<<8)
+#endif
+
+#ifndef HWCAP_DCPOP
+#define HWCAP_DCPOP (1<<16)
+#endif
+
+#ifndef HWCAP_SHA512
+#define HWCAP_SHA512 (1 << 21)
+#endif
+
+#ifndef HWCAP_SVE
+#define HWCAP_SVE (1 << 22)
+#endif
+
+#ifndef HWCAP2_SVE2
+#define HWCAP2_SVE2 (1 << 1)
+#endif
+
+#ifndef PR_SVE_GET_VL
+// For old toolchains which do not have SVE related macros defined.
+#define PR_SVE_SET_VL   50
+#define PR_SVE_GET_VL   51
+#endif
+
+int VM_Version::get_current_sve_vector_length() {
+  assert(_features & CPU_SVE, "should not call this");
+  return prctl(PR_SVE_GET_VL);
+}
+
+int VM_Version::set_and_get_current_sve_vector_lenght(int length) {
+  assert(_features & CPU_SVE, "should not call this");
+  int new_length = prctl(PR_SVE_SET_VL, length);
+  return new_length;
+}
+
+void VM_Version::get_os_cpu_info() {
+
+  uint64_t auxv = getauxval(AT_HWCAP);
+  uint64_t auxv2 = getauxval(AT_HWCAP2);
+
+  static_assert(CPU_FP      == HWCAP_FP);
+  static_assert(CPU_ASIMD   == HWCAP_ASIMD);
+  static_assert(CPU_EVTSTRM == HWCAP_EVTSTRM);
+  static_assert(CPU_AES     == HWCAP_AES);
+  static_assert(CPU_PMULL   == HWCAP_PMULL);
+  static_assert(CPU_SHA1    == HWCAP_SHA1);
+  static_assert(CPU_SHA2    == HWCAP_SHA2);
+  static_assert(CPU_CRC32   == HWCAP_CRC32);
+  static_assert(CPU_LSE     == HWCAP_ATOMICS);
+  static_assert(CPU_DCPOP   == HWCAP_DCPOP);
+  static_assert(CPU_SHA512  == HWCAP_SHA512);
+  static_assert(CPU_SVE     == HWCAP_SVE);
+  _features = auxv & (
+      HWCAP_FP      |
+      HWCAP_ASIMD   |
+      HWCAP_EVTSTRM |
+      HWCAP_AES     |
+      HWCAP_PMULL   |
+      HWCAP_SHA1    |
+      HWCAP_SHA2    |
+      HWCAP_CRC32   |
+      HWCAP_ATOMICS |
+      HWCAP_DCPOP   |
+      HWCAP_SHA512  |
+      HWCAP_SVE);
+
+  if (auxv2 & HWCAP2_SVE2) _features |= CPU_SVE2;
+
+  uint64_t ctr_el0;
+  uint64_t dczid_el0;
+  __asm__ (
+    "mrs %0, CTR_EL0\n"
+    "mrs %1, DCZID_EL0\n"
+    : "=r"(ctr_el0), "=r"(dczid_el0)
+  );
+
+  _icache_line_size = (1 << (ctr_el0 & 0x0f)) * 4;
+  _dcache_line_size = (1 << ((ctr_el0 >> 16) & 0x0f)) * 4;
+
+  if (!(dczid_el0 & 0x10)) {
+    _zva_length = 4 << (dczid_el0 & 0xf);
+  }
+
+  int cpu_lines = 0;
+  if (FILE *f = fopen("/proc/cpuinfo", "r")) {
+    // need a large buffer as the flags line may include lots of text
+    char buf[1024], *p;
+    while (fgets(buf, sizeof (buf), f) != NULL) {
+      if ((p = strchr(buf, ':')) != NULL) {
+        long v = strtol(p+1, NULL, 0);
+        if (strncmp(buf, "CPU implementer", sizeof "CPU implementer" - 1) == 0) {
+          _cpu = v;
+          cpu_lines++;
+        } else if (strncmp(buf, "CPU variant", sizeof "CPU variant" - 1) == 0) {
+          _variant = v;
+        } else if (strncmp(buf, "CPU part", sizeof "CPU part" - 1) == 0) {
+          if (_model != v)  _model2 = _model;
+          _model = v;
+        } else if (strncmp(buf, "CPU revision", sizeof "CPU revision" - 1) == 0) {
+          _revision = v;
+        } else if (strncmp(buf, "flags", sizeof("flags") - 1) == 0) {
+          if (strstr(p+1, "dcpop")) {
+            guarantee(_features & CPU_DCPOP, "dcpop availability should be consistent");
+          }
+        }
+      }
+    }
+    fclose(f);
+  }
+  guarantee(cpu_lines == os::processor_count(), "core count should be consistent");
+}

From 58a63b60cbeffe91ebebe0b6db764368c1b1e210 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Wed, 30 Sep 2020 07:50:59 -0700
Subject: [PATCH 08/94] JDK-8253819: Add missing parts from bsd_x86

---
 src/hotspot/os/bsd/os_bsd.cpp                 |   2 +
 .../os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp |   3 +-
 .../bsd_aarch64/bytes_bsd_aarch64.inline.hpp  |  14 +-
 .../bsd_aarch64/copy_bsd_aarch64.inline.hpp   | 114 +++---
 .../os_cpu/bsd_aarch64/copy_bsd_aarch64.s     |  13 +-
 .../bsd_aarch64/gc/z/zSyscall_bsd_aarch64.hpp |  40 --
 .../bsd_aarch64/globals_bsd_aarch64.hpp       |   4 +-
 .../bsd_aarch64/orderAccess_bsd_aarch64.hpp   |   2 -
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.cpp     | 380 ++++++++++++++----
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.hpp     |   6 -
 .../os_cpu/bsd_aarch64/threadLS_bsd_aarch64.s |  44 --
 .../os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp |  13 +-
 .../os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp |  14 +-
 .../bsd_aarch64/vmStructs_bsd_aarch64.hpp     |   7 +-
 .../bsd_aarch64/vm_version_bsd_aarch64.cpp    | 137 -------
 15 files changed, 390 insertions(+), 403 deletions(-)
 delete mode 100644 src/hotspot/os_cpu/bsd_aarch64/gc/z/zSyscall_bsd_aarch64.hpp
 delete mode 100644 src/hotspot/os_cpu/bsd_aarch64/threadLS_bsd_aarch64.s

diff --git a/src/hotspot/os/bsd/os_bsd.cpp b/src/hotspot/os/bsd/os_bsd.cpp
index 5b049c15d04..1d1701ed6db 100644
--- a/src/hotspot/os/bsd/os_bsd.cpp
+++ b/src/hotspot/os/bsd/os_bsd.cpp
@@ -219,6 +219,8 @@ static char cpu_arch[] = "i386";
 static char cpu_arch[] = "amd64";
 #elif defined(ARM)
 static char cpu_arch[] = "arm";
+#elif defined(AARCH64)
+static char cpu_arch[] = "aarch64";
 #elif defined(PPC32)
 static char cpu_arch[] = "ppc";
 #else
diff --git a/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
index cd8807c6a79..a64d9f3f36f 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
@@ -26,8 +26,6 @@
 #ifndef OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP
 #define OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP
 
-#include "runtime/vm_version.hpp"
-
 // Implementation of class atomic
 // Note that memory_order_conservative requires a full barrier after atomic stores.
 // See https://patchwork.kernel.org/patch/3575821/
@@ -102,4 +100,5 @@ struct Atomic::PlatformOrderedStore<byte_size, RELEASE_X_FENCE>
   void operator()(volatile T* p, T v) const { release_store(p, v); OrderAccess::fence(); }
 };
 
+
 #endif // OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp b/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
index 6dea3134a8f..1c46c14f092 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
@@ -26,7 +26,17 @@
 #ifndef OS_CPU_BSD_AARCH64_BYTES_BSD_AARCH64_INLINE_HPP
 #define OS_CPU_BSD_AARCH64_BYTES_BSD_AARCH64_INLINE_HPP
 
-#include <byteswap.h>
+#ifdef __APPLE__
+#include <libkern/OSByteOrder.h>
+#endif
+
+#if defined(__APPLE__)
+#  define bswap_16(x) OSSwapInt16(x)
+#  define bswap_32(x) OSSwapInt32(x)
+#  define bswap_64(x) OSSwapInt64(x)
+#else
+#  error "Unimplemented"
+#endif
 
 // Efficient swapping of data bytes from Java byte
 // ordering to native byte ordering and vice versa.
diff --git a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
index ab4960aefd0..e353971ad8d 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
@@ -31,65 +31,65 @@
         long tmp0, tmp1, tmp2, tmp3;                                    \
         long tmp4, tmp5, tmp6, tmp7;                                    \
   __asm volatile(                                                       \
-"       adr     %[t0], 0f;"                                             \
-"       add     %[t0], %[t0], %[cnt], lsl #5;"                          \
-"       br      %[t0];"                                                 \
-"       .align  5;"                                                     \
+"       adr     %[t0], 0f;\n"                                           \
+"       add     %[t0], %[t0], %[cnt], lsl #5;\n"                        \
+"       br      %[t0];\n"                                               \
+"       .align  5;\n"                                                   \
 "0:"                                                                    \
-"       b       1f;"                                                    \
-"       .align  5;"                                                     \
-"       ldr     %[t0], [%[s], #0];"                                     \
-"       str     %[t0], [%[d], #0];"                                     \
-"       b       1f;"                                                    \
-"       .align  5;"                                                     \
-"       ldp     %[t0], %[t1], [%[s], #0];"                              \
-"       stp     %[t0], %[t1], [%[d], #0];"                              \
-"       b       1f;"                                                    \
-"       .align  5;"                                                     \
-"       ldp     %[t0], %[t1], [%[s], #0];"                              \
-"       ldr     %[t2], [%[s], #16];"                                    \
-"       stp     %[t0], %[t1], [%[d], #0];"                              \
-"       str     %[t2], [%[d], #16];"                                    \
-"       b       1f;"                                                    \
-"       .align  5;"                                                     \
-"       ldp     %[t0], %[t1], [%[s], #0];"                              \
-"       ldp     %[t2], %[t3], [%[s], #16];"                             \
-"       stp     %[t0], %[t1], [%[d], #0];"                              \
-"       stp     %[t2], %[t3], [%[d], #16];"                             \
-"       b       1f;"                                                    \
-"       .align  5;"                                                     \
-"       ldp     %[t0], %[t1], [%[s], #0];"                              \
-"       ldp     %[t2], %[t3], [%[s], #16];"                             \
-"       ldr     %[t4], [%[s], #32];"                                    \
-"       stp     %[t0], %[t1], [%[d], #0];"                              \
-"       stp     %[t2], %[t3], [%[d], #16];"                             \
-"       str     %[t4], [%[d], #32];"                                    \
-"       b       1f;"                                                    \
-"       .align  5;"                                                     \
-"       ldp     %[t0], %[t1], [%[s], #0];"                              \
-"       ldp     %[t2], %[t3], [%[s], #16];"                             \
-"       ldp     %[t4], %[t5], [%[s], #32];"                             \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldr     %[t0], [%[s], #0];\n"                                   \
+"       str     %[t0], [%[d], #0];\n"                                   \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       ldr     %[t2], [%[s], #16];\n"                                  \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       str     %[t2], [%[d], #16];\n"                                  \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       ldp     %[t2], %[t3], [%[s], #16];\n"                           \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       stp     %[t2], %[t3], [%[d], #16];\n"                           \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       ldp     %[t2], %[t3], [%[s], #16];\n"                           \
+"       ldr     %[t4], [%[s], #32];\n"                                  \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       stp     %[t2], %[t3], [%[d], #16];\n"                           \
+"       str     %[t4], [%[d], #32];\n"                                  \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       ldp     %[t2], %[t3], [%[s], #16];\n"                           \
+"       ldp     %[t4], %[t5], [%[s], #32];\n"                           \
 "2:"                                                                    \
-"       stp     %[t0], %[t1], [%[d], #0];"                              \
-"       stp     %[t2], %[t3], [%[d], #16];"                             \
-"       stp     %[t4], %[t5], [%[d], #32];"                             \
-"       b       1f;"                                                    \
-"       .align  5;"                                                     \
-"       ldr     %[t6], [%[s], #0];"                                     \
-"       ldp     %[t0], %[t1], [%[s], #8];"                              \
-"       ldp     %[t2], %[t3], [%[s], #24];"                             \
-"       ldp     %[t4], %[t5], [%[s], #40];"                             \
-"       str     %[t6], [%[d]], #8;"                                     \
-"       b       2b;"                                                    \
-"       .align  5;"                                                     \
-"       ldp     %[t0], %[t1], [%[s], #0];"                              \
-"       ldp     %[t2], %[t3], [%[s], #16];"                             \
-"       ldp     %[t4], %[t5], [%[s], #32];"                             \
-"       ldp     %[t6], %[t7], [%[s], #48];"                             \
-"       stp     %[t0], %[t1], [%[d], #0];"                              \
-"       stp     %[t2], %[t3], [%[d], #16];"                             \
-"       stp     %[t4], %[t5], [%[d], #32];"                             \
-"       stp     %[t6], %[t7], [%[d], #48];"                             \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       stp     %[t2], %[t3], [%[d], #16];\n"                           \
+"       stp     %[t4], %[t5], [%[d], #32];\n"                           \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldr     %[t6], [%[s], #0];\n"                                   \
+"       ldp     %[t0], %[t1], [%[s], #8];\n"                            \
+"       ldp     %[t2], %[t3], [%[s], #24];\n"                           \
+"       ldp     %[t4], %[t5], [%[s], #40];\n"                           \
+"       str     %[t6], [%[d]], #8;\n"                                   \
+"       b       2b;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       ldp     %[t2], %[t3], [%[s], #16];\n"                           \
+"       ldp     %[t4], %[t5], [%[s], #32];\n"                           \
+"       ldp     %[t6], %[t7], [%[s], #48];\n"                           \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       stp     %[t2], %[t3], [%[d], #16];\n"                           \
+"       stp     %[t4], %[t5], [%[d], #32];\n"                           \
+"       stp     %[t6], %[t7], [%[d], #48];\n"                           \
 "1:"                                                                    \
                                                                         \
   : [s]"+r"(from), [d]"+r"(to), [cnt]"+r"(count),                       \
diff --git a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s
index 4b8ed597c59..70b0c24660e 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s
+++ b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s
@@ -21,8 +21,11 @@
  * questions.
  *
  */
-        .global _Copy_conjoint_words
-        .global _Copy_disjoint_words
+
+#define CFUNC(x) _##x
+
+        .global CFUNC(_Copy_conjoint_words)
+        .global CFUNC(_Copy_disjoint_words)
 
 s       .req    x0
 d       .req    x1
@@ -37,7 +40,7 @@ t6      .req    x9
 t7      .req    x10
 
         .align  6
-_Copy_disjoint_words:
+CFUNC(_Copy_disjoint_words):
         // Ensure 2 word aligned
         tbz     s, #3, fwd_copy_aligned
         ldr     t0, [s], #8
@@ -135,10 +138,10 @@ fwd_copy_drain:
         ret
 
         .align  6
-_Copy_conjoint_words:
+CFUNC(_Copy_conjoint_words):
         sub     t0, d, s
         cmp     t0, count, lsl #3
-        bhs     _Copy_disjoint_words
+        bhs     CFUNC(_Copy_disjoint_words)
 
         add     s, s, count, lsl #3
         add     d, d, count, lsl #3
diff --git a/src/hotspot/os_cpu/bsd_aarch64/gc/z/zSyscall_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/gc/z/zSyscall_bsd_aarch64.hpp
deleted file mode 100644
index f99ba830c6d..00000000000
--- a/src/hotspot/os_cpu/bsd_aarch64/gc/z/zSyscall_bsd_aarch64.hpp
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef OS_CPU_BSD_AARCH64_GC_Z_ZSYSCALL_BSD_AARCH64_HPP
-#define OS_CPU_BSD_AARCH64_GC_Z_ZSYSCALL_BSD_AARCH64_HPP
-
-#include <sys/syscall.h>
-
-//
-// Support for building on older Linux systems
-//
-
-#ifndef SYS_memfd_create
-#define SYS_memfd_create     279
-#endif
-#ifndef SYS_fallocate
-#define SYS_fallocate        47
-#endif
-
-#endif // OS_CPU_BSD_AARCH64_GC_Z_ZSYSCALL_BSD_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
index 26c7ab0f84d..dbe8ffc51b6 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
@@ -26,6 +26,7 @@
 #ifndef OS_CPU_BSD_AARCH64_GLOBALS_BSD_AARCH64_HPP
 #define OS_CPU_BSD_AARCH64_GLOBALS_BSD_AARCH64_HPP
 
+
 // Sets the default values for platform dependent flags used by the runtime system.
 // (see globals.hpp)
 
@@ -40,7 +41,4 @@ define_pd_global(uintx,JVMInvokeMethodSlack,     8192);
 // Used on 64 bit platforms for UseCompressedOops base address
 define_pd_global(uintx,HeapBaseMinAddress,       2*G);
 
-class Thread;
-extern __thread Thread *aarch64_currentThread;
-
 #endif // OS_CPU_BSD_AARCH64_GLOBALS_BSD_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
index ab5886f9440..0039fc89fd7 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
@@ -28,8 +28,6 @@
 
 // Included in orderAccess.hpp header file.
 
-#include "runtime/vm_version.hpp"
-
 // Implementation of class OrderAccess.
 
 inline void OrderAccess::loadload()   { acquire(); }
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index 18651ae81b1..d00cee436eb 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -32,10 +32,10 @@
 #include "code/codeCache.hpp"
 #include "code/icBuffer.hpp"
 #include "code/vtableStubs.hpp"
-#include "code/nativeInst.hpp"
 #include "interpreter/interpreter.hpp"
+#include "logging/log.hpp"
 #include "memory/allocation.inline.hpp"
-#include "os_share_linux.hpp"
+#include "os_share_bsd.hpp"
 #include "prims/jniFastGetField.hpp"
 #include "prims/jvm_misc.hpp"
 #include "runtime/arguments.hpp"
@@ -50,7 +50,7 @@
 #include "runtime/stubRoutines.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/timer.hpp"
-#include "utilities/debug.hpp"
+#include "utilities/align.hpp"
 #include "utilities/events.hpp"
 #include "utilities/vmError.hpp"
 
@@ -73,14 +73,53 @@
 # include <sys/wait.h>
 # include <pwd.h>
 # include <poll.h>
+#ifndef __OpenBSD__
 # include <ucontext.h>
-# include <fpu_control.h>
+#endif
+
+#if !defined(__APPLE__) && !defined(__NetBSD__)
+# include <pthread_np.h>
+#endif
+
+// needed by current_stack_region() workaround for Mavericks
+#if defined(__APPLE__)
+# include <errno.h>
+# include <sys/types.h>
+# include <sys/sysctl.h>
+# define DEFAULT_MAIN_THREAD_STACK_PAGES 2048
+# define OS_X_10_9_0_KERNEL_MAJOR_VERSION 13
+#endif
 
-#define REG_FP 29
-#define REG_LR 30
+#define SPELL_REG_SP "sp"
+#define SPELL_REG_FP "fp"
 
-NOINLINE address os::current_stack_pointer() {
-  return (address)__builtin_frame_address(0);
+#ifdef __APPLE__
+// see darwin-xnu/osfmk/mach/arm/_structs.h
+
+# if __DARWIN_UNIX03 && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
+  // 10.5 UNIX03 member name prefixes
+  #define DU3_PREFIX(s, m) __ ## s.__ ## m
+# else
+  #define DU3_PREFIX(s, m) s ## . ## m
+# endif
+#endif
+
+#define context_x    uc_mcontext->DU3_PREFIX(ss,x)
+#define context_fp   uc_mcontext->DU3_PREFIX(ss,fp)
+#define context_lr   uc_mcontext->DU3_PREFIX(ss,lr)
+#define context_sp   uc_mcontext->DU3_PREFIX(ss,sp)
+#define context_pc   uc_mcontext->DU3_PREFIX(ss,pc)
+#define context_cpsr uc_mcontext->DU3_PREFIX(ss,cpsr)
+
+address os::current_stack_pointer() {
+#if defined(__clang__) || defined(__llvm__)
+  void *sp;
+  __asm__("mov %0, " SPELL_REG_SP : "=r"(sp));
+  return (address) sp;
+#else
+  register void *sp __asm__ (SPELL_REG_SP);
+  return (address) sp;
+#endif
 }
 
 char* os::non_memory_address_word() {
@@ -88,23 +127,25 @@ char* os::non_memory_address_word() {
   // even in its subfields (as defined by the CPU immediate fields,
   // if the CPU splits constants across multiple instructions).
 
+  // the return value used in computation of Universe::non_oop_word(), which
+  // is loaded by cpu/aarch64 by MacroAssembler::movptr(Register, uintptr_t)
   return (char*) 0xffffffffffff;
 }
 
-address os::Linux::ucontext_get_pc(const ucontext_t * uc) {
-  return (address)uc->uc_mcontext.pc;
+address os::Bsd::ucontext_get_pc(const ucontext_t * uc) {
+  return (address)uc->context_pc;
 }
 
-void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
-  uc->uc_mcontext.pc = (intptr_t)pc;
+void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {
+  uc->context_pc = (intptr_t)pc ;
 }
 
-intptr_t* os::Linux::ucontext_get_sp(const ucontext_t * uc) {
-  return (intptr_t*)uc->uc_mcontext.sp;
+intptr_t* os::Bsd::ucontext_get_sp(const ucontext_t * uc) {
+  return (intptr_t*)uc->context_sp;
 }
 
-intptr_t* os::Linux::ucontext_get_fp(const ucontext_t * uc) {
-  return (intptr_t*)uc->uc_mcontext.regs[REG_FP];
+intptr_t* os::Bsd::ucontext_get_fp(const ucontext_t * uc) {
+  return (intptr_t*)uc->context_fp;
 }
 
 address os::fetch_frame_from_context(const void* ucVoid,
@@ -114,9 +155,9 @@ address os::fetch_frame_from_context(const void* ucVoid,
   const ucontext_t* uc = (const ucontext_t*)ucVoid;
 
   if (uc != NULL) {
-    epc = os::Linux::ucontext_get_pc(uc);
-    if (ret_sp) *ret_sp = os::Linux::ucontext_get_sp(uc);
-    if (ret_fp) *ret_fp = os::Linux::ucontext_get_fp(uc);
+    epc = os::Bsd::ucontext_get_pc(uc);
+    if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);
+    if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);
   } else {
     epc = NULL;
     if (ret_sp) *ret_sp = (intptr_t *)NULL;
@@ -133,8 +174,8 @@ frame os::fetch_frame_from_context(const void* ucVoid) {
   return frame(sp, fp, epc);
 }
 
-bool os::Linux::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
-  address pc = (address) os::Linux::ucontext_get_pc(uc);
+bool os::Bsd::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
+  address pc = (address) os::Bsd::ucontext_get_pc(uc);
   if (Interpreter::contains(pc)) {
     // interpreter performs stack banging after the fixed frame header has
     // been generated while the compilers perform it before. To maintain
@@ -157,9 +198,9 @@ bool os::Linux::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t*
       // In compiled code, the stack banging is performed before LR
       // has been saved in the frame.  LR is live, and SP and FP
       // belong to the caller.
-      intptr_t* fp = os::Linux::ucontext_get_fp(uc);
-      intptr_t* sp = os::Linux::ucontext_get_sp(uc);
-      address pc = (address)(uc->uc_mcontext.regs[REG_LR]
+      intptr_t* fp = os::Bsd::ucontext_get_fp(uc);
+      intptr_t* sp = os::Bsd::ucontext_get_sp(uc);
+      address pc = (address)(uc->context_lr
                          - NativeInstruction::instruction_size);
       *fr = frame(sp, fp, pc);
       if (!fr->is_java_frame()) {
@@ -193,7 +234,7 @@ NOINLINE frame os::current_frame() {
 }
 
 extern "C" JNIEXPORT int
-JVM_handle_linux_signal(int sig,
+JVM_handle_bsd_signal(int sig,
                         siginfo_t* info,
                         void* ucVoid,
                         int abort_if_unrecognized) {
@@ -210,13 +251,13 @@ JVM_handle_linux_signal(int sig,
   // Note: it's not uncommon that JNI code uses signal/sigset to install
   // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
   // or have a SIGILL handler when detecting CPU type). When that happens,
-  // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To
+  // JVM_handle_bsd_signal() might be invoked with junk info/ucVoid. To
   // avoid unnecessary crash when libjsig is not preloaded, try handle signals
   // that do not require siginfo/ucontext first.
 
   if (sig == SIGPIPE || sig == SIGXFSZ) {
     // allow chained handler to go first
-    if (os::Linux::chained_handler(sig, info, ucVoid)) {
+    if (os::Bsd::chained_handler(sig, info, ucVoid)) {
       return true;
     } else {
       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
@@ -234,10 +275,10 @@ JVM_handle_linux_signal(int sig,
 
   JavaThread* thread = NULL;
   VMThread* vmthread = NULL;
-  if (os::Linux::signal_handlers_are_installed) {
+  if (os::Bsd::signal_handlers_are_installed) {
     if (t != NULL ){
       if(t->is_Java_thread()) {
-        thread = t->as_Java_thread();
+        thread = (JavaThread*)t;
       }
       else if(t->is_VM_thread()){
         vmthread = (VMThread *)t;
@@ -245,7 +286,7 @@ JVM_handle_linux_signal(int sig,
     }
   }
 /*
-  NOTE: does not seem to work on linux.
+  NOTE: does not seem to work on bsd.
   if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {
     // can't decode this kind of signal
     info = NULL;
@@ -260,22 +301,22 @@ JVM_handle_linux_signal(int sig,
 
   //%note os_trap_1
   if (info != NULL && uc != NULL && thread != NULL) {
-    pc = (address) os::Linux::ucontext_get_pc(uc);
+    pc = (address) os::Bsd::ucontext_get_pc(uc);
 
     if (StubRoutines::is_safefetch_fault(pc)) {
-      os::Linux::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
+      os::Bsd::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
       return 1;
     }
 
-    address addr = (address) info->si_addr;
+    // Handle ALL stack overflow variations here
+    if (sig == SIGSEGV || sig == SIGBUS) {
+      address addr = (address) info->si_addr;
 
-    // Make sure the high order byte is sign extended, as it may be masked away by the hardware.
-    if ((uintptr_t(addr) & (uintptr_t(1) << 55)) != 0) {
-      addr = address(uintptr_t(addr) | (uintptr_t(0xFF) << 56));
-    }
+      // Make sure the high order byte is sign extended, as it may be masked away by the hardware.
+      if ((uintptr_t(addr) & (uintptr_t(1) << 55)) != 0) {
+        addr = address(uintptr_t(addr) | (uintptr_t(0xFF) << 56));
+      }
 
-    // Handle ALL stack overflow variations here
-    if (sig == SIGSEGV) {
       // check if fault address is within thread stack
       if (thread->is_in_full_stack(addr)) {
         // stack overflow
@@ -283,7 +324,7 @@ JVM_handle_linux_signal(int sig,
           if (thread->thread_state() == _thread_in_Java) {
             if (thread->in_stack_reserved_zone(addr)) {
               frame fr;
-              if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &fr)) {
+              if (os::Bsd::get_frame_at_stack_banging_point(thread, uc, &fr)) {
                 assert(fr.is_java_frame(), "Must be a Java frame");
                 frame activation =
                   SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
@@ -313,44 +354,37 @@ JVM_handle_linux_signal(int sig,
           // to handle_unexpected_exception way down below.
           thread->disable_stack_red_zone();
           tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
-
-          // This is a likely cause, but hard to verify. Let's just print
-          // it as a hint.
-          tty->print_raw_cr("Please check if any of your loaded .so files has "
-                            "enabled executable stack (see man page execstack(8))");
-        } else {
-          // Accessing stack address below sp may cause SEGV if current
-          // thread has MAP_GROWSDOWN stack. This should only happen when
-          // current thread was created by user code with MAP_GROWSDOWN flag
-          // and then attached to VM. See notes in os_linux.cpp.
-          if (thread->osthread()->expanding_stack() == 0) {
-             thread->osthread()->set_expanding_stack();
-             if (os::Linux::manually_expand_stack(thread, addr)) {
-               thread->osthread()->clear_expanding_stack();
-               return 1;
-             }
-             thread->osthread()->clear_expanding_stack();
-          } else {
-             fatal("recursive segv. expanding stack.");
-          }
         }
       }
     }
 
-    if (thread->thread_state() == _thread_in_Java) {
+    // We test if stub is already set (by the stack overflow code
+    // above) so it is not overwritten by the code that follows. This
+    // check is not required on other platforms, because on other
+    // platforms we check for SIGSEGV only or SIGBUS only, where here
+    // we have to check for both SIGSEGV and SIGBUS.
+    if (thread->thread_state() == _thread_in_Java && stub == NULL) {
       // Java thread running in Java code => find exception handler if any
       // a fault inside compiled code, the interpreter, or a stub
 
       // Handle signal from NativeJump::patch_verified_entry().
-      if ((sig == SIGILL || sig == SIGTRAP)
+      if ((sig == SIGILL)
           && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {
         if (TraceTraps) {
-          tty->print_cr("trap: zombie_not_entrant (%s)", (sig == SIGTRAP) ? "SIGTRAP" : "SIGILL");
+          tty->print_cr("trap: zombie_not_entrant");
         }
         stub = SharedRuntime::get_handle_wrong_method_stub();
-      } else if (sig == SIGSEGV && SafepointMechanism::is_poll_address((address)info->si_addr)) {
+      } else if ((sig == SIGSEGV || sig == SIGBUS) && SafepointMechanism::is_poll_address((address)info->si_addr)) {
         stub = SharedRuntime::get_poll_stub(pc);
+#if defined(__APPLE__)
+      // 32-bit Darwin reports a SIGBUS for nearly all memory access exceptions.
+      // 64-bit Darwin may also use a SIGBUS (seen with compressed oops).
+      // Catching SIGBUS here prevents the implicit SIGBUS NULL check below from
+      // being called, so only do so if the implicit NULL check is not necessary.
+      } else if (sig == SIGBUS && !MacroAssembler::uses_implicit_null_check(info->si_addr)) {
+#else
       } else if (sig == SIGBUS /* && info->si_code == BUS_OBJERR */) {
+#endif
         // BugId 4454115: A read from a MappedByteBuffer can fault
         // here if the underlying file has been truncated.
         // Do not crash the VM in such a case.
@@ -390,8 +424,13 @@ JVM_handle_linux_signal(int sig,
                                               pc,
                                               SharedRuntime::
                                               IMPLICIT_DIVIDE_BY_ZERO);
-      } else if (sig == SIGSEGV &&
-                 MacroAssembler::uses_implicit_null_check((void*)addr)) {
+#ifdef __APPLE__
+      } else if (sig == SIGFPE && info->si_code == FPE_NOOP) {
+        Unimplemented();
+#endif /* __APPLE__ */
+
+      } else if ((sig == SIGSEGV || sig == SIGBUS) &&
+                 MacroAssembler::uses_implicit_null_check(info->si_addr)) {
           // Determination of interpreter/vtable stub/compiled code null exception
           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
       }
@@ -420,12 +459,12 @@ JVM_handle_linux_signal(int sig,
     // save all thread context in case we need to restore it
     if (thread != NULL) thread->set_saved_exception_pc(pc);
 
-    os::Linux::ucontext_set_pc(uc, stub);
+    os::Bsd::ucontext_set_pc(uc, stub);
     return true;
   }
 
   // signal-chaining
-  if (os::Linux::chained_handler(sig, info, ucVoid)) {
+  if (os::Bsd::chained_handler(sig, info, ucVoid)) {
      return true;
   }
 
@@ -435,7 +474,7 @@ JVM_handle_linux_signal(int sig,
   }
 
   if (pc == NULL && uc != NULL) {
-    pc = os::Linux::ucontext_get_pc(uc);
+    pc = os::Bsd::ucontext_get_pc(uc);
   }
 
   // unmask current signal
@@ -450,14 +489,7 @@ JVM_handle_linux_signal(int sig,
   return true; // Mute compiler
 }
 
-void os::Linux::init_thread_fpu_state(void) {
-}
-
-int os::Linux::get_fpu_control_word(void) {
-  return 0;
-}
-
-void os::Linux::set_fpu_control_word(int fpu_control) {
+void os::Bsd::init_thread_fpu_state(void) {
 }
 
 bool os::is_allocatable(size_t bytes) {
@@ -480,6 +512,116 @@ size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
   return s;
 }
 
+
+// Java thread:
+//
+//   Low memory addresses
+//    +------------------------+
+//    |                        |\  Java thread created by VM does not have glibc
+//    |    glibc guard page    | - guard, attached Java thread usually has
+//    |                        |/  1 glibc guard page.
+// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
+//    |                        |\
+//    |  HotSpot Guard Pages   | - red, yellow and reserved pages
+//    |                        |/
+//    +------------------------+ JavaThread::stack_reserved_zone_base()
+//    |                        |\
+//    |      Normal Stack      | -
+//    |                        |/
+// P2 +------------------------+ Thread::stack_base()
+//
+// Non-Java thread:
+//
+//   Low memory addresses
+//    +------------------------+
+//    |                        |\
+//    |  glibc guard page      | - usually 1 page
+//    |                        |/
+// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
+//    |                        |\
+//    |      Normal Stack      | -
+//    |                        |/
+// P2 +------------------------+ Thread::stack_base()
+//
+// ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from
+//    pthread_attr_getstack()
+
+static void current_stack_region(address * bottom, size_t * size) {
+#ifdef __APPLE__
+  pthread_t self = pthread_self();
+  void *stacktop = pthread_get_stackaddr_np(self);
+  *size = pthread_get_stacksize_np(self);
+  // workaround for OS X 10.9.0 (Mavericks)
+  // pthread_get_stacksize_np returns 128 pages even though the actual size is 2048 pages
+  if (pthread_main_np() == 1) {
+    // At least on Mac OS 10.12 we have observed stack sizes not aligned
+    // to pages boundaries. This can be provoked by e.g. setrlimit() (ulimit -s xxxx in the
+    // shell). Apparently Mac OS actually rounds upwards to next multiple of page size,
+    // however, we round downwards here to be on the safe side.
+    *size = align_down(*size, getpagesize());
+
+    if ((*size) < (DEFAULT_MAIN_THREAD_STACK_PAGES * (size_t)getpagesize())) {
+      char kern_osrelease[256];
+      size_t kern_osrelease_size = sizeof(kern_osrelease);
+      int ret = sysctlbyname("kern.osrelease", kern_osrelease, &kern_osrelease_size, NULL, 0);
+      if (ret == 0) {
+        // get the major number, atoi will ignore the minor amd micro portions of the version string
+        if (atoi(kern_osrelease) >= OS_X_10_9_0_KERNEL_MAJOR_VERSION) {
+          *size = (DEFAULT_MAIN_THREAD_STACK_PAGES*getpagesize());
+        }
+      }
+    }
+  }
+  *bottom = (address) stacktop - *size;
+#elif defined(__OpenBSD__)
+  stack_t ss;
+  int rslt = pthread_stackseg_np(pthread_self(), &ss);
+
+  if (rslt != 0)
+    fatal("pthread_stackseg_np failed with error = %d", rslt);
+
+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);
+  *size   = ss.ss_size;
+#else
+  pthread_attr_t attr;
+
+  int rslt = pthread_attr_init(&attr);
+
+  // JVM needs to know exact stack location, abort if it fails
+  if (rslt != 0)
+    fatal("pthread_attr_init failed with error = %d", rslt);
+
+  rslt = pthread_attr_get_np(pthread_self(), &attr);
+
+  if (rslt != 0)
+    fatal("pthread_attr_get_np failed with error = %d", rslt);
+
+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||
+    pthread_attr_getstacksize(&attr, size) != 0) {
+    fatal("Can not locate current stack attributes!");
+  }
+
+  pthread_attr_destroy(&attr);
+#endif
+  assert(os::current_stack_pointer() >= *bottom &&
+         os::current_stack_pointer() < *bottom + *size, "just checking");
+}
+
+address os::current_stack_base() {
+  address bottom;
+  size_t size;
+  current_stack_region(&bottom, &size);
+  return (bottom + size);
+}
+
+size_t os::current_stack_size() {
+  // stack size includes normal stack and HotSpot guard pages
+  address bottom;
+  size_t size;
+  current_stack_region(&bottom, &size);
+  return size;
+}
+
 /////////////////////////////////////////////////////////////////////////////
 // helper functions for fatal error handler
 
@@ -488,21 +630,59 @@ void os::print_context(outputStream *st, const void *context) {
 
   const ucontext_t *uc = (const ucontext_t*)context;
   st->print_cr("Registers:");
-  for (int r = 0; r < 31; r++) {
-    st->print("R%-2d=", r);
-    print_location(st, uc->uc_mcontext.regs[r]);
-  }
+  st->print( " x0=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 0]);
+  st->print("  x1=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 1]);
+  st->print("  x2=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 2]);
+  st->print("  x3=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 3]);
+  st->cr();
+  st->print( " x4=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 4]);
+  st->print("  x5=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 5]);
+  st->print("  x6=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 6]);
+  st->print("  x7=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 7]);
+  st->cr();
+  st->print( " x8=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 8]);
+  st->print("  x9=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 9]);
+  st->print(" x10=" INTPTR_FORMAT, (intptr_t)uc->context_x[10]);
+  st->print(" x11=" INTPTR_FORMAT, (intptr_t)uc->context_x[11]);
+  st->cr();
+  st->print( "x12=" INTPTR_FORMAT, (intptr_t)uc->context_x[12]);
+  st->print(" x13=" INTPTR_FORMAT, (intptr_t)uc->context_x[13]);
+  st->print(" x14=" INTPTR_FORMAT, (intptr_t)uc->context_x[14]);
+  st->print(" x15=" INTPTR_FORMAT, (intptr_t)uc->context_x[15]);
+  st->cr();
+  st->print( "x16=" INTPTR_FORMAT, (intptr_t)uc->context_x[16]);
+  st->print(" x17=" INTPTR_FORMAT, (intptr_t)uc->context_x[17]);
+  st->print(" x18=" INTPTR_FORMAT, (intptr_t)uc->context_x[18]);
+  st->print(" x19=" INTPTR_FORMAT, (intptr_t)uc->context_x[19]);
+  st->cr();
+  st->print( "x20=" INTPTR_FORMAT, (intptr_t)uc->context_x[20]);
+  st->print(" x21=" INTPTR_FORMAT, (intptr_t)uc->context_x[21]);
+  st->print(" x22=" INTPTR_FORMAT, (intptr_t)uc->context_x[22]);
+  st->print(" x23=" INTPTR_FORMAT, (intptr_t)uc->context_x[23]);
+  st->cr();
+  st->print( "x24=" INTPTR_FORMAT, (intptr_t)uc->context_x[24]);
+  st->print(" x25=" INTPTR_FORMAT, (intptr_t)uc->context_x[25]);
+  st->print(" x26=" INTPTR_FORMAT, (intptr_t)uc->context_x[26]);
+  st->print(" x27=" INTPTR_FORMAT, (intptr_t)uc->context_x[27]);
+  st->cr();
+  st->print( "x28=" INTPTR_FORMAT, (intptr_t)uc->context_x[28]);
+  st->print("  fp=" INTPTR_FORMAT, (intptr_t)uc->context_fp);
+  st->print("  lr=" INTPTR_FORMAT, (intptr_t)uc->context_lr);
+  st->print("  sp=" INTPTR_FORMAT, (intptr_t)uc->context_sp);
+  st->cr();
+  st->print(  "pc=" INTPTR_FORMAT,  (intptr_t)uc->context_pc);
+  st->print(" cpsr=" INTPTR_FORMAT, (intptr_t)uc->context_cpsr);
   st->cr();
 
-  intptr_t *sp = (intptr_t *)os::Linux::ucontext_get_sp(uc);
-  st->print_cr("Top of Stack: (sp=" PTR_FORMAT ")", p2i(sp));
+  intptr_t *sp = (intptr_t *)os::Bsd::ucontext_get_sp(uc);
+  st->print_cr("Top of Stack: (sp=" INTPTR_FORMAT ")", (intptr_t)sp);
   print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));
   st->cr();
 
   // Note: it may be unsafe to inspect memory near pc. For example, pc may
   // point to garbage if entry point in an nmethod is corrupted. Leave
   // this at the end, and hope for the best.
-  address pc = os::Linux::ucontext_get_pc(uc);
+  address pc = os::Bsd::ucontext_get_pc(uc);
   print_instructions(st, pc, 4/*native instruction size*/);
   st->cr();
 }
@@ -521,8 +701,36 @@ void os::print_register_info(outputStream *st, const void *context) {
 
   // this is only for the "general purpose" registers
 
-  for (int r = 0; r < 31; r++)
-    st->print_cr(  "R%d=" INTPTR_FORMAT, r, (uintptr_t)uc->uc_mcontext.regs[r]);
+  st->print(" x0="); print_location(st, uc->context_x[ 0]);
+  st->print(" x1="); print_location(st, uc->context_x[ 1]);
+  st->print(" x2="); print_location(st, uc->context_x[ 2]);
+  st->print(" x3="); print_location(st, uc->context_x[ 3]);
+  st->print(" x4="); print_location(st, uc->context_x[ 4]);
+  st->print(" x5="); print_location(st, uc->context_x[ 5]);
+  st->print(" x6="); print_location(st, uc->context_x[ 6]);
+  st->print(" x7="); print_location(st, uc->context_x[ 7]);
+  st->print(" x8="); print_location(st, uc->context_x[ 8]);
+  st->print(" x9="); print_location(st, uc->context_x[ 9]);
+  st->print("x10="); print_location(st, uc->context_x[10]);
+  st->print("x11="); print_location(st, uc->context_x[11]);
+  st->print("x12="); print_location(st, uc->context_x[12]);
+  st->print("x13="); print_location(st, uc->context_x[13]);
+  st->print("x14="); print_location(st, uc->context_x[14]);
+  st->print("x15="); print_location(st, uc->context_x[15]);
+  st->print("x16="); print_location(st, uc->context_x[16]);
+  st->print("x17="); print_location(st, uc->context_x[17]);
+  st->print("x18="); print_location(st, uc->context_x[18]);
+  st->print("x19="); print_location(st, uc->context_x[19]);
+  st->print("x20="); print_location(st, uc->context_x[20]);
+  st->print("x21="); print_location(st, uc->context_x[21]);
+  st->print("x22="); print_location(st, uc->context_x[22]);
+  st->print("x23="); print_location(st, uc->context_x[23]);
+  st->print("x24="); print_location(st, uc->context_x[24]);
+  st->print("x25="); print_location(st, uc->context_x[25]);
+  st->print("x26="); print_location(st, uc->context_x[26]);
+  st->print("x27="); print_location(st, uc->context_x[27]);
+  st->print("x28="); print_location(st, uc->context_x[28]);
+
   st->cr();
 }
 
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
index 494a7e621b8..56bb1f4e70c 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
@@ -39,10 +39,4 @@
     *(jlong *) dst = *(const jlong *) src;
   }
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-public:
-
 #endif // OS_CPU_BSD_AARCH64_OS_BSD_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/threadLS_bsd_aarch64.s b/src/hotspot/os_cpu/bsd_aarch64/threadLS_bsd_aarch64.s
deleted file mode 100644
index f541844b9d6..00000000000
--- a/src/hotspot/os_cpu/bsd_aarch64/threadLS_bsd_aarch64.s
+++ /dev/null
@@ -1,44 +0,0 @@
-// Copyright (c) 2015, Red Hat Inc. All rights reserved.
-// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-//
-// This code is free software; you can redistribute it and/or modify it
-// under the terms of the GNU General Public License version 2 only, as
-// published by the Free Software Foundation.
-//
-// This code is distributed in the hope that it will be useful, but WITHOUT
-// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-// version 2 for more details (a copy is included in the LICENSE file that
-// accompanied this code).
-//
-// You should have received a copy of the GNU General Public License version
-// 2 along with this work; if not, write to the Free Software Foundation,
-// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-//
-// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-// or visit www.oracle.com if you need additional information or have any
-// questions.
-
-        // JavaThread::aarch64_get_thread_helper()
-        //
-        // Return the current thread pointer in x0.
-        // Clobber x1, flags.
-        // All other registers are preserved,
-
-	.global	_ZN10JavaThread25aarch64_get_thread_helperEv
-	.type	_ZN10JavaThread25aarch64_get_thread_helperEv, %function
-
-_ZN10JavaThread25aarch64_get_thread_helperEv:
-	stp x29, x30, [sp, -16]!
-	adrp x0, :tlsdesc:_ZN6Thread12_thr_currentE
-	ldr x1, [x0, #:tlsdesc_lo12:_ZN6Thread12_thr_currentE]
-	add x0, x0, :tlsdesc_lo12:_ZN6Thread12_thr_currentE
-	.tlsdesccall _ZN6Thread12_thr_currentE
-	blr x1
-	mrs x1, tpidr_el0
-	add x0, x1, x0
-	ldr x0, [x0]
-	ldp x29, x30, [sp], 16
-	ret
-
-	.size _ZN10JavaThread25aarch64_get_thread_helperEv, .-_ZN10JavaThread25aarch64_get_thread_helperEv
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
index 799d2cf87d1..efdeed96cfd 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
@@ -30,6 +30,7 @@
 
 frame JavaThread::pd_last_frame() {
   assert(has_last_Java_frame(), "must have last_Java_sp() when suspended");
+  vmassert(_anchor.last_Java_pc() != NULL, "not walkable");
   return frame(_anchor.last_Java_sp(), _anchor.last_Java_fp(), _anchor.last_Java_pc());
 }
 
@@ -47,10 +48,13 @@ bool JavaThread::pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext,
 }
 
 bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava) {
+  assert(this->is_Java_thread(), "must be JavaThread");
+  JavaThread* jt = (JavaThread *)this;
+
   // If we have a last_Java_frame, then we should use it even if
   // isInJava == true.  It should be more reliable than ucontext info.
-  if (has_last_Java_frame() && frame_anchor()->walkable()) {
-    *fr_addr = pd_last_frame();
+  if (jt->has_last_Java_frame() && jt->frame_anchor()->walkable()) {
+    *fr_addr = jt->pd_last_frame();
     return true;
   }
 
@@ -75,10 +79,10 @@ bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava)
     }
 
     frame ret_frame(ret_sp, ret_fp, addr);
-    if (!ret_frame.safe_for_sender(this)) {
+    if (!ret_frame.safe_for_sender(jt)) {
 #ifdef COMPILER2
       frame ret_frame2(ret_sp, NULL, addr);
-      if (!ret_frame2.safe_for_sender(this)) {
+      if (!ret_frame2.safe_for_sender(jt)) {
         // nothing else to try if the frame isn't good
         return false;
       }
@@ -97,3 +101,4 @@ bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava)
 }
 
 void JavaThread::cache_global_variables() { }
+
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
index 945dceb6e2e..5f55e27345f 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
@@ -27,16 +27,6 @@
 #define OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP
 
  private:
-#ifdef ASSERT
-  // spill stack holds N callee-save registers at each Java call and
-  // grows downwards towards limit
-  // we need limit to check we have space for a spill and base so we
-  // can identify all live spill frames at GC (eventually)
-  address          _spill_stack;
-  address          _spill_stack_base;
-  address          _spill_stack_limit;
-#endif // ASSERT
-
   void pd_initialize() {
     _anchor.clear();
   }
@@ -69,7 +59,9 @@
   bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);
 public:
 
-  static Thread *aarch64_get_thread_helper();
+  static Thread *aarch64_get_thread_helper() {
+    return Thread::current();
+  }
 
   // These routines are only used on cpu architectures that
   // have separate register stacks (Itanium).
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
index 7c483d685cb..1abe32cf165 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
@@ -36,17 +36,16 @@
   /* Threads (NOTE: incomplete) */                                                                                                   \
   /******************************/                                                                                                   \
   nonstatic_field(OSThread,                      _thread_id,                                      OSThread::thread_id_t)             \
-  nonstatic_field(OSThread,                      _pthread_id,                                     pthread_t)
+  nonstatic_field(OSThread,                      _unique_thread_id,                               uint64_t)
 
 
 #define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \
                                                                           \
   /**********************/                                                \
-  /* Posix Thread IDs   */                                                \
+  /* Thread IDs         */                                                \
   /**********************/                                                \
                                                                           \
-  declare_integer_type(OSThread::thread_id_t)                             \
-  declare_unsigned_integer_type(pthread_t)
+  declare_unsigned_integer_type(OSThread::thread_id_t)
 
 #define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)
 
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
index d5fb3f4680b..e4ae30c4cff 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
@@ -27,140 +27,3 @@
 #include "runtime/os.hpp"
 #include "runtime/vm_version.hpp"
 
-#include <asm/hwcap.h>
-#include <sys/auxv.h>
-#include <sys/prctl.h>
-
-#ifndef HWCAP_AES
-#define HWCAP_AES   (1<<3)
-#endif
-
-#ifndef HWCAP_PMULL
-#define HWCAP_PMULL (1<<4)
-#endif
-
-#ifndef HWCAP_SHA1
-#define HWCAP_SHA1  (1<<5)
-#endif
-
-#ifndef HWCAP_SHA2
-#define HWCAP_SHA2  (1<<6)
-#endif
-
-#ifndef HWCAP_CRC32
-#define HWCAP_CRC32 (1<<7)
-#endif
-
-#ifndef HWCAP_ATOMICS
-#define HWCAP_ATOMICS (1<<8)
-#endif
-
-#ifndef HWCAP_DCPOP
-#define HWCAP_DCPOP (1<<16)
-#endif
-
-#ifndef HWCAP_SHA512
-#define HWCAP_SHA512 (1 << 21)
-#endif
-
-#ifndef HWCAP_SVE
-#define HWCAP_SVE (1 << 22)
-#endif
-
-#ifndef HWCAP2_SVE2
-#define HWCAP2_SVE2 (1 << 1)
-#endif
-
-#ifndef PR_SVE_GET_VL
-// For old toolchains which do not have SVE related macros defined.
-#define PR_SVE_SET_VL   50
-#define PR_SVE_GET_VL   51
-#endif
-
-int VM_Version::get_current_sve_vector_length() {
-  assert(_features & CPU_SVE, "should not call this");
-  return prctl(PR_SVE_GET_VL);
-}
-
-int VM_Version::set_and_get_current_sve_vector_lenght(int length) {
-  assert(_features & CPU_SVE, "should not call this");
-  int new_length = prctl(PR_SVE_SET_VL, length);
-  return new_length;
-}
-
-void VM_Version::get_os_cpu_info() {
-
-  uint64_t auxv = getauxval(AT_HWCAP);
-  uint64_t auxv2 = getauxval(AT_HWCAP2);
-
-  static_assert(CPU_FP      == HWCAP_FP);
-  static_assert(CPU_ASIMD   == HWCAP_ASIMD);
-  static_assert(CPU_EVTSTRM == HWCAP_EVTSTRM);
-  static_assert(CPU_AES     == HWCAP_AES);
-  static_assert(CPU_PMULL   == HWCAP_PMULL);
-  static_assert(CPU_SHA1    == HWCAP_SHA1);
-  static_assert(CPU_SHA2    == HWCAP_SHA2);
-  static_assert(CPU_CRC32   == HWCAP_CRC32);
-  static_assert(CPU_LSE     == HWCAP_ATOMICS);
-  static_assert(CPU_DCPOP   == HWCAP_DCPOP);
-  static_assert(CPU_SHA512  == HWCAP_SHA512);
-  static_assert(CPU_SVE     == HWCAP_SVE);
-  _features = auxv & (
-      HWCAP_FP      |
-      HWCAP_ASIMD   |
-      HWCAP_EVTSTRM |
-      HWCAP_AES     |
-      HWCAP_PMULL   |
-      HWCAP_SHA1    |
-      HWCAP_SHA2    |
-      HWCAP_CRC32   |
-      HWCAP_ATOMICS |
-      HWCAP_DCPOP   |
-      HWCAP_SHA512  |
-      HWCAP_SVE);
-
-  if (auxv2 & HWCAP2_SVE2) _features |= CPU_SVE2;
-
-  uint64_t ctr_el0;
-  uint64_t dczid_el0;
-  __asm__ (
-    "mrs %0, CTR_EL0\n"
-    "mrs %1, DCZID_EL0\n"
-    : "=r"(ctr_el0), "=r"(dczid_el0)
-  );
-
-  _icache_line_size = (1 << (ctr_el0 & 0x0f)) * 4;
-  _dcache_line_size = (1 << ((ctr_el0 >> 16) & 0x0f)) * 4;
-
-  if (!(dczid_el0 & 0x10)) {
-    _zva_length = 4 << (dczid_el0 & 0xf);
-  }
-
-  int cpu_lines = 0;
-  if (FILE *f = fopen("/proc/cpuinfo", "r")) {
-    // need a large buffer as the flags line may include lots of text
-    char buf[1024], *p;
-    while (fgets(buf, sizeof (buf), f) != NULL) {
-      if ((p = strchr(buf, ':')) != NULL) {
-        long v = strtol(p+1, NULL, 0);
-        if (strncmp(buf, "CPU implementer", sizeof "CPU implementer" - 1) == 0) {
-          _cpu = v;
-          cpu_lines++;
-        } else if (strncmp(buf, "CPU variant", sizeof "CPU variant" - 1) == 0) {
-          _variant = v;
-        } else if (strncmp(buf, "CPU part", sizeof "CPU part" - 1) == 0) {
-          if (_model != v)  _model2 = _model;
-          _model = v;
-        } else if (strncmp(buf, "CPU revision", sizeof "CPU revision" - 1) == 0) {
-          _revision = v;
-        } else if (strncmp(buf, "flags", sizeof("flags") - 1) == 0) {
-          if (strstr(p+1, "dcpop")) {
-            guarantee(_features & CPU_DCPOP, "dcpop availability should be consistent");
-          }
-        }
-      }
-    }
-    fclose(f);
-  }
-  guarantee(cpu_lines == os::processor_count(), "core count should be consistent");
-}

From 39042c49668c6d88e33942d809753ed354569ec3 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Wed, 30 Sep 2020 06:15:02 -0700
Subject: [PATCH 09/94] JDK-8253816: W^X part for bsd_aarch64

---
 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index d00cee436eb..c4967f8a3b8 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -319,6 +319,7 @@ JVM_handle_bsd_signal(int sig,
 
       // check if fault address is within thread stack
       if (thread->is_in_full_stack(addr)) {
+        Thread::WXWriteFromExecSetter wx_write;
         // stack overflow
         if (thread->in_stack_yellow_reserved_zone(addr)) {
           if (thread->thread_state() == _thread_in_Java) {
@@ -366,6 +367,7 @@ JVM_handle_bsd_signal(int sig,
     if (thread->thread_state() == _thread_in_Java && stub == NULL) {
       // Java thread running in Java code => find exception handler if any
       // a fault inside compiled code, the interpreter, or a stub
+      Thread::WXWriteFromExecSetter wx_write;
 
       // Handle signal from NativeJump::patch_verified_entry().
       if ((sig == SIGILL)

From 8ab282dc355dc3047546b088a5c2dfbeb32607f7 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Thu, 1 Oct 2020 02:43:29 -0700
Subject: [PATCH 10/94] JDK-8253819: Finish the bsd_aarch64

---
 src/hotspot/os/bsd/os_bsd.cpp                       | 2 +-
 src/java.base/macosx/native/libjli/java_md_macosx.m | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/hotspot/os/bsd/os_bsd.cpp b/src/hotspot/os/bsd/os_bsd.cpp
index 1d1701ed6db..35d6febf536 100644
--- a/src/hotspot/os/bsd/os_bsd.cpp
+++ b/src/hotspot/os/bsd/os_bsd.cpp
@@ -3195,7 +3195,7 @@ int os::active_processor_count() {
   return _processor_count;
 }
 
-#ifdef __APPLE__
+#if defined(__APPLE__) && defined(__x86_64__)
 uint os::processor_id() {
   // Get the initial APIC id and return the associated processor id. The initial APIC
   // id is limited to 8-bits, which means we can have at most 256 unique APIC ids. If
diff --git a/src/java.base/macosx/native/libjli/java_md_macosx.m b/src/java.base/macosx/native/libjli/java_md_macosx.m
index cf55e05f35d..d6b13c4afdb 100644
--- a/src/java.base/macosx/native/libjli/java_md_macosx.m
+++ b/src/java.base/macosx/native/libjli/java_md_macosx.m
@@ -210,6 +210,8 @@
         preferredJVM = "client";
 #elif defined(__x86_64__)
         preferredJVM = "server";
+#elif defined(__aarch64__)
+        preferredJVM = "server";
 #else
 #error "Unknown architecture - needs definition"
 #endif

From 82895a8b7ee0c30616cc62ded1aadeb56d7a3e05 Mon Sep 17 00:00:00 2001
From: Ludovic Henry <luhenry@microsoft.com>
Date: Tue, 3 Nov 2020 22:28:45 +0100
Subject: [PATCH 11/94] Add macOS-AArch64 build and platform support code  (#2)

Co-authored-by: Bernhard Urban-Forster <beurba@microsoft.com>
Co-authored-by: Mat Carter <macarte@microsoft.com>
---
 make/autoconf/flags-cflags.m4                 |   2 +-
 make/autoconf/flags.m4                        |  12 +-
 make/hotspot/gensrc/GensrcAdlc.gmk            |  11 +-
 .../java.desktop/lib/Awt2dLibraries.gmk       |   4 +-
 make/modules/jdk.hotspot.agent/Lib.gmk        |   2 +-
 make/test/JtregNativeJdk.gmk                  |   2 +-
 src/hotspot/cpu/aarch64/aarch64.ad            |   4 +-
 .../cpu/aarch64/c1_FrameMap_aarch64.cpp       |   6 +-
 .../cpu/aarch64/globalDefinitions_aarch64.hpp |   2 +-
 .../cpu/aarch64/macroAssembler_aarch64.cpp    |   2 +-
 src/hotspot/cpu/aarch64/register_aarch64.cpp  |   2 +-
 src/hotspot/cpu/aarch64/register_aarch64.hpp  |   2 +-
 .../aarch64/register_definitions_aarch64.cpp  |   2 +-
 .../cpu/aarch64/stubGenerator_aarch64.cpp     |   2 +-
 .../cpu/aarch64/vm_version_aarch64.hpp        |   1 +
 src/hotspot/os/bsd/os_bsd.cpp                 |   2 +
 src/hotspot/os/posix/signals_posix.cpp        |   2 +-
 .../os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp |   2 +-
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.cpp     |  49 ++++++
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.hpp     |   2 +-
 .../os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp |   6 +-
 .../os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp |   1 +
 .../bsd_aarch64/vm_version_bsd_aarch64.cpp    |   5 +-
 src/hotspot/share/c1/c1_Runtime1.cpp          |   2 +
 src/hotspot/share/runtime/globals.hpp         |   2 +-
 .../macosx/native/libjava/java_props_macosx.c |  34 ++--
 .../macosx/native/libawt_lwawt/awt/AWTView.m  |  10 +-
 .../native/libawt_lwawt/awt/OSVersion.m       |  61 -------
 .../share/native/libharfbuzz/hb-coretext.cc   |   2 +
 .../native/libsaproc/MacosxDebuggerLocal.m    | 150 +++++++++++++++---
 .../macosx/native/libsaproc/libproc_impl.h    |  53 +++++++
 .../macosx/native/libsaproc/ps_core.c         | 132 +++++++++++++++
 .../classes/sun/jvm/hotspot/HotSpotAgent.java |   4 +-
 .../sun/jvm/hotspot/asm/Disassembler.java     |   9 +-
 .../hotspot/debugger/bsd/BsdCDebugger.java    |   9 ++
 .../debugger/bsd/BsdThreadContextFactory.java |   3 +
 .../bsd/aarch64/BsdAARCH64CFrame.java         |  85 ++++++++++
 .../bsd/aarch64/BsdAARCH64ThreadContext.java} |  31 +++-
 .../sun/jvm/hotspot/runtime/Threads.java      |   3 +
 .../BsdAARCH64JavaThreadPDAccess.java         | 139 ++++++++++++++++
 .../compiler/c2/aarch64/TestSVEWithJNI.java   |   2 +-
 .../compiler/c2/aarch64/libTestSVEWithJNI.c   |   2 +-
 42 files changed, 698 insertions(+), 160 deletions(-)
 delete mode 100644 src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.m
 create mode 100644 src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
 rename src/{java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.h => jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java} (56%)
 create mode 100644 src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java

diff --git a/make/autoconf/flags-cflags.m4 b/make/autoconf/flags-cflags.m4
index 588df7f0011..77032dbddaa 100644
--- a/make/autoconf/flags-cflags.m4
+++ b/make/autoconf/flags-cflags.m4
@@ -165,7 +165,7 @@ AC_DEFUN([FLAGS_SETUP_WARNINGS],
           -Wunused-function -Wundef -Wunused-value -Woverloaded-virtual"
       WARNINGS_ENABLE_ALL="-Wall -Wextra -Wformat=2 $WARNINGS_ENABLE_ADDITIONAL"
 
-      DISABLED_WARNINGS="unknown-warning-option unused-parameter unused"
+      DISABLED_WARNINGS="unknown-warning-option unused-parameter unused format-nonliteral"
 
       if test "x$OPENJDK_TARGET_OS" = xmacosx; then
         # missing-method-return-type triggers in JavaNativeFoundation framework
diff --git a/make/autoconf/flags.m4 b/make/autoconf/flags.m4
index 0301e64dc17..a47db905d55 100644
--- a/make/autoconf/flags.m4
+++ b/make/autoconf/flags.m4
@@ -125,19 +125,25 @@ AC_DEFUN([FLAGS_SETUP_MACOSX_VERSION],
 [
   # Additional macosx handling
   if test "x$OPENJDK_TARGET_OS" = xmacosx; then
+    # The expected format for <version> is either nn.n.n or nn.nn.nn. See
+    # /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/AvailabilityVersions.h
+
     # MACOSX_VERSION_MIN specifies the lowest version of Macosx that the built
     # binaries should be compatible with, even if compiled on a newer version
     # of the OS. It currently has a hard coded value. Setting this also limits
     # exposure to API changes in header files. Bumping this is likely to
     # require code changes to build.
-    MACOSX_VERSION_MIN=10.9.0
+    if test "x$OPENJDK_TARGET_CPU_ARCH" = xaarch64; then
+      MACOSX_VERSION_MIN=11.00.00
+    else
+      MACOSX_VERSION_MIN=10.9.0
+    fi
     MACOSX_VERSION_MIN_NODOTS=${MACOSX_VERSION_MIN//\./}
 
     AC_SUBST(MACOSX_VERSION_MIN)
 
     # Setting --with-macosx-version-max=<version> makes it an error to build or
-    # link to macosx APIs that are newer than the given OS version. The expected
-    # format for <version> is either nn.n.n or nn.nn.nn. See /usr/include/AvailabilityMacros.h.
+    # link to macosx APIs that are newer than the given OS version.
     AC_ARG_WITH([macosx-version-max], [AS_HELP_STRING([--with-macosx-version-max],
         [error on use of newer functionality. @<:@macosx@:>@])],
         [
diff --git a/make/hotspot/gensrc/GensrcAdlc.gmk b/make/hotspot/gensrc/GensrcAdlc.gmk
index 733658d5d8b..d76951e42dd 100644
--- a/make/hotspot/gensrc/GensrcAdlc.gmk
+++ b/make/hotspot/gensrc/GensrcAdlc.gmk
@@ -92,9 +92,6 @@ ifeq ($(call check-jvm-feature, compiler2), true)
     ifeq ($(call isTargetCpuBits, 64), true)
       ADLCFLAGS += -D_WIN64=1
     endif
-    ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)
-      ADLCFLAGS += -DR18_RESERVED
-    endif
   endif
 
   ifeq ($(call isTargetOs, windows), false)
@@ -119,6 +116,14 @@ ifeq ($(call check-jvm-feature, compiler2), true)
     ADLCFLAGS += -DARM=1
   endif
 
+  ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)
+    ifeq ($(call isTargetOs, windows), true)
+      ADLCFLAGS += -DR18_RESERVED
+    else ifeq ($(call isTargetOs, macosx), true)
+      ADLCFLAGS += -DR18_RESERVED
+    endif
+  endif
+
   ##############################################################################
   # Concatenate all ad source files into a single file, which will be fed to
   # adlc. Also include a #line directive at the start of every included file
diff --git a/make/modules/java.desktop/lib/Awt2dLibraries.gmk b/make/modules/java.desktop/lib/Awt2dLibraries.gmk
index 7fbd1049f89..8c38eb65930 100644
--- a/make/modules/java.desktop/lib/Awt2dLibraries.gmk
+++ b/make/modules/java.desktop/lib/Awt2dLibraries.gmk
@@ -566,6 +566,7 @@ $(eval $(call SetupJdkLibrary, BUILD_LIBFONTMANAGER, \
     CFLAGS_windows = -DCC_NOEX, \
     EXTRA_HEADER_DIRS := $(LIBFONTMANAGER_EXTRA_HEADER_DIRS), \
     WARNINGS_AS_ERRORS_xlc := false, \
+    DISABLED_WARNINGS_clang := deprecated-declarations, \
     LDFLAGS := $(subst -Xlinker -z -Xlinker defs,, \
         $(subst -Wl$(COMMA)-z$(COMMA)defs,,$(LDFLAGS_JDKLIB))) $(LDFLAGS_CXX_JDK) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
@@ -790,7 +791,8 @@ ifeq ($(ENABLE_HEADLESS_ONLY), false)
       DISABLED_WARNINGS_gcc := sign-compare type-limits unused-result \
           maybe-uninitialized shift-negative-value implicit-fallthrough \
           unused-function, \
-      DISABLED_WARNINGS_clang := incompatible-pointer-types sign-compare, \
+      DISABLED_WARNINGS_clang := incompatible-pointer-types sign-compare \
+          deprecated-declarations, \
       DISABLED_WARNINGS_microsoft := 4018 4244 4267, \
       LDFLAGS := $(LDFLAGS_JDKLIB) \
           $(call SET_SHARED_LIBRARY_ORIGIN), \
diff --git a/make/modules/jdk.hotspot.agent/Lib.gmk b/make/modules/jdk.hotspot.agent/Lib.gmk
index 827b4bc4f28..8525cff9690 100644
--- a/make/modules/jdk.hotspot.agent/Lib.gmk
+++ b/make/modules/jdk.hotspot.agent/Lib.gmk
@@ -31,7 +31,7 @@ ifeq ($(call isTargetOs, linux), true)
   SA_CFLAGS := -D_FILE_OFFSET_BITS=64
 
 else ifeq ($(call isTargetOs, macosx), true)
-  SA_CFLAGS := -Damd64 -D_GNU_SOURCE -mno-omit-leaf-frame-pointer \
+  SA_CFLAGS := -D_GNU_SOURCE -mno-omit-leaf-frame-pointer \
       -mstack-alignment=16 -fPIC
   LIBSA_EXTRA_SRC := $(SUPPORT_OUTPUTDIR)/gensrc/jdk.hotspot.agent
 else ifeq ($(call isTargetOs, windows), true)
diff --git a/make/test/JtregNativeJdk.gmk b/make/test/JtregNativeJdk.gmk
index ecd587c3d3d..57c5bf4035e 100644
--- a/make/test/JtregNativeJdk.gmk
+++ b/make/test/JtregNativeJdk.gmk
@@ -78,7 +78,7 @@ endif
 ifeq ($(call isTargetOs, macosx), true)
   BUILD_JDK_JTREG_EXCLUDE += exelauncher.c
   BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libTestMainKeyWindow := -ObjC
-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestMainKeyWindow := -framework JavaVM \
+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestMainKeyWindow := \
       -framework Cocoa -framework JavaNativeFoundation
   BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeJniInvocationTest := -ljli
 else
diff --git a/src/hotspot/cpu/aarch64/aarch64.ad b/src/hotspot/cpu/aarch64/aarch64.ad
index 695c3bd61a0..6ac129246ad 100644
--- a/src/hotspot/cpu/aarch64/aarch64.ad
+++ b/src/hotspot/cpu/aarch64/aarch64.ad
@@ -114,8 +114,8 @@ reg_def R16     ( SOC, SOC, Op_RegI, 16, r16->as_VMReg()        );
 reg_def R16_H   ( SOC, SOC, Op_RegI, 16, r16->as_VMReg()->next());
 reg_def R17     ( SOC, SOC, Op_RegI, 17, r17->as_VMReg()        );
 reg_def R17_H   ( SOC, SOC, Op_RegI, 17, r17->as_VMReg()->next());
-reg_def R18     ( SOC, SOC, Op_RegI, 18, r18_tls->as_VMReg()        );
-reg_def R18_H   ( SOC, SOC, Op_RegI, 18, r18_tls->as_VMReg()->next());
+reg_def R18     ( SOC, SOC, Op_RegI, 18, r18_reserved->as_VMReg()        );
+reg_def R18_H   ( SOC, SOC, Op_RegI, 18, r18_reserved->as_VMReg()->next());
 reg_def R19     ( SOC, SOE, Op_RegI, 19, r19->as_VMReg()        );
 reg_def R19_H   ( SOC, SOE, Op_RegI, 19, r19->as_VMReg()->next());
 reg_def R20     ( SOC, SOE, Op_RegI, 20, r20->as_VMReg()        ); // caller esp
diff --git a/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp b/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp
index 42ff62a986c..cca87b70eb6 100644
--- a/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp
@@ -183,7 +183,7 @@ void FrameMap::initialize() {
   map_register(i, r17); r17_opr = LIR_OprFact::single_cpu(i); i++;
 #ifndef R18_RESERVED
   // See comment in register_aarch64.hpp
-  map_register(i, r18_tls); r18_opr = LIR_OprFact::single_cpu(i); i++;
+  map_register(i, r18_reserved); r18_opr = LIR_OprFact::single_cpu(i); i++;
 #endif
   map_register(i, r19); r19_opr = LIR_OprFact::single_cpu(i); i++;
   map_register(i, r20); r20_opr = LIR_OprFact::single_cpu(i); i++;
@@ -204,7 +204,7 @@ void FrameMap::initialize() {
 
 #ifdef R18_RESERVED
   // See comment in register_aarch64.hpp
-  map_register(i, r18_tls); r18_opr = LIR_OprFact::single_cpu(i); i++;
+  map_register(i, r18_reserved); r18_opr = LIR_OprFact::single_cpu(i); i++;
 #endif
 
   rscratch1_opr = r8_opr;
@@ -264,7 +264,7 @@ void FrameMap::initialize() {
   r15_oop_opr = as_oop_opr(r15);
   r16_oop_opr = as_oop_opr(r16);
   r17_oop_opr = as_oop_opr(r17);
-  r18_oop_opr = as_oop_opr(r18_tls);
+  r18_oop_opr = as_oop_opr(r18_reserved);
   r19_oop_opr = as_oop_opr(r19);
   r20_oop_opr = as_oop_opr(r20);
   r21_oop_opr = as_oop_opr(r21);
diff --git a/src/hotspot/cpu/aarch64/globalDefinitions_aarch64.hpp b/src/hotspot/cpu/aarch64/globalDefinitions_aarch64.hpp
index 523dbf1e602..c85ba66bce1 100644
--- a/src/hotspot/cpu/aarch64/globalDefinitions_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/globalDefinitions_aarch64.hpp
@@ -58,7 +58,7 @@ const bool CCallingConventionRequiresIntsAsLongs = false;
 
 #define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false
 
-#if defined(_WIN64)
+#if defined(__APPLE__) || defined(_WIN64)
 #define R18_RESERVED
 #define R18_RESERVED_ONLY(code) code
 #define NOT_R18_RESERVED(code)
diff --git a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
index 61bbae2381d..3a62718b223 100644
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
@@ -2648,7 +2648,7 @@ void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[])
 RegSet MacroAssembler::call_clobbered_registers() {
   RegSet regs = RegSet::range(r0, r17) - RegSet::of(rscratch1, rscratch2);
 #ifndef R18_RESERVED
-  regs += r18_tls;
+  regs += r18_reserved;
 #endif
   return regs;
 }
diff --git a/src/hotspot/cpu/aarch64/register_aarch64.cpp b/src/hotspot/cpu/aarch64/register_aarch64.cpp
index 24c3f32c2b6..d24a47f2dbe 100644
--- a/src/hotspot/cpu/aarch64/register_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/register_aarch64.cpp
@@ -41,7 +41,7 @@ const char* RegisterImpl::name() const {
     "c_rarg0", "c_rarg1", "c_rarg2", "c_rarg3", "c_rarg4", "c_rarg5", "c_rarg6", "c_rarg7",
     "rscratch1", "rscratch2",
     "r10", "r11", "r12", "r13", "r14", "r15", "r16",
-    "r17", "r18_tls", "r19",
+    "r17", "r18_reserved", "r19",
     "resp", "rdispatch", "rbcp", "r23", "rlocals", "rmonitors", "rcpool", "rheapbase",
     "rthread", "rfp", "lr", "sp"
   };
diff --git a/src/hotspot/cpu/aarch64/register_aarch64.hpp b/src/hotspot/cpu/aarch64/register_aarch64.hpp
index c567791e593..221be3f322a 100644
--- a/src/hotspot/cpu/aarch64/register_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/register_aarch64.hpp
@@ -103,7 +103,7 @@ CONSTANT_REGISTER_DECLARATION(Register, r17,  (17));
 // It's easier to avoid allocating r18 altogether.
 //
 // See https://docs.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions?view=vs-2019#integer-registers
-CONSTANT_REGISTER_DECLARATION(Register, r18_tls,  (18));
+CONSTANT_REGISTER_DECLARATION(Register, r18_reserved,  (18));
 CONSTANT_REGISTER_DECLARATION(Register, r19,  (19));
 CONSTANT_REGISTER_DECLARATION(Register, r20,  (20));
 CONSTANT_REGISTER_DECLARATION(Register, r21,  (21));
diff --git a/src/hotspot/cpu/aarch64/register_definitions_aarch64.cpp b/src/hotspot/cpu/aarch64/register_definitions_aarch64.cpp
index f48c70d09e6..482f77e0e4a 100644
--- a/src/hotspot/cpu/aarch64/register_definitions_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/register_definitions_aarch64.cpp
@@ -50,7 +50,7 @@ REGISTER_DEFINITION(Register, r14);
 REGISTER_DEFINITION(Register, r15);
 REGISTER_DEFINITION(Register, r16);
 REGISTER_DEFINITION(Register, r17);
-REGISTER_DEFINITION(Register, r18_tls); // see comment in register_aarch64.hpp
+REGISTER_DEFINITION(Register, r18_reserved); // see comment in register_aarch64.hpp
 REGISTER_DEFINITION(Register, r19);
 REGISTER_DEFINITION(Register, r20);
 REGISTER_DEFINITION(Register, r21);
diff --git a/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp b/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
index 412578eea5c..f305ef49f48 100644
--- a/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
@@ -5069,7 +5069,7 @@ class StubGenerator: public StubCodeGenerator {
 
       // Register allocation
 
-      RegSetIterator regs = (RegSet::range(r0, r26) - r18_tls).begin();
+      RegSetIterator regs = (RegSet::range(r0, r26) - r18_reserved).begin();
       Pa_base = *regs;       // Argument registers
       if (squaring)
         Pb_base = Pa_base;
diff --git a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
index d3b25cc44aa..a8a814315ac 100644
--- a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
@@ -90,6 +90,7 @@ class VM_Version : public Abstract_VM_Version {
     CPU_QUALCOM   = 'Q',
     CPU_MARVELL   = 'V',
     CPU_INTEL     = 'i',
+    CPU_APPLE     = 'a',
   };
 
   enum Feature_Flag {
diff --git a/src/hotspot/os/bsd/os_bsd.cpp b/src/hotspot/os/bsd/os_bsd.cpp
index ebe35390242..70b36a8519b 100644
--- a/src/hotspot/os/bsd/os_bsd.cpp
+++ b/src/hotspot/os/bsd/os_bsd.cpp
@@ -213,6 +213,8 @@ static char cpu_arch[] = "arm";
 static char cpu_arch[] = "aarch64";
 #elif defined(PPC32)
 static char cpu_arch[] = "ppc";
+#elif defined(AARCH64)
+static char cpu_arch[] = "aarch64";
 #else
   #error Add appropriate cpu_arch setting
 #endif
diff --git a/src/hotspot/os/posix/signals_posix.cpp b/src/hotspot/os/posix/signals_posix.cpp
index 4eea0664566..07c706cccc2 100644
--- a/src/hotspot/os/posix/signals_posix.cpp
+++ b/src/hotspot/os/posix/signals_posix.cpp
@@ -1188,7 +1188,7 @@ void PosixSignals::install_signal_handlers() {
     // exception handling, while leaving the standard BSD signal handlers functional.
     kern_return_t kr;
     kr = task_set_exception_ports(mach_task_self(),
-                                  EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,
+                                  EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC,
                                   MACH_PORT_NULL,
                                   EXCEPTION_STATE_IDENTITY,
                                   MACHINE_THREAD_STATE);
diff --git a/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp
index 39d5ffe9bbe..457ef4c6bd2 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp
@@ -41,4 +41,4 @@ class ICache : public AbstractICache {
   }
 };
 
-#endif // OS_CPU_BSD_AARCH64_ICACHE_AARCH64_HPP
\ No newline at end of file
+#endif // OS_CPU_BSD_AARCH64_ICACHE_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index bdb6b7d84c0..7a74a1f8f3d 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -111,6 +111,7 @@
 #define context_sp   uc_mcontext->DU3_PREFIX(ss,sp)
 #define context_pc   uc_mcontext->DU3_PREFIX(ss,pc)
 #define context_cpsr uc_mcontext->DU3_PREFIX(ss,cpsr)
+#define context_esr  uc_mcontext->DU3_PREFIX(es,esr)
 
 address os::current_stack_pointer() {
 #if defined(__clang__) || defined(__llvm__)
@@ -463,6 +464,50 @@ PRAGMA_DIAG_POP
     }
   }
 
+#if defined(ASSERT) && defined(__APPLE__)
+  // Execution protection violation
+  //
+  // This should be kept as the last step in the triage.  We don't
+  // have a dedicated trap number for a no-execute fault, so be
+  // conservative and allow other handlers the first shot.
+  if (UnguardOnExecutionViolation > 0 &&
+      (sig == SIGBUS)) {
+    static __thread address last_addr = (address) -1;
+
+    address addr = (address) info->si_addr;
+    address pc = os::Bsd::ucontext_get_pc(uc);
+
+    if (pc != addr && uc->context_esr == 0x9200004F) { //TODO: figure out what this value means
+      // We are faulting trying to write a R-X page
+      pthread_jit_write_protect_np(false);
+
+      log_debug(os)("Writing protection violation "
+                    "at " INTPTR_FORMAT
+                    ", unprotecting", p2i(addr));
+
+      stub = pc;
+
+      last_addr = (address) -1;
+    } else if (pc == addr && uc->context_esr == 0x8200000f) { //TODO: figure out what this value means
+      // We are faulting trying to execute a RW- page
+
+      if (addr != last_addr) {
+        pthread_jit_write_protect_np(true);
+
+        log_debug(os)("Execution protection violation "
+                      "at " INTPTR_FORMAT
+                      ", protecting", p2i(addr));
+
+        stub = pc;
+
+        // Set last_addr so if we fault again at the same address, we don't end
+        // up in an endless loop.
+        last_addr = addr;
+      }
+    }
+  }
+#endif
+
   if (stub != NULL) {
     // save all thread context in case we need to restore it
     if (thread != NULL) thread->set_saved_exception_pc(pc);
@@ -756,6 +801,10 @@ int os::extra_bang_size_in_bytes() {
   return 0;
 }
 
+void os::current_thread_enable_wx_impl(WXMode mode) {
+  pthread_jit_write_protect_np(mode == WXExec);
+}
+
 extern "C" {
   int SpinPause() {
     return 0;
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
index a17c6a2e719..821728697e6 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
@@ -36,7 +36,7 @@
 
 private:
 
-  static void current_thread_enable_wx_impl(WXMode mode) { }
+  static void current_thread_enable_wx_impl(WXMode mode);
 
 public:
 
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
index efdeed96cfd..e791d7f6746 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
@@ -38,7 +38,6 @@ frame JavaThread::pd_last_frame() {
 // currently interrupted by SIGPROF
 bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr,
   void* ucontext, bool isInJava) {
-
   assert(Thread::current() == this, "caller must be current thread");
   return pd_get_top_frame(fr_addr, ucontext, isInJava);
 }
@@ -80,7 +79,8 @@ bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava)
 
     frame ret_frame(ret_sp, ret_fp, addr);
     if (!ret_frame.safe_for_sender(jt)) {
-#ifdef COMPILER2
+#if COMPILER2_OR_JVMCI
+      // C2 and JVMCI use ebp as a general register see if NULL fp helps
       frame ret_frame2(ret_sp, NULL, addr);
       if (!ret_frame2.safe_for_sender(jt)) {
         // nothing else to try if the frame isn't good
@@ -90,7 +90,7 @@ bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava)
 #else
       // nothing else to try if the frame isn't good
       return false;
-#endif /* COMPILER2 */
+#endif // COMPILER2_OR_JVMCI
     }
     *fr_addr = ret_frame;
     return true;
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
index 83d9a00628a..795058fca05 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
@@ -51,6 +51,7 @@
     bool isInJava);
 
   bool pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava);
+
 private:
   bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);
 public:
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
index 259dbcda96b..57a62fde87d 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
@@ -27,7 +27,6 @@
 #include "runtime/os.hpp"
 #include "runtime/vm_version.hpp"
 
-
 int VM_Version::get_current_sve_vector_length() {
   ShouldNotReachHere();
   return -1;
@@ -39,4 +38,8 @@ int VM_Version::set_and_get_current_sve_vector_lenght(int length) {
 }
 
 void VM_Version::get_os_cpu_info() {
+  _icache_line_size = _dcache_line_size = 64;
+
+  // Disable DC ZVA
+  _zva_length = -1;
 }
diff --git a/src/hotspot/share/c1/c1_Runtime1.cpp b/src/hotspot/share/c1/c1_Runtime1.cpp
index 6c776670cac..207c6ddf90a 100644
--- a/src/hotspot/share/c1/c1_Runtime1.cpp
+++ b/src/hotspot/share/c1/c1_Runtime1.cpp
@@ -1269,6 +1269,8 @@ JRT_END
 void Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id) {
   NOT_PRODUCT(_patch_code_slowcase_cnt++);
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   if (TracePatching) {
     tty->print_cr("Deoptimizing because patch is needed");
   }
diff --git a/src/hotspot/share/runtime/globals.hpp b/src/hotspot/share/runtime/globals.hpp
index 85eb2412e25..7d7fdf07cd1 100644
--- a/src/hotspot/share/runtime/globals.hpp
+++ b/src/hotspot/share/runtime/globals.hpp
@@ -2233,7 +2233,7 @@ const intx ObjectAlignmentInBytes = 8;
           "Bypass Win32 file system criteria checks (Windows Only)")        \
                                                                             \
   product(intx, UnguardOnExecutionViolation, 0,                             \
-          "Unguard page and retry on no-execute fault (Win32 only) "        \
+          "Unguard page and retry on no-execute fault "                     \
           "0=off, 1=conservative, 2=aggressive")                            \
           range(0, 2)                                                       \
                                                                             \
diff --git a/src/java.base/macosx/native/libjava/java_props_macosx.c b/src/java.base/macosx/native/libjava/java_props_macosx.c
index df997e07417..7df1e15a926 100644
--- a/src/java.base/macosx/native/libjava/java_props_macosx.c
+++ b/src/java.base/macosx/native/libjava/java_props_macosx.c
@@ -222,37 +222,23 @@ char *setupMacOSXLocale(int cat) {
     }
 }
 
-// 10.9 SDK does not include the NSOperatingSystemVersion struct.
-// For now, create our own
-typedef struct {
-        NSInteger majorVersion;
-        NSInteger minorVersion;
-        NSInteger patchVersion;
-} OSVerStruct;
-
 void setOSNameAndVersion(java_props_t *sprops) {
     // Hardcode os_name, and fill in os_version
     sprops->os_name = strdup("Mac OS X");
 
     char* osVersionCStr = NULL;
-    // Mac OS 10.9 includes the [NSProcessInfo operatingSystemVersion] function,
-    // but it's not in the 10.9 SDK.  So, call it via objc_msgSend_stret.
-    if ([[NSProcessInfo processInfo] respondsToSelector:@selector(operatingSystemVersion)]) {
-        OSVerStruct (*procInfoFn)(id rec, SEL sel) = (OSVerStruct(*)(id, SEL))objc_msgSend_stret;
-        OSVerStruct osVer = procInfoFn([NSProcessInfo processInfo],
-                                       @selector(operatingSystemVersion));
-        NSString *nsVerStr;
-        if (osVer.patchVersion == 0) { // Omit trailing ".0"
-            nsVerStr = [NSString stringWithFormat:@"%ld.%ld",
-                    (long)osVer.majorVersion, (long)osVer.minorVersion];
-        } else {
-            nsVerStr = [NSString stringWithFormat:@"%ld.%ld.%ld",
-                    (long)osVer.majorVersion, (long)osVer.minorVersion, (long)osVer.patchVersion];
+    // Mac OS 10.2 includes the [NSProcessInfo operatingSystemVersionString] function,
+    // but it's not in the 10.2 SDK.  So, call it via objc_msgSend_stret.
+    if ([[NSProcessInfo processInfo] respondsToSelector:@selector(operatingSystemVersionString)]) {
+        NSString* (*procInfoFn)(id rec, SEL sel) = (NSString* (*)(id, SEL))objc_msgSend;
+        NSString *nsVerStr = procInfoFn([NSProcessInfo processInfo],
+                                       @selector(operatingSystemVersionString));
+        if (nsVerStr != NULL) {
+            // Copy out the char*
+            osVersionCStr = strdup([nsVerStr UTF8String]);
         }
-        // Copy out the char*
-        osVersionCStr = strdup([nsVerStr UTF8String]);
     }
-    // Fallback if running on pre-10.9 Mac OS
+    // Fallback if running on pre-10.2 Mac OS
     if (osVersionCStr == NULL) {
         NSDictionary *version = [NSDictionary dictionaryWithContentsOfFile :
                                  @"/System/Library/CoreServices/SystemVersion.plist"];
diff --git a/src/java.desktop/macosx/native/libawt_lwawt/awt/AWTView.m b/src/java.desktop/macosx/native/libawt_lwawt/awt/AWTView.m
index 3e80b5a6cf3..e41beb256fe 100644
--- a/src/java.desktop/macosx/native/libawt_lwawt/awt/AWTView.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/awt/AWTView.m
@@ -31,7 +31,6 @@
 #import "JavaTextAccessibility.h"
 #import "JavaAccessibilityUtilities.h"
 #import "GeomUtilities.h"
-#import "OSVersion.h"
 #import "ThreadUtilities.h"
 
 #import <Carbon/Carbon.h>
@@ -52,13 +51,6 @@ -(NSMutableString *) parseString : (id) complexString;
 //#define IM_DEBUG TRUE
 //#define EXTRA_DEBUG
 
-static BOOL shouldUsePressAndHold() {
-    static int shouldUsePressAndHold = -1;
-    if (shouldUsePressAndHold != -1) return shouldUsePressAndHold;
-    shouldUsePressAndHold = !isSnowLeopardOrLower();
-    return shouldUsePressAndHold;
-}
-
 @implementation AWTView
 
 @synthesize _dropTarget;
@@ -81,7 +73,7 @@ - (id) initWithRect: (NSRect) rect
     fKeyEventsNeeded = NO;
     fProcessingKeystroke = NO;
 
-    fEnablePressAndHold = shouldUsePressAndHold();
+    fEnablePressAndHold = YES; // always true since Snow Leopard
     fInPressAndHold = NO;
     fPAHNeedsToSelect = NO;
 
diff --git a/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.m b/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.m
deleted file mode 100644
index 93951abe1c8..00000000000
--- a/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.m
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-// Support for detecting Mac OS X Versions
-
-#include <math.h>
-#include <stdlib.h>
-#include <stdio.h>
-#import <JavaRuntimeSupport/JavaRuntimeSupport.h>
-
-
-// returns 107 for Lion, 106 for SnowLeopard etc.
-int getOSXMajorVersion() {
-    char *ver = JRSCopyOSVersion();
-    if (ver == NULL) {
-        return 0;
-    }
-
-    int len = strlen(ver);
-    int v = 0;
-
-    // Third char must be a '.'
-    if (len >= 3 && ver[2] == '.') {
-        int i;
-
-        v = (ver[0] - '0') * 10 + (ver[1] - '0');
-        for (i = 3; i < len && isdigit(ver[i]); ++i) {
-            v = v * 10 + (ver[i] - '0');
-        }
-    }
-
-    free(ver);
-
-    return v;
-}
-
-BOOL isSnowLeopardOrLower() {
-    return (getOSXMajorVersion() < 107);
-}
diff --git a/src/java.desktop/share/native/libharfbuzz/hb-coretext.cc b/src/java.desktop/share/native/libharfbuzz/hb-coretext.cc
index f8d03085bd9..03d2672336b 100644
--- a/src/java.desktop/share/native/libharfbuzz/hb-coretext.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-coretext.cc
@@ -205,6 +205,7 @@ create_ct_font (CGFontRef cg_font, CGFloat font_size)
    * reconfiguring the cascade list causes CoreText crashes. For details, see
    * crbug.com/549610 */
   // 0x00070000 stands for "kCTVersionNumber10_10", see CoreText.h
+#if TARGET_OS_OSX && MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_10
   if (&CTGetCoreTextVersion != nullptr && CTGetCoreTextVersion() < 0x00070000) {
     CFStringRef fontName = CTFontCopyPostScriptName (ct_font);
     bool isEmojiFont = CFStringCompare (fontName, CFSTR("AppleColorEmoji"), 0) == kCFCompareEqualTo;
@@ -212,6 +213,7 @@ create_ct_font (CGFontRef cg_font, CGFloat font_size)
     if (!isEmojiFont)
       return ct_font;
   }
+#endif
 
   CFURLRef original_url = nullptr;
 #if TARGET_OS_OSX && MAC_OS_X_VERSION_MIN_REQUIRED < 1060
diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
index cfbf7f9b787..5a8d7c028fb 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
@@ -44,14 +44,10 @@
 #import <sys/ptrace.h>
 #include "libproc_impl.h"
 
-#define UNSUPPORTED_ARCH "Unsupported architecture!"
-
-#if defined(x86_64) && !defined(amd64)
-#define amd64 1
-#endif
-
-#if amd64
+#if defined(amd64)
 #include "sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h"
+#elif defined(aarch64)
+#include "sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h"
 #else
 #error UNSUPPORTED_ARCH
 #endif
@@ -164,20 +160,20 @@ static void throw_new_debugger_exception(JNIEnv* env, const char* errMsg) {
   return (struct ps_prochandle*)(intptr_t)ptr;
 }
 
-#if defined(__i386__)
-    #define hsdb_thread_state_t     x86_thread_state32_t
-    #define hsdb_float_state_t      x86_float_state32_t
-    #define HSDB_THREAD_STATE       x86_THREAD_STATE32
-    #define HSDB_FLOAT_STATE        x86_FLOAT_STATE32
-    #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE32_COUNT
-    #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE32_COUNT
-#elif defined(__x86_64__)
+#if defined(amd64)
     #define hsdb_thread_state_t     x86_thread_state64_t
     #define hsdb_float_state_t      x86_float_state64_t
     #define HSDB_THREAD_STATE       x86_THREAD_STATE64
     #define HSDB_FLOAT_STATE        x86_FLOAT_STATE64
     #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE64_COUNT
     #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE64_COUNT
+#elif defined(aarch64)
+    #define hsdb_thread_state_t     arm_thread_state64_t
+    #define hsdb_float_state_t      arm_float_state64_t
+    #define HSDB_THREAD_STATE       ARM_THREAD_STATE64
+    #define HSDB_FLOAT_STATE        ARM_NEON_STATE64
+    #define HSDB_THREAD_STATE_COUNT ARM_THREAD_STATE64_COUNT
+    #define HSDB_FLOAT_STATE_COUNT  ARM_NEON_STATE64_COUNT
 #else
     #error UNSUPPORTED_ARCH
 #endif
@@ -462,11 +458,21 @@ bool fill_java_threads(JNIEnv* env, jobject this_obj, struct ps_prochandle* ph)
       lwpid_t  uid = cinfos[j];
       uint64_t beg = cinfos[j + 1];
       uint64_t end = cinfos[j + 2];
+#if defined(amd64)
       if ((regs.r_rsp < end && regs.r_rsp >= beg) ||
           (regs.r_rbp < end && regs.r_rbp >= beg)) {
         set_lwp_id(ph, i, uid);
         break;
       }
+#elif defined(aarch64)
+      if ((regs.r_sp < end && regs.r_sp >= beg) ||
+          (regs.r_fp < end && regs.r_fp >= beg)) {
+        set_lwp_id(ph, i, uid);
+        break;
+      }
+#else
+#error UNSUPPORTED_ARCH
+#endif
     }
   }
   (*env)->ReleaseLongArrayElements(env, thrinfos, (jlong*)cinfos, 0);
@@ -497,15 +503,23 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
   }
 
 #undef NPRGREG
-#undef REG_INDEX
-#if amd64
+#if defined(amd64)
 #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
-#define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
+#elif defined(aarch64)
+#define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG
+#else
+#error UNSUPPORTED_ARCH
+#endif
 
   array = (*env)->NewLongArray(env, NPRGREG);
   CHECK_EXCEPTION_(0);
   regs = (*env)->GetLongArrayElements(env, array, &isCopy);
 
+#undef REG_INDEX
+
+#if defined(amd64)
+#define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
+
   regs[REG_INDEX(R15)] = gregs.r_r15;
   regs[REG_INDEX(R14)] = gregs.r_r14;
   regs[REG_INDEX(R13)] = gregs.r_r13;
@@ -534,8 +548,48 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
   regs[REG_INDEX(TRAPNO)] = gregs.r_trapno;
   regs[REG_INDEX(RFL)]    = gregs.r_rflags;
 
+#elif defined(aarch64)
+#define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
+
+  regs[REG_INDEX(R0)] = gregs.r_r0;
+  regs[REG_INDEX(R1)] = gregs.r_r1;
+  regs[REG_INDEX(R2)] = gregs.r_r2;
+  regs[REG_INDEX(R3)] = gregs.r_r3;
+  regs[REG_INDEX(R4)] = gregs.r_r4;
+  regs[REG_INDEX(R5)] = gregs.r_r5;
+  regs[REG_INDEX(R6)] = gregs.r_r6;
+  regs[REG_INDEX(R7)] = gregs.r_r7;
+  regs[REG_INDEX(R8)] = gregs.r_r8;
+  regs[REG_INDEX(R9)] = gregs.r_r9;
+  regs[REG_INDEX(R10)] = gregs.r_r10;
+  regs[REG_INDEX(R11)] = gregs.r_r11;
+  regs[REG_INDEX(R12)] = gregs.r_r12;
+  regs[REG_INDEX(R13)] = gregs.r_r13;
+  regs[REG_INDEX(R14)] = gregs.r_r14;
+  regs[REG_INDEX(R15)] = gregs.r_r15;
+  regs[REG_INDEX(R16)] = gregs.r_r16;
+  regs[REG_INDEX(R17)] = gregs.r_r17;
+  regs[REG_INDEX(R18)] = gregs.r_r18;
+  regs[REG_INDEX(R19)] = gregs.r_r19;
+  regs[REG_INDEX(R20)] = gregs.r_r20;
+  regs[REG_INDEX(R21)] = gregs.r_r21;
+  regs[REG_INDEX(R22)] = gregs.r_r22;
+  regs[REG_INDEX(R23)] = gregs.r_r23;
+  regs[REG_INDEX(R24)] = gregs.r_r24;
+  regs[REG_INDEX(R25)] = gregs.r_r25;
+  regs[REG_INDEX(R26)] = gregs.r_r26;
+  regs[REG_INDEX(R27)] = gregs.r_r27;
+  regs[REG_INDEX(R28)] = gregs.r_r28;
+  regs[REG_INDEX(FP)] = gregs.r_fp;
+  regs[REG_INDEX(LR)] = gregs.r_lr;
+  regs[REG_INDEX(SP)] = gregs.r_sp;
+  regs[REG_INDEX(PC)] = gregs.r_pc;
+
+#else
+#error UNSUPPORTED_ARCH
+#endif
+
   (*env)->ReleaseLongArrayElements(env, array, regs, JNI_COMMIT);
-#endif /* amd64 */
   return array;
 }
 
@@ -630,10 +684,14 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
     return NULL;
   }
 
-#if amd64
+#undef NPRGREG
+#if defined(amd64)
 #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
-#undef REG_INDEX
-#define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
+#elif defined(aarch64)
+#define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG
+#else
+#error UNSUPPORTED_ARCH
+#endif
 
   // 64 bit
   print_debug("Getting threads for a 64-bit process\n");
@@ -641,6 +699,11 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
   CHECK_EXCEPTION_(0);
   primitiveArray = (*env)->GetLongArrayElements(env, registerArray, NULL);
 
+#undef REG_INDEX
+
+#if defined(amd64)
+#define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
+
   primitiveArray[REG_INDEX(R15)] = state.__r15;
   primitiveArray[REG_INDEX(R14)] = state.__r14;
   primitiveArray[REG_INDEX(R13)] = state.__r13;
@@ -669,14 +732,51 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
   primitiveArray[REG_INDEX(DS)] = 0;
   primitiveArray[REG_INDEX(FSBASE)] = 0;
   primitiveArray[REG_INDEX(GSBASE)] = 0;
-  print_debug("set registers\n");
 
-  (*env)->ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);
+#elif defined(aarch64)
+#define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
+
+  primitiveArray[REG_INDEX(R0)] = state.__x[0];
+  primitiveArray[REG_INDEX(R1)] = state.__x[1];
+  primitiveArray[REG_INDEX(R2)] = state.__x[2];
+  primitiveArray[REG_INDEX(R3)] = state.__x[3];
+  primitiveArray[REG_INDEX(R4)] = state.__x[4];
+  primitiveArray[REG_INDEX(R5)] = state.__x[5];
+  primitiveArray[REG_INDEX(R6)] = state.__x[6];
+  primitiveArray[REG_INDEX(R7)] = state.__x[7];
+  primitiveArray[REG_INDEX(R8)] = state.__x[8];
+  primitiveArray[REG_INDEX(R9)] = state.__x[9];
+  primitiveArray[REG_INDEX(R10)] = state.__x[10];
+  primitiveArray[REG_INDEX(R11)] = state.__x[11];
+  primitiveArray[REG_INDEX(R12)] = state.__x[12];
+  primitiveArray[REG_INDEX(R13)] = state.__x[13];
+  primitiveArray[REG_INDEX(R14)] = state.__x[14];
+  primitiveArray[REG_INDEX(R15)] = state.__x[15];
+  primitiveArray[REG_INDEX(R16)] = state.__x[16];
+  primitiveArray[REG_INDEX(R17)] = state.__x[17];
+  primitiveArray[REG_INDEX(R18)] = state.__x[18];
+  primitiveArray[REG_INDEX(R19)] = state.__x[19];
+  primitiveArray[REG_INDEX(R20)] = state.__x[20];
+  primitiveArray[REG_INDEX(R21)] = state.__x[21];
+  primitiveArray[REG_INDEX(R22)] = state.__x[22];
+  primitiveArray[REG_INDEX(R23)] = state.__x[23];
+  primitiveArray[REG_INDEX(R24)] = state.__x[24];
+  primitiveArray[REG_INDEX(R25)] = state.__x[25];
+  primitiveArray[REG_INDEX(R26)] = state.__x[26];
+  primitiveArray[REG_INDEX(R27)] = state.__x[27];
+  primitiveArray[REG_INDEX(R28)] = state.__x[28];
+  primitiveArray[REG_INDEX(FP)] = state.__fp;
+  primitiveArray[REG_INDEX(LR)] = state.__lr;
+  primitiveArray[REG_INDEX(SP)] = state.__sp;
+  primitiveArray[REG_INDEX(PC)] = state.__pc;
 
 #else
 #error UNSUPPORTED_ARCH
-#endif /* amd64 */
+#endif
 
+  print_debug("set registers\n");
+
+  (*env)->ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);
   return registerArray;
 }
 
diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
index 3084a5283c7..c12ee989b76 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
@@ -30,6 +30,16 @@
 #include "libproc.h"
 #include "symtab.h"
 
+#define UNSUPPORTED_ARCH "Unsupported architecture!"
+
+#if defined(__x86_64__) && !defined(amd64)
+#define amd64 1
+#endif
+
+#if defined(__arm64__) && !defined(aarch64)
+#define aarch64 1
+#endif
+
 #ifdef __APPLE__
 #include <inttypes.h>     // for PRIx64, 32, ...
 #include <pthread.h>
@@ -42,6 +52,7 @@
 #define register_t uint64_t
 #endif
 
+#if defined(amd64)
 /*** registers copied from bsd/amd64 */
 typedef struct reg {
   register_t      r_r15;
@@ -72,6 +83,48 @@ typedef struct reg {
   register_t      r_ss;          // not used
 } reg;
 
+#elif defined(aarch64)
+/*** registers copied from bsd/arm64 */
+typedef struct reg {
+   register_t     r_r0;
+   register_t     r_r1;
+   register_t     r_r2;
+   register_t     r_r3;
+   register_t     r_r4;
+   register_t     r_r5;
+   register_t     r_r6;
+   register_t     r_r7;
+   register_t     r_r8;
+   register_t     r_r9;
+   register_t     r_r10;
+   register_t     r_r11;
+   register_t     r_r12;
+   register_t     r_r13;
+   register_t     r_r14;
+   register_t     r_r15;
+   register_t     r_r16;
+   register_t     r_r17;
+   register_t     r_r18;
+   register_t     r_r19;
+   register_t     r_r20;
+   register_t     r_r21;
+   register_t     r_r22;
+   register_t     r_r23;
+   register_t     r_r24;
+   register_t     r_r25;
+   register_t     r_r26;
+   register_t     r_r27;
+   register_t     r_r28;
+   register_t     r_fp;
+   register_t     r_lr;
+   register_t     r_sp;
+   register_t     r_pc;
+} reg;
+
+#else
+#error UNSUPPORTED_ARCH
+#endif
+
 // convenient defs
 typedef struct mach_header_64 mach_header_64;
 typedef struct load_command load_command;
diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c b/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
index d06b53351b5..4745ec8d53a 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
@@ -33,8 +33,14 @@
 #include "ps_core_common.h"
 
 #ifdef __APPLE__
+#if defined(amd64)
 #include "sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h"
+#elif defined(aarch64)
+#include "sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h"
+#else
+#error UNSUPPORTED_ARCH
 #endif
+#endif /* __APPLE__ */
 
 // This file has the libproc implementation to read core files.
 // For live processes, refer to ps_proc.c. Portions of this is adapted
@@ -195,6 +201,8 @@ static ps_prochandle_ops core_ops = {
 void print_thread(sa_thread_info *threadinfo) {
   print_debug("thread added: %d\n", threadinfo->lwp_id);
   print_debug("registers:\n");
+
+#if defined(amd64)
   print_debug("  r_r15: 0x%" PRIx64 "\n", threadinfo->regs.r_r15);
   print_debug("  r_r14: 0x%" PRIx64 "\n", threadinfo->regs.r_r14);
   print_debug("  r_r13: 0x%" PRIx64 "\n", threadinfo->regs.r_r13);
@@ -216,6 +224,45 @@ void print_thread(sa_thread_info *threadinfo) {
   print_debug("  r_cs:  0x%" PRIx64 "\n", threadinfo->regs.r_cs);
   print_debug("  r_rsp: 0x%" PRIx64 "\n", threadinfo->regs.r_rsp);
   print_debug("  r_rflags: 0x%" PRIx64 "\n", threadinfo->regs.r_rflags);
+
+#elif defined(aarch64)
+  print_debug(" r_r0:  0x%" PRIx64 "\n", threadinfo->regs.r_r0);
+  print_debug(" r_r1:  0x%" PRIx64 "\n", threadinfo->regs.r_r1);
+  print_debug(" r_r2:  0x%" PRIx64 "\n", threadinfo->regs.r_r2);
+  print_debug(" r_r3:  0x%" PRIx64 "\n", threadinfo->regs.r_r3);
+  print_debug(" r_r4:  0x%" PRIx64 "\n", threadinfo->regs.r_r4);
+  print_debug(" r_r5:  0x%" PRIx64 "\n", threadinfo->regs.r_r5);
+  print_debug(" r_r6:  0x%" PRIx64 "\n", threadinfo->regs.r_r6);
+  print_debug(" r_r7:  0x%" PRIx64 "\n", threadinfo->regs.r_r7);
+  print_debug(" r_r8:  0x%" PRIx64 "\n", threadinfo->regs.r_r8);
+  print_debug(" r_r9:  0x%" PRIx64 "\n", threadinfo->regs.r_r9);
+  print_debug(" r_r10: 0x%" PRIx64 "\n", threadinfo->regs.r_r10);
+  print_debug(" r_r11: 0x%" PRIx64 "\n", threadinfo->regs.r_r11);
+  print_debug(" r_r12: 0x%" PRIx64 "\n", threadinfo->regs.r_r12);
+  print_debug(" r_r13: 0x%" PRIx64 "\n", threadinfo->regs.r_r13);
+  print_debug(" r_r14: 0x%" PRIx64 "\n", threadinfo->regs.r_r14);
+  print_debug(" r_r15: 0x%" PRIx64 "\n", threadinfo->regs.r_r15);
+  print_debug(" r_r16: 0x%" PRIx64 "\n", threadinfo->regs.r_r16);
+  print_debug(" r_r17: 0x%" PRIx64 "\n", threadinfo->regs.r_r17);
+  print_debug(" r_r18: 0x%" PRIx64 "\n", threadinfo->regs.r_r18);
+  print_debug(" r_r19: 0x%" PRIx64 "\n", threadinfo->regs.r_r19);
+  print_debug(" r_r20: 0x%" PRIx64 "\n", threadinfo->regs.r_r20);
+  print_debug(" r_r21: 0x%" PRIx64 "\n", threadinfo->regs.r_r21);
+  print_debug(" r_r22: 0x%" PRIx64 "\n", threadinfo->regs.r_r22);
+  print_debug(" r_r23: 0x%" PRIx64 "\n", threadinfo->regs.r_r23);
+  print_debug(" r_r24: 0x%" PRIx64 "\n", threadinfo->regs.r_r24);
+  print_debug(" r_r25: 0x%" PRIx64 "\n", threadinfo->regs.r_r25);
+  print_debug(" r_r26: 0x%" PRIx64 "\n", threadinfo->regs.r_r26);
+  print_debug(" r_r27: 0x%" PRIx64 "\n", threadinfo->regs.r_r27);
+  print_debug(" r_r28: 0x%" PRIx64 "\n", threadinfo->regs.r_r28);
+  print_debug(" r_fp:  0x%" PRIx64 "\n", threadinfo->regs.r_fp);
+  print_debug(" r_lr:  0x%" PRIx64 "\n", threadinfo->regs.r_lr);
+  print_debug(" r_sp:  0x%" PRIx64 "\n", threadinfo->regs.r_sp);
+  print_debug(" r_pc:  0x%" PRIx64 "\n", threadinfo->regs.r_pc);
+
+#else
+#error UNSUPPORTED_ARCH
+#endif
 }
 
 // read all segments64 commands from core file
@@ -269,6 +316,7 @@ static bool read_core_segments(struct ps_prochandle* ph) {
           goto err;
         }
         size += sizeof(thread_fc);
+#if defined(amd64)
         if (fc.flavor == x86_THREAD_STATE) {
           x86_thread_state_t thrstate;
           if (read(fd, (void *)&thrstate, sizeof(x86_thread_state_t)) != sizeof(x86_thread_state_t)) {
@@ -328,6 +376,90 @@ static bool read_core_segments(struct ps_prochandle* ph) {
           }
           size += sizeof(x86_exception_state_t);
         }
+
+#elif defined(aarch64)
+        if (fc.flavor == ARM_THREAD_STATE64) {
+          arm_thread_state64_t thrstate;
+          if (read(fd, (void *)&thrstate, sizeof(arm_thread_state64_t)) != sizeof(arm_thread_state64_t)) {
+            printf("Reading flavor, count failed.\n");
+            goto err;
+          }
+          size += sizeof(arm_thread_state64_t);
+          // create thread info list, update lwp_id later
+          sa_thread_info* newthr = add_thread_info(ph, (pthread_t) -1, (lwpid_t) num_threads++);
+          if (newthr == NULL) {
+            printf("create thread_info failed\n");
+            goto err;
+          }
+
+          // note __DARWIN_UNIX03 depengs on other definitions
+#if __DARWIN_UNIX03
+#define get_register_v(regst, regname) \
+  regst.__##regname
+#else
+#define get_register_v(regst, regname) \
+  regst.##regname
+#endif // __DARWIN_UNIX03
+          newthr->regs.r_r0  = get_register_v(thrstate, x[0]);
+          newthr->regs.r_r1  = get_register_v(thrstate, x[1]);
+          newthr->regs.r_r2  = get_register_v(thrstate, x[2]);
+          newthr->regs.r_r3  = get_register_v(thrstate, x[3]);
+          newthr->regs.r_r4  = get_register_v(thrstate, x[4]);
+          newthr->regs.r_r5  = get_register_v(thrstate, x[5]);
+          newthr->regs.r_r6  = get_register_v(thrstate, x[6]);
+          newthr->regs.r_r7  = get_register_v(thrstate, x[7]);
+          newthr->regs.r_r8  = get_register_v(thrstate, x[8]);
+          newthr->regs.r_r9  = get_register_v(thrstate, x[9]);
+          newthr->regs.r_r10 = get_register_v(thrstate, x[10]);
+          newthr->regs.r_r11 = get_register_v(thrstate, x[11]);
+          newthr->regs.r_r12 = get_register_v(thrstate, x[12]);
+          newthr->regs.r_r13 = get_register_v(thrstate, x[13]);
+          newthr->regs.r_r14 = get_register_v(thrstate, x[14]);
+          newthr->regs.r_r15 = get_register_v(thrstate, x[15]);
+          newthr->regs.r_r16 = get_register_v(thrstate, x[16]);
+          newthr->regs.r_r17 = get_register_v(thrstate, x[17]);
+          newthr->regs.r_r18 = get_register_v(thrstate, x[18]);
+          newthr->regs.r_r19 = get_register_v(thrstate, x[19]);
+          newthr->regs.r_r20 = get_register_v(thrstate, x[20]);
+          newthr->regs.r_r21 = get_register_v(thrstate, x[21]);
+          newthr->regs.r_r22 = get_register_v(thrstate, x[22]);
+          newthr->regs.r_r23 = get_register_v(thrstate, x[23]);
+          newthr->regs.r_r24 = get_register_v(thrstate, x[24]);
+          newthr->regs.r_r25 = get_register_v(thrstate, x[25]);
+          newthr->regs.r_r26 = get_register_v(thrstate, x[26]);
+          newthr->regs.r_r27 = get_register_v(thrstate, x[27]);
+          newthr->regs.r_r28 = get_register_v(thrstate, x[28]);
+          newthr->regs.r_fp  = get_register_v(thrstate, fp);
+          newthr->regs.r_lr  = get_register_v(thrstate, lr);
+          newthr->regs.r_sp  = get_register_v(thrstate, sp);
+          newthr->regs.r_pc  = get_register_v(thrstate, pc);
+          print_thread(newthr);
+        } else if (fc.flavor == ARM_NEON_STATE64) {
+          arm_neon_state64_t flstate;
+          if (read(fd, (void *)&flstate, sizeof(arm_neon_state64_t)) != sizeof(arm_neon_state64_t)) {
+            printf("Reading flavor, count failed.\n");
+            goto err;
+          }
+          size += sizeof(arm_neon_state64_t);
+        } else if (fc.flavor == ARM_EXCEPTION_STATE64) {
+          arm_exception_state64_t excpstate;
+          if (read(fd, (void *)&excpstate, sizeof(arm_exception_state64_t)) != sizeof(arm_exception_state64_t)) {
+            printf("Reading flavor, count failed.\n");
+            goto err;
+          }
+          size += sizeof(arm_exception_state64_t);
+        } else if (fc.flavor == ARM_DEBUG_STATE64) {
+          arm_debug_state64_t dbgstate;
+          if (read(fd, (void *)&dbgstate, sizeof(arm_debug_state64_t)) != sizeof(arm_debug_state64_t)) {
+            printf("Reading flavor, count failed.\n");
+            goto err;
+          }
+          size += sizeof(arm_debug_state64_t);
+        }
+
+#else
+#error UNSUPPORTED_ARCH
+#endif
       }
     }
   }
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java
index 37a12d8f0ac..94676356ffe 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java
@@ -621,8 +621,10 @@ private void setupDebuggerDarwin() {
 
         if (cpu.equals("amd64") || cpu.equals("x86_64")) {
             machDesc = new MachineDescriptionAMD64();
+        } else if (cpu.equals("aarch64")) {
+            machDesc = new MachineDescriptionAArch64();
         } else {
-            throw new DebuggerException("Darwin only supported on x86_64. Current arch: " + cpu);
+            throw new DebuggerException("Darwin only supported on x86_64/aarch64. Current arch: " + cpu);
         }
 
         BsdDebuggerLocal dbg = new BsdDebuggerLocal(machDesc, !isServer);
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java
index a9522773471..0f29c1cdbea 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java
@@ -86,8 +86,13 @@ private Disassembler(long startPc, byte[] code) {
                libname +=  "-" + arch + ".so";
             }
          } else if (os.lastIndexOf("Mac OS X", 0) != -1) {
-            path.append(sep + "lib" + sep);
-            libname += "-amd64" + ".dylib";       // x86_64 => amd64
+            if (arch.equals("amd64") || arch.equals("x86_64")) {
+               path.append(sep + "lib" + sep);
+               libname += "-amd64" + ".dylib";       // x86_64 => amd64
+            } else {
+               path.append(sep + "lib" + sep);
+               libname +=  "-" + arch + ".so";
+            }
          } else {
             path.append(sep + "lib" + sep + "arch" + sep);
             libname +=  "-" + arch + ".so";
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
index 198e930efb9..d5a444a82d9 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
@@ -30,8 +30,10 @@
 import sun.jvm.hotspot.debugger.cdbg.*;
 import sun.jvm.hotspot.debugger.x86.*;
 import sun.jvm.hotspot.debugger.amd64.*;
+import sun.jvm.hotspot.debugger.aarch64.*;
 import sun.jvm.hotspot.debugger.bsd.x86.*;
 import sun.jvm.hotspot.debugger.bsd.amd64.*;
+import sun.jvm.hotspot.debugger.bsd.aarch64.*;
 import sun.jvm.hotspot.utilities.*;
 
 class BsdCDebugger implements CDebugger {
@@ -97,6 +99,13 @@ public CFrame topFrameForThread(ThreadProxy thread) throws DebuggerException {
        Address pc  = context.getRegisterAsAddress(AMD64ThreadContext.RIP);
        if (pc == null) return null;
        return new BsdAMD64CFrame(dbg, rbp, pc);
+    } else if (cpu.equals("aarch64")) {
+       AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();
+       Address fp = context.getRegisterAsAddress(AARCH64ThreadContext.FP);
+       if (fp == null) return null;
+       Address pc  = context.getRegisterAsAddress(AARCH64ThreadContext.PC);
+       if (pc == null) return null;
+       return new BsdAARCH64CFrame(dbg, fp, pc);
     } else {
        throw new DebuggerException(cpu + " is not yet supported");
     }
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java
index 0624fa92c78..d9c203e16bf 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java
@@ -25,6 +25,7 @@
 package sun.jvm.hotspot.debugger.bsd;
 
 import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.bsd.aarch64.*;
 import sun.jvm.hotspot.debugger.bsd.amd64.*;
 import sun.jvm.hotspot.debugger.bsd.x86.*;
 
@@ -35,6 +36,8 @@ static ThreadContext createThreadContext(BsdDebugger dbg) {
          return new BsdX86ThreadContext(dbg);
       } else if (cpu.equals("amd64") || cpu.equals("x86_64")) {
          return new BsdAMD64ThreadContext(dbg);
+      } else if (cpu.equals("aarch64")) {
+         return new BsdAARCH64ThreadContext(dbg);
       } else {
          throw new RuntimeException("cpu " + cpu + " is not yet supported");
       }
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
new file mode 100644
index 00000000000..b321935c25e
--- /dev/null
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.bsd.aarch64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.aarch64.*;
+import sun.jvm.hotspot.debugger.bsd.*;
+import sun.jvm.hotspot.debugger.cdbg.*;
+import sun.jvm.hotspot.debugger.cdbg.basic.*;
+
+final public class BsdAARCH64CFrame extends BasicCFrame {
+   public BsdAARCH64CFrame(BsdDebugger dbg, Address fp, Address pc) {
+      super(dbg.getCDebugger());
+      this.fp = fp;
+      this.pc = pc;
+      this.dbg = dbg;
+   }
+
+   // override base class impl to avoid ELF parsing
+   public ClosestSymbol closestSymbolToPC() {
+      // try native lookup in debugger.
+      return dbg.lookup(dbg.getAddressValue(pc()));
+   }
+
+   public Address pc() {
+      return pc;
+   }
+
+   public Address localVariableBase() {
+      return fp;
+   }
+
+   public CFrame sender(ThreadProxy thread) {
+      AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();
+      Address rsp = context.getRegisterAsAddress(AARCH64ThreadContext.SP);
+
+      if ( (fp == null) || fp.lessThan(rsp) ) {
+        return null;
+      }
+
+      // Check alignment of fp
+      if (dbg.getAddressValue(fp) % ADDRESS_SIZE != 0) {
+        return null;
+      }
+
+      Address nextFP = fp.getAddressAt( 0 * ADDRESS_SIZE);
+      if (nextFP == null || nextFP.lessThanOrEqual(fp)) {
+        return null;
+      }
+      Address nextPC  = fp.getAddressAt( 1 * ADDRESS_SIZE);
+      if (nextPC == null) {
+        return null;
+      }
+      return new BsdAARCH64CFrame(dbg, nextFP, nextPC);
+   }
+
+   // package/class internals only
+   private static final int ADDRESS_SIZE = 8;
+   private Address pc;
+   private Address sp;
+   private Address fp;
+   private BsdDebugger dbg;
+}
diff --git a/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.h b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
similarity index 56%
rename from src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.h
rename to src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
index 65d2f2c2ea7..1e0fcf15bb1 100644
--- a/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.h
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
@@ -1,12 +1,10 @@
 /*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
+ * published by the Free Software Foundation.
  *
  * This code is distributed in the hope that it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
@@ -21,9 +19,28 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
+ *
  */
 
-// Support for detecting Mac OS X versions
+package sun.jvm.hotspot.debugger.bsd.aarch64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.aarch64.*;
+import sun.jvm.hotspot.debugger.bsd.*;
+
+public class BsdAARCH64ThreadContext extends AARCH64ThreadContext {
+  private BsdDebugger debugger;
+
+  public BsdAARCH64ThreadContext(BsdDebugger debugger) {
+    super();
+    this.debugger = debugger;
+  }
+
+  public void setRegisterAsAddress(int index, Address value) {
+    setRegister(index, debugger.getAddressValue(value));
+  }
 
-double getOSXMajorVersion();
-BOOL isSnowLeopardOrLower();
+  public Address getRegisterAsAddress(int index) {
+    return debugger.newAddress(getRegister(index));
+  }
+}
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java
index 80279b3d1c5..62ec37811fd 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java
@@ -37,6 +37,7 @@
 import sun.jvm.hotspot.runtime.linux_ppc64.LinuxPPC64JavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.bsd_x86.BsdX86JavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.bsd_amd64.BsdAMD64JavaThreadPDAccess;
+import sun.jvm.hotspot.runtime.bsd_aarch64.BsdAARCH64JavaThreadPDAccess;
 import sun.jvm.hotspot.utilities.*;
 import sun.jvm.hotspot.utilities.Observable;
 import sun.jvm.hotspot.utilities.Observer;
@@ -132,6 +133,8 @@ private static synchronized void initialize(TypeDataBase db) {
         } else if (os.equals("darwin")) {
             if (cpu.equals("amd64") || cpu.equals("x86_64")) {
                 access = new BsdAMD64JavaThreadPDAccess();
+            } else if (cpu.equals("aarch64")) {
+                access = new BsdAARCH64JavaThreadPDAccess();
             }
         }
 
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
new file mode 100644
index 00000000000..53b34d648a4
--- /dev/null
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.runtime.bsd_aarch64;
+
+import java.io.*;
+import java.util.*;
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.aarch64.*;
+import sun.jvm.hotspot.debugger.bsd.BsdDebugger;
+import sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal;
+import sun.jvm.hotspot.runtime.*;
+import sun.jvm.hotspot.runtime.aarch64.*;
+import sun.jvm.hotspot.runtime.x86.*;
+import sun.jvm.hotspot.types.*;
+import sun.jvm.hotspot.utilities.*;
+import sun.jvm.hotspot.utilities.Observable;
+import sun.jvm.hotspot.utilities.Observer;
+
+public class BsdAARCH64JavaThreadPDAccess implements JavaThreadPDAccess {
+  private static AddressField  lastJavaFPField;
+  private static AddressField  osThreadField;
+
+  // Fields from OSThread
+  private static CIntegerField osThreadThreadIDField;
+  private static CIntegerField osThreadUniqueThreadIDField;
+
+  // This is currently unneeded but is being kept in case we change
+  // the currentFrameGuess algorithm
+  private static final long GUESS_SCAN_RANGE = 128 * 1024;
+
+  static {
+    VM.registerVMInitializedObserver(new Observer() {
+        public void update(Observable o, Object data) {
+          initialize(VM.getVM().getTypeDataBase());
+        }
+      });
+  }
+
+  private static synchronized void initialize(TypeDataBase db) {
+    Type type = db.lookupType("JavaThread");
+    osThreadField           = type.getAddressField("_osthread");
+
+    Type anchorType = db.lookupType("JavaFrameAnchor");
+    lastJavaFPField         = anchorType.getAddressField("_last_Java_fp");
+
+    Type osThreadType = db.lookupType("OSThread");
+    osThreadThreadIDField = osThreadType.getCIntegerField("_thread_id");
+    osThreadUniqueThreadIDField = osThreadType.getCIntegerField("_unique_thread_id");
+  }
+
+  public    Address getLastJavaFP(Address addr) {
+    return lastJavaFPField.getValue(addr.addOffsetTo(sun.jvm.hotspot.runtime.JavaThread.getAnchorField().getOffset()));
+  }
+
+  public    Address getLastJavaPC(Address addr) {
+    return null;
+  }
+
+  public    Address getBaseOfStackPointer(Address addr) {
+    return null;
+  }
+
+  public    Frame getLastFramePD(JavaThread thread, Address addr) {
+    Address fp = thread.getLastJavaFP();
+    if (fp == null) {
+      return null; // no information
+    }
+    return new AARCH64Frame(thread.getLastJavaSP(), fp);
+  }
+
+  public    RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {
+    return new AARCH64RegisterMap(thread, updateMap);
+  }
+
+  public    Frame getCurrentFrameGuess(JavaThread thread, Address addr) {
+    ThreadProxy t = getThreadProxy(addr);
+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();
+    AARCH64CurrentFrameGuess guesser = new AARCH64CurrentFrameGuess(context, thread);
+    if (!guesser.run(GUESS_SCAN_RANGE)) {
+      return null;
+    }
+    if (guesser.getPC() == null) {
+      return new AARCH64Frame(guesser.getSP(), guesser.getFP());
+    } else {
+      return new AARCH64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());
+    }
+  }
+
+  public    void printThreadIDOn(Address addr, PrintStream tty) {
+    tty.print(getThreadProxy(addr));
+  }
+
+  public    void printInfoOn(Address threadAddr, PrintStream tty) {
+    tty.print("Thread id: ");
+    printThreadIDOn(threadAddr, tty);
+//    tty.println("\nPostJavaState: " + getPostJavaState(threadAddr));
+  }
+
+  public    Address getLastSP(Address addr) {
+    ThreadProxy t = getThreadProxy(addr);
+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();
+    return context.getRegisterAsAddress(AARCH64ThreadContext.SP);
+  }
+
+  public    ThreadProxy getThreadProxy(Address addr) {
+    // Addr is the address of the JavaThread.
+    // Fetch the OSThread (for now and for simplicity, not making a
+    // separate "OSThread" class in this package)
+    Address osThreadAddr = osThreadField.getValue(addr);
+    // Get the address of the _thread_id from the OSThread
+    Address threadIdAddr = osThreadAddr.addOffsetTo(osThreadThreadIDField.getOffset());
+    Address uniqueThreadIdAddr = osThreadAddr.addOffsetTo(osThreadUniqueThreadIDField.getOffset());
+
+    BsdDebuggerLocal debugger = (BsdDebuggerLocal) VM.getVM().getDebugger();
+    return debugger.getThreadForIdentifierAddress(threadIdAddr, uniqueThreadIdAddr);
+  }
+}
diff --git a/test/hotspot/jtreg/compiler/c2/aarch64/TestSVEWithJNI.java b/test/hotspot/jtreg/compiler/c2/aarch64/TestSVEWithJNI.java
index dc15ca800df..5140e557141 100644
--- a/test/hotspot/jtreg/compiler/c2/aarch64/TestSVEWithJNI.java
+++ b/test/hotspot/jtreg/compiler/c2/aarch64/TestSVEWithJNI.java
@@ -26,7 +26,7 @@
 /**
  * @test
  *
- * @requires os.arch == "aarch64" & vm.compiler2.enabled
+ * @requires os.arch == "aarch64" & os.family == "linux" & vm.compiler2.enabled
  * @summary Verify VM SVE checking behavior
  * @library /test/lib
  * @run main/othervm/native compiler.c2.aarch64.TestSVEWithJNI
diff --git a/test/hotspot/jtreg/compiler/c2/aarch64/libTestSVEWithJNI.c b/test/hotspot/jtreg/compiler/c2/aarch64/libTestSVEWithJNI.c
index 0cb3ab0b5c4..e3d2fb94444 100644
--- a/test/hotspot/jtreg/compiler/c2/aarch64/libTestSVEWithJNI.c
+++ b/test/hotspot/jtreg/compiler/c2/aarch64/libTestSVEWithJNI.c
@@ -23,7 +23,7 @@
 *
 */
 
-#ifdef __aarch64__
+#if defined(__aarch64__) && defined(LINUX)
 
 #include <jni.h>
 #include <pthread.h>

From 499487333abcb0700e8d1403df778ddb65cc9886 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <drakon.mega@gmail.com>
Date: Wed, 11 Nov 2020 22:46:27 +0300
Subject: [PATCH 12/94] Minor clean-up in #2 (#4)

* Bring r18_tls back everywhere instead of r18_reserved

* Remove dup cpu_aarch

* JDK-8253457: bsd_aarch64 part

* Revert "Bring r18_tls back everywhere instead of r18_reserved"

This reverts commit 80da32e085c802d2195d5a76b4b4a89dcf15fba7.

* Revert of revert for r18_reserve, make part
---
 make/hotspot/gensrc/GensrcAdlc.gmk                | 14 ++++++--------
 src/hotspot/os/bsd/os_bsd.cpp                     |  2 --
 .../os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp     | 15 ---------------
 3 files changed, 6 insertions(+), 25 deletions(-)

diff --git a/make/hotspot/gensrc/GensrcAdlc.gmk b/make/hotspot/gensrc/GensrcAdlc.gmk
index d76951e42dd..850430cc105 100644
--- a/make/hotspot/gensrc/GensrcAdlc.gmk
+++ b/make/hotspot/gensrc/GensrcAdlc.gmk
@@ -88,10 +88,16 @@ ifeq ($(call check-jvm-feature, compiler2), true)
     ADLCFLAGS += -DAIX=1
   else ifeq ($(call isTargetOs, macosx), true)
     ADLCFLAGS += -D_ALLBSD_SOURCE=1 -D_GNU_SOURCE=1
+    ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)
+      ADLCFLAGS += -DR18_RESERVED
+    endif
   else ifeq ($(call isTargetOs, windows), true)
     ifeq ($(call isTargetCpuBits, 64), true)
       ADLCFLAGS += -D_WIN64=1
     endif
+    ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)
+      ADLCFLAGS += -DR18_RESERVED
+    endif
   endif
 
   ifeq ($(call isTargetOs, windows), false)
@@ -116,14 +122,6 @@ ifeq ($(call check-jvm-feature, compiler2), true)
     ADLCFLAGS += -DARM=1
   endif
 
-  ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)
-    ifeq ($(call isTargetOs, windows), true)
-      ADLCFLAGS += -DR18_RESERVED
-    else ifeq ($(call isTargetOs, macosx), true)
-      ADLCFLAGS += -DR18_RESERVED
-    endif
-  endif
-
   ##############################################################################
   # Concatenate all ad source files into a single file, which will be fed to
   # adlc. Also include a #line directive at the start of every included file
diff --git a/src/hotspot/os/bsd/os_bsd.cpp b/src/hotspot/os/bsd/os_bsd.cpp
index 70b36a8519b..ebe35390242 100644
--- a/src/hotspot/os/bsd/os_bsd.cpp
+++ b/src/hotspot/os/bsd/os_bsd.cpp
@@ -213,8 +213,6 @@ static char cpu_arch[] = "arm";
 static char cpu_arch[] = "aarch64";
 #elif defined(PPC32)
 static char cpu_arch[] = "ppc";
-#elif defined(AARCH64)
-static char cpu_arch[] = "aarch64";
 #else
   #error Add appropriate cpu_arch setting
 #endif
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
index 795058fca05..c10f0da1003 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
@@ -34,19 +34,10 @@
   frame pd_last_frame();
 
  public:
-  void set_base_of_stack_pointer(intptr_t* base_sp) {
-  }
-
   static ByteSize last_Java_fp_offset()          {
     return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();
   }
 
-  intptr_t* base_of_stack_pointer() {
-    return NULL;
-  }
-  void record_base_of_stack_pointer() {
-  }
-
   bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,
     bool isInJava);
 
@@ -60,10 +51,4 @@
     return Thread::current();
   }
 
-  // These routines are only used on cpu architectures that
-  // have separate register stacks (Itanium).
-  static bool register_stack_overflow() { return false; }
-  static void enable_register_stack_guard() {}
-  static void disable_register_stack_guard() {}
-
 #endif // OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP

From d81cca31ab716e02a7c94250de9a2b63f099ebab Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 10 Nov 2020 23:39:56 -0800
Subject: [PATCH 13/94] Revert "Take f69c83ad6b part for MAP_JIT"

This reverts commit 861304588e44451d73730de58479bb0e64bf9a3d.
---
 src/hotspot/os/aix/os_aix.cpp                             | 4 ++--
 src/hotspot/os/bsd/os_bsd.cpp                             | 5 ++---
 src/hotspot/os/linux/os_linux.cpp                         | 6 +++---
 src/hotspot/os/windows/os_windows.cpp                     | 6 +++---
 src/hotspot/share/memory/allocation.inline.hpp            | 4 ++--
 src/hotspot/share/memory/virtualspace.cpp                 | 6 +++++-
 src/hotspot/share/runtime/os.cpp                          | 8 ++++----
 src/hotspot/share/runtime/os.hpp                          | 6 +++---
 .../gtest/runtime/test_committed_virtualmemory.cpp        | 4 ++--
 9 files changed, 26 insertions(+), 23 deletions(-)

diff --git a/src/hotspot/os/aix/os_aix.cpp b/src/hotspot/os/aix/os_aix.cpp
index 33cacba2f48..552c345563a 100644
--- a/src/hotspot/os/aix/os_aix.cpp
+++ b/src/hotspot/os/aix/os_aix.cpp
@@ -1976,7 +1976,7 @@ void os::pd_commit_memory_or_exit(char* addr, size_t size,
   pd_commit_memory_or_exit(addr, size, exec, mesg);
 }
 
-bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
+bool os::pd_uncommit_memory(char* addr, size_t size) {
   assert(is_aligned_to(addr, os::vm_page_size()),
     "addr " PTR_FORMAT " not aligned to vm_page_size (" PTR_FORMAT ")",
     p2i(addr), os::vm_page_size());
@@ -2053,7 +2053,7 @@ char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info
 }
 
 // Reserves and attaches a shared memory segment.
-char* os::pd_reserve_memory(size_t bytes, bool executable) {
+char* os::pd_reserve_memory(size_t bytes) {
   // Always round to os::vm_page_size(), which may be larger than 4K.
   bytes = align_up(bytes, os::vm_page_size());
 
diff --git a/src/hotspot/os/bsd/os_bsd.cpp b/src/hotspot/os/bsd/os_bsd.cpp
index ebe35390242..4d5e45bd7d6 100644
--- a/src/hotspot/os/bsd/os_bsd.cpp
+++ b/src/hotspot/os/bsd/os_bsd.cpp
@@ -1823,9 +1823,8 @@ bool os::remove_stack_guard_pages(char* addr, size_t size) {
 // may not start from the requested address. Unlike Bsd mmap(), this
 // function returns NULL to indicate failure.
 static char* anon_mmap(char* requested_addr, size_t bytes, bool executable) {
-  int flags;
-
-  flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
+  // MAP_FIXED is intentionally left out, to leave existing mappings intact.
+  int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
 #ifdef __APPLE__
   if (executable) {
     flags |= MAP_JIT;
diff --git a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
index 3f5a02fc341..cf20034772f 100644
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -3239,7 +3239,7 @@ struct bitmask* os::Linux::_numa_nodes_ptr;
 struct bitmask* os::Linux::_numa_interleave_bitmask;
 struct bitmask* os::Linux::_numa_membind_bitmask;
 
-bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
+bool os::pd_uncommit_memory(char* addr, size_t size) {
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
   return res  != (uintptr_t) MAP_FAILED;
@@ -3424,7 +3424,7 @@ bool os::remove_stack_guard_pages(char* addr, size_t size) {
     return ::munmap(addr, size) == 0;
   }
 
-  return os::uncommit_memory(addr, size, !ExecMem);
+  return os::uncommit_memory(addr, size);
 }
 
 // 'requested_addr' is only treated as a hint, the return value may or
@@ -3483,7 +3483,7 @@ static int anon_munmap(char * addr, size_t size) {
   return ::munmap(addr, size) == 0;
 }
 
-char* os::pd_reserve_memory(size_t bytes, bool executable) {
+char* os::pd_reserve_memory(size_t bytes) {
   return anon_mmap(NULL, bytes);
 }
 
diff --git a/src/hotspot/os/windows/os_windows.cpp b/src/hotspot/os/windows/os_windows.cpp
index 2131c025e0a..0416605e309 100644
--- a/src/hotspot/os/windows/os_windows.cpp
+++ b/src/hotspot/os/windows/os_windows.cpp
@@ -3168,7 +3168,7 @@ char* os::reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {
   return aligned_base;
 }
 
-char* os::pd_reserve_memory(size_t bytes, bool executable) {
+char* os::pd_reserve_memory(size_t bytes) {
   return pd_attempt_reserve_memory_at(NULL /* addr */, bytes);
 }
 
@@ -3369,7 +3369,7 @@ void os::pd_commit_memory_or_exit(char* addr, size_t size,
   pd_commit_memory_or_exit(addr, size, exec, mesg);
 }
 
-bool os::pd_uncommit_memory(char* addr, size_t bytes, bool exec) {
+bool os::pd_uncommit_memory(char* addr, size_t bytes) {
   if (bytes == 0) {
     // Don't bother the OS with noops.
     return true;
@@ -3388,7 +3388,7 @@ bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
 }
 
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  return os::uncommit_memory(addr, size, !ExecMem);
+  return os::uncommit_memory(addr, size);
 }
 
 static bool protect_pages_individually(char* addr, size_t bytes, unsigned int p, DWORD *old_status) {
diff --git a/src/hotspot/share/memory/allocation.inline.hpp b/src/hotspot/share/memory/allocation.inline.hpp
index fb62038ed1b..e913c0c8053 100644
--- a/src/hotspot/share/memory/allocation.inline.hpp
+++ b/src/hotspot/share/memory/allocation.inline.hpp
@@ -56,7 +56,7 @@ template <class E>
 E* MmapArrayAllocator<E>::allocate_or_null(size_t length, MEMFLAGS flags) {
   size_t size = size_for(length);
 
-  char* addr = os::reserve_memory(size, flags);
+  char* addr = os::reserve_memory(size, !ExecMem, flags);
   if (addr == NULL) {
     return NULL;
   }
@@ -73,7 +73,7 @@ template <class E>
 E* MmapArrayAllocator<E>::allocate(size_t length, MEMFLAGS flags) {
   size_t size = size_for(length);
 
-  char* addr = os::reserve_memory(size, flags);
+  char* addr = os::reserve_memory(size, !ExecMem, flags);
   if (addr == NULL) {
     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, "Allocator (reserve)");
   }
diff --git a/src/hotspot/share/memory/virtualspace.cpp b/src/hotspot/share/memory/virtualspace.cpp
index 881d97f1185..46979f9d595 100644
--- a/src/hotspot/share/memory/virtualspace.cpp
+++ b/src/hotspot/share/memory/virtualspace.cpp
@@ -194,7 +194,11 @@ void ReservedSpace::initialize(size_t size, size_t alignment, bool large,
         base = NULL;
       }
     } else {
-      base = os::reserve_memory_with_fd(size, _fd_for_heap, _executable);
+      if (_executable) {
+        base = os::reserve_memory(size, ExecMem);
+      } else {
+        base = os::reserve_memory_with_fd(size, _fd_for_heap);
+      }
     }
 
     if (base == NULL) return;
diff --git a/src/hotspot/share/runtime/os.cpp b/src/hotspot/share/runtime/os.cpp
index fc47a76d828..eef06b8a020 100644
--- a/src/hotspot/share/runtime/os.cpp
+++ b/src/hotspot/share/runtime/os.cpp
@@ -1646,8 +1646,8 @@ bool os::create_stack_guard_pages(char* addr, size_t bytes) {
   return os::pd_create_stack_guard_pages(addr, bytes);
 }
 
-char* os::reserve_memory(size_t bytes, MEMFLAGS flags) {
-  char* result = pd_reserve_memory(bytes);
+char* os::reserve_memory(size_t bytes, bool executable, MEMFLAGS flags) {
+  char* result = pd_reserve_memory(bytes, executable);
   if (result != NULL) {
     MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC);
     if (flags != mtOther) {
@@ -1658,7 +1658,7 @@ char* os::reserve_memory(size_t bytes, MEMFLAGS flags) {
   return result;
 }
 
-char* os::reserve_memory_with_fd(size_t bytes, int file_desc, bool executable) {
+char* os::reserve_memory_with_fd(size_t bytes, int file_desc) {
   char* result;
 
   if (file_desc != -1) {
@@ -1669,7 +1669,7 @@ char* os::reserve_memory_with_fd(size_t bytes, int file_desc, bool executable) {
       MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC);
     }
   } else {
-    result = pd_reserve_memory(bytes, executable);
+    result = pd_reserve_memory(bytes, false/*executable*/);
     if (result != NULL) {
       MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC);
     }
diff --git a/src/hotspot/share/runtime/os.hpp b/src/hotspot/share/runtime/os.hpp
index 731ee4050c7..a07f76369d3 100644
--- a/src/hotspot/share/runtime/os.hpp
+++ b/src/hotspot/share/runtime/os.hpp
@@ -118,7 +118,7 @@ class os: AllStatic {
     _page_sizes[1] = 0; // sentinel
   }
 
-  static char*  pd_reserve_memory(size_t bytes, bool executable = false);
+  static char*  pd_reserve_memory(size_t bytes, bool executable);
 
   static char*  pd_attempt_reserve_memory_at(char* addr, size_t bytes);
   static char*  pd_attempt_reserve_memory_at(char* addr, size_t bytes, int file_desc);
@@ -319,11 +319,11 @@ class os: AllStatic {
 
   // Reserves virtual memory.
   // alignment_hint - currently only used by AIX
-  static char*  reserve_memory(size_t bytes, MEMFLAGS flags = mtOther);
+  static char*  reserve_memory(size_t bytes, bool executable = false, MEMFLAGS flags = mtOther);
 
   // Reserves virtual memory.
   // if file_desc != -1, also attaches the memory to the file.
-  static char*  reserve_memory_with_fd(size_t bytes, int file_desc, bool executable = false);
+  static char*  reserve_memory_with_fd(size_t bytes, int file_desc);
 
   // Reserves virtual memory that starts at an address that is aligned to 'alignment'.
   static char*  reserve_memory_aligned(size_t size, size_t alignment, int file_desc = -1);
diff --git a/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp b/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
index d2539b73382..06378fcdc00 100644
--- a/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
+++ b/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
@@ -101,7 +101,7 @@ class CommittedVirtualMemoryTest {
   static void test_committed_region_impl(size_t num_pages, size_t touch_pages, int* page_num) {
     const size_t page_sz = os::vm_page_size();
     const size_t size = num_pages * page_sz;
-    char* base = os::reserve_memory(size, mtThreadStack);
+    char* base = os::reserve_memory(size, false, mtThreadStack);
     bool result = os::commit_memory(base, size, false);
     size_t index;
     ASSERT_NE(base, (char*)NULL);
@@ -169,7 +169,7 @@ class CommittedVirtualMemoryTest {
     const size_t page_sz = os::vm_page_size();
     const size_t num_pages = 4;
     const size_t size = num_pages * page_sz;
-    char* base = os::reserve_memory(size, mtTest);
+    char* base = os::reserve_memory(size, false, mtTest);
     ASSERT_NE(base, (char*)NULL);
     result = os::commit_memory(base, size, false);
 

From 0ab1e1ccb7d592159abb4447f1eb8e2969454c4a Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 10 Nov 2020 23:40:33 -0800
Subject: [PATCH 14/94] Revert "Import JDK-8234930 v2: Use MAP_JIT when
 allocating pages for code cache on macOS"

This reverts commit 296224992ab4e7fb435387237eed810497471cb2.
---
 src/hotspot/os/bsd/os_bsd.cpp                 | 38 +++++--------------
 .../share/gc/g1/g1PageBasedVirtualSpace.cpp   |  2 +-
 src/hotspot/share/gc/parallel/psCardTable.cpp |  3 +-
 .../share/gc/parallel/psVirtualspace.cpp      |  2 +-
 src/hotspot/share/gc/shared/cardTable.cpp     |  3 +-
 .../share/gc/shenandoah/shenandoahHeap.cpp    |  4 +-
 .../gc/shenandoah/shenandoahHeapRegion.cpp    |  2 +-
 .../share/memory/allocation.inline.hpp        |  4 +-
 src/hotspot/share/memory/virtualspace.cpp     | 12 ++----
 src/hotspot/share/prims/whitebox.cpp          |  2 +-
 src/hotspot/share/runtime/os.cpp              | 12 +++---
 src/hotspot/share/runtime/os.hpp              |  8 ++--
 src/hotspot/share/runtime/stackOverflow.cpp   |  2 +-
 .../runtime/test_committed_virtualmemory.cpp  |  4 +-
 14 files changed, 36 insertions(+), 62 deletions(-)

diff --git a/src/hotspot/os/bsd/os_bsd.cpp b/src/hotspot/os/bsd/os_bsd.cpp
index 4d5e45bd7d6..55b9b0fac68 100644
--- a/src/hotspot/os/bsd/os_bsd.cpp
+++ b/src/hotspot/os/bsd/os_bsd.cpp
@@ -1694,16 +1694,12 @@ static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
 //       problem.
 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
-#if defined(__OpenBSD__)
+#ifdef __OpenBSD__
   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
   Events::log(NULL, "Protecting memory [" INTPTR_FORMAT "," INTPTR_FORMAT "] with protection modes %x", p2i(addr), p2i(addr+size), prot);
   if (::mprotect(addr, size, prot) == 0) {
     return true;
   }
-#elif defined(__APPLE__)
-  if (::mprotect(addr, size, prot) == 0) {
-    return true;
-  }
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
                                      MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
@@ -1786,22 +1782,11 @@ char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info
 }
 
 
-bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
-#if defined(__OpenBSD__)
+bool os::pd_uncommit_memory(char* addr, size_t size) {
+#ifdef __OpenBSD__
   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
   Events::log(NULL, "Protecting memory [" INTPTR_FORMAT "," INTPTR_FORMAT "] with PROT_NONE", p2i(addr), p2i(addr+size));
   return ::mprotect(addr, size, PROT_NONE) == 0;
-#elif defined(__APPLE__)
-  if (exec) {
-    if (::madvise(addr, size, MADV_FREE) != 0) {
-      return false;
-    }
-    return ::mprotect(addr, size, PROT_NONE) == 0;
-  } else {
-    uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
-        MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
-    return res  != (uintptr_t) MAP_FAILED;
-  }
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
@@ -1816,20 +1801,15 @@ bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
 // If this is a growable mapping, remove the guard pages entirely by
 // munmap()ping them.  If not, just call uncommit_memory().
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  return os::uncommit_memory(addr, size, !ExecMem);
+  return os::uncommit_memory(addr, size);
 }
 
 // 'requested_addr' is only treated as a hint, the return value may or
 // may not start from the requested address. Unlike Bsd mmap(), this
 // function returns NULL to indicate failure.
-static char* anon_mmap(char* requested_addr, size_t bytes, bool executable) {
+static char* anon_mmap(char* requested_addr, size_t bytes) {
   // MAP_FIXED is intentionally left out, to leave existing mappings intact.
-  int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
-#ifdef __APPLE__
-  if (executable) {
-    flags |= MAP_JIT;
-  }
-#endif
+  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
 
   // Map reserved/uncommitted pages PROT_NONE so we fail early if we
   // touch an uncommitted page. Otherwise, the read/write might
@@ -1843,8 +1823,8 @@ static int anon_munmap(char * addr, size_t size) {
   return ::munmap(addr, size) == 0;
 }
 
-char* os::pd_reserve_memory(size_t bytes, bool executable) {
-  return anon_mmap(NULL /* addr */, bytes, executable);
+char* os::pd_reserve_memory(size_t bytes) {
+  return anon_mmap(NULL /* addr */, bytes);
 }
 
 bool os::pd_release_memory(char* addr, size_t size) {
@@ -1954,7 +1934,7 @@ char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes) {
 
   // Bsd mmap allows caller to pass an address as hint; give it a try first,
   // if kernel honors the hint then we can return immediately.
-  char * addr = anon_mmap(requested_addr, bytes, false/*executable*/);
+  char * addr = anon_mmap(requested_addr, bytes);
   if (addr == requested_addr) {
     return requested_addr;
   }
diff --git a/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp b/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
index ca86478a5e2..be7fa937ed2 100644
--- a/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
+++ b/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
@@ -216,7 +216,7 @@ void G1PageBasedVirtualSpace::uncommit_internal(size_t start_page, size_t end_pa
             "Given start page " SIZE_FORMAT " is larger or equal to end page " SIZE_FORMAT, start_page, end_page);
 
   char* start_addr = page_start(start_page);
-  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)), !ExecMem);
+  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)));
 }
 
 void G1PageBasedVirtualSpace::uncommit(size_t start_page, size_t size_in_pages) {
diff --git a/src/hotspot/share/gc/parallel/psCardTable.cpp b/src/hotspot/share/gc/parallel/psCardTable.cpp
index 322802a92c8..9ad29779ed7 100644
--- a/src/hotspot/share/gc/parallel/psCardTable.cpp
+++ b/src/hotspot/share/gc/parallel/psCardTable.cpp
@@ -587,8 +587,7 @@ bool PSCardTable::resize_commit_uncommit(int changed_region,
       MemRegion(cur_committed.start(), new_start_aligned));
     if (!uncommit_region.is_empty()) {
       if (!os::uncommit_memory((char*)uncommit_region.start(),
-                               uncommit_region.byte_size(),
-                               !ExecMem)) {
+                               uncommit_region.byte_size())) {
         // If the uncommit fails, ignore it.  Let the
         // committed table resizing go even though the committed
         // table will over state the committed space.
diff --git a/src/hotspot/share/gc/parallel/psVirtualspace.cpp b/src/hotspot/share/gc/parallel/psVirtualspace.cpp
index f25d295093a..473a1f26854 100644
--- a/src/hotspot/share/gc/parallel/psVirtualspace.cpp
+++ b/src/hotspot/share/gc/parallel/psVirtualspace.cpp
@@ -113,7 +113,7 @@ bool PSVirtualSpace::shrink_by(size_t bytes) {
   }
 
   char* const base_addr = committed_high_addr() - bytes;
-  bool result = special() || os::uncommit_memory(base_addr, bytes, !ExecMem);
+  bool result = special() || os::uncommit_memory(base_addr, bytes);
   if (result) {
     _committed_high_addr -= bytes;
   }
diff --git a/src/hotspot/share/gc/shared/cardTable.cpp b/src/hotspot/share/gc/shared/cardTable.cpp
index a74070c8d47..b2a7118e8aa 100644
--- a/src/hotspot/share/gc/shared/cardTable.cpp
+++ b/src/hotspot/share/gc/shared/cardTable.cpp
@@ -254,8 +254,7 @@ void CardTable::resize_covered_region(MemRegion new_region) {
                                                 cur_committed.end()));
       if (!uncommit_region.is_empty()) {
         if (!os::uncommit_memory((char*)uncommit_region.start(),
-                                 uncommit_region.byte_size(),
-                                 !ExecMem)) {
+                                 uncommit_region.byte_size())) {
           assert(false, "Card table contraction failed");
           // The call failed so don't change the end of the
           // committed region.  This is better than taking the
diff --git a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
index 7af54952243..e1449b45199 100644
--- a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
@@ -1350,7 +1350,7 @@ void ShenandoahHeap::scan_roots_for_iteration(ShenandoahScanObjectStack* oop_sta
 }
 
 void ShenandoahHeap::reclaim_aux_bitmap_for_iteration() {
-  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), !ExecMem)) {
+  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
     log_warning(gc)("Could not uncommit native memory for auxiliary marking bitmap for heap iteration");
   }
 }
@@ -2867,7 +2867,7 @@ bool ShenandoahHeap::uncommit_bitmap_slice(ShenandoahHeapRegion *r) {
   size_t slice = r->index() / _bitmap_regions_per_slice;
   size_t off = _bitmap_bytes_per_slice * slice;
   size_t len = _bitmap_bytes_per_slice;
-  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len, !ExecMem)) {
+  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len)) {
     return false;
   }
   return true;
diff --git a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
index eba696a98ad..2dd5f161d1d 100644
--- a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
@@ -628,7 +628,7 @@ void ShenandoahHeapRegion::do_commit() {
 
 void ShenandoahHeapRegion::do_uncommit() {
   ShenandoahHeap* heap = ShenandoahHeap::heap();
-  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes, !ExecMem)) {
+  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {
     report_java_out_of_memory("Unable to uncommit region");
   }
   if (!heap->uncommit_bitmap_slice(this)) {
diff --git a/src/hotspot/share/memory/allocation.inline.hpp b/src/hotspot/share/memory/allocation.inline.hpp
index e913c0c8053..fb62038ed1b 100644
--- a/src/hotspot/share/memory/allocation.inline.hpp
+++ b/src/hotspot/share/memory/allocation.inline.hpp
@@ -56,7 +56,7 @@ template <class E>
 E* MmapArrayAllocator<E>::allocate_or_null(size_t length, MEMFLAGS flags) {
   size_t size = size_for(length);
 
-  char* addr = os::reserve_memory(size, !ExecMem, flags);
+  char* addr = os::reserve_memory(size, flags);
   if (addr == NULL) {
     return NULL;
   }
@@ -73,7 +73,7 @@ template <class E>
 E* MmapArrayAllocator<E>::allocate(size_t length, MEMFLAGS flags) {
   size_t size = size_for(length);
 
-  char* addr = os::reserve_memory(size, !ExecMem, flags);
+  char* addr = os::reserve_memory(size, flags);
   if (addr == NULL) {
     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, "Allocator (reserve)");
   }
diff --git a/src/hotspot/share/memory/virtualspace.cpp b/src/hotspot/share/memory/virtualspace.cpp
index 46979f9d595..c67e9c1c78f 100644
--- a/src/hotspot/share/memory/virtualspace.cpp
+++ b/src/hotspot/share/memory/virtualspace.cpp
@@ -194,11 +194,7 @@ void ReservedSpace::initialize(size_t size, size_t alignment, bool large,
         base = NULL;
       }
     } else {
-      if (_executable) {
-        base = os::reserve_memory(size, ExecMem);
-      } else {
-        base = os::reserve_memory_with_fd(size, _fd_for_heap);
-      }
+      base = os::reserve_memory_with_fd(size, _fd_for_heap);
     }
 
     if (base == NULL) return;
@@ -986,7 +982,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(middle_high_boundary() <= aligned_upper_new_high &&
            aligned_upper_new_high + upper_needs <= upper_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs, _executable)) {
+    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
@@ -997,7 +993,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(lower_high_boundary() <= aligned_middle_new_high &&
            aligned_middle_new_high + middle_needs <= middle_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs, _executable)) {
+    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
@@ -1008,7 +1004,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(low_boundary() <= aligned_lower_new_high &&
            aligned_lower_new_high + lower_needs <= lower_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs, _executable)) {
+    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
diff --git a/src/hotspot/share/prims/whitebox.cpp b/src/hotspot/share/prims/whitebox.cpp
index 2a6cae1deeb..013295742e0 100644
--- a/src/hotspot/share/prims/whitebox.cpp
+++ b/src/hotspot/share/prims/whitebox.cpp
@@ -774,7 +774,7 @@ WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size
 WB_END
 
 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
-  os::uncommit_memory((char *)(uintptr_t)addr, size, !ExecMem);
+  os::uncommit_memory((char *)(uintptr_t)addr, size);
 WB_END
 
 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
diff --git a/src/hotspot/share/runtime/os.cpp b/src/hotspot/share/runtime/os.cpp
index eef06b8a020..3179ada2f65 100644
--- a/src/hotspot/share/runtime/os.cpp
+++ b/src/hotspot/share/runtime/os.cpp
@@ -1646,8 +1646,8 @@ bool os::create_stack_guard_pages(char* addr, size_t bytes) {
   return os::pd_create_stack_guard_pages(addr, bytes);
 }
 
-char* os::reserve_memory(size_t bytes, bool executable, MEMFLAGS flags) {
-  char* result = pd_reserve_memory(bytes, executable);
+char* os::reserve_memory(size_t bytes, MEMFLAGS flags) {
+  char* result = pd_reserve_memory(bytes);
   if (result != NULL) {
     MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC);
     if (flags != mtOther) {
@@ -1669,7 +1669,7 @@ char* os::reserve_memory_with_fd(size_t bytes, int file_desc) {
       MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC);
     }
   } else {
-    result = pd_reserve_memory(bytes, false/*executable*/);
+    result = pd_reserve_memory(bytes);
     if (result != NULL) {
       MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC);
     }
@@ -1723,16 +1723,16 @@ void os::commit_memory_or_exit(char* addr, size_t size, size_t alignment_hint,
   MemTracker::record_virtual_memory_commit((address)addr, size, CALLER_PC);
 }
 
-bool os::uncommit_memory(char* addr, size_t bytes, bool exec) {
+bool os::uncommit_memory(char* addr, size_t bytes) {
   bool res;
   if (MemTracker::tracking_level() > NMT_minimal) {
     Tracker tkr(Tracker::uncommit);
-    res = pd_uncommit_memory(addr, bytes, exec);
+    res = pd_uncommit_memory(addr, bytes);
     if (res) {
       tkr.record((address)addr, bytes);
     }
   } else {
-    res = pd_uncommit_memory(addr, bytes, exec);
+    res = pd_uncommit_memory(addr, bytes);
   }
   return res;
 }
diff --git a/src/hotspot/share/runtime/os.hpp b/src/hotspot/share/runtime/os.hpp
index a07f76369d3..167385bf26e 100644
--- a/src/hotspot/share/runtime/os.hpp
+++ b/src/hotspot/share/runtime/os.hpp
@@ -118,7 +118,7 @@ class os: AllStatic {
     _page_sizes[1] = 0; // sentinel
   }
 
-  static char*  pd_reserve_memory(size_t bytes, bool executable);
+  static char*  pd_reserve_memory(size_t bytes);
 
   static char*  pd_attempt_reserve_memory_at(char* addr, size_t bytes);
   static char*  pd_attempt_reserve_memory_at(char* addr, size_t bytes, int file_desc);
@@ -133,7 +133,7 @@ class os: AllStatic {
   static void   pd_commit_memory_or_exit(char* addr, size_t size,
                                          size_t alignment_hint,
                                          bool executable, const char* mesg);
-  static bool   pd_uncommit_memory(char* addr, size_t bytes, bool exec);
+  static bool   pd_uncommit_memory(char* addr, size_t bytes);
   static bool   pd_release_memory(char* addr, size_t bytes);
 
   static char*  pd_map_memory(int fd, const char* file_name, size_t file_offset,
@@ -319,7 +319,7 @@ class os: AllStatic {
 
   // Reserves virtual memory.
   // alignment_hint - currently only used by AIX
-  static char*  reserve_memory(size_t bytes, bool executable = false, MEMFLAGS flags = mtOther);
+  static char*  reserve_memory(size_t bytes, MEMFLAGS flags = mtOther);
 
   // Reserves virtual memory.
   // if file_desc != -1, also attaches the memory to the file.
@@ -352,7 +352,7 @@ class os: AllStatic {
   static void   commit_memory_or_exit(char* addr, size_t size,
                                       size_t alignment_hint,
                                       bool executable, const char* mesg);
-  static bool   uncommit_memory(char* addr, size_t bytes, bool exec);
+  static bool   uncommit_memory(char* addr, size_t bytes);
   static bool   release_memory(char* addr, size_t bytes);
 
   // Touch memory pages that cover the memory range from start to end (exclusive)
diff --git a/src/hotspot/share/runtime/stackOverflow.cpp b/src/hotspot/share/runtime/stackOverflow.cpp
index 0b706e71703..01aba3ea2de 100644
--- a/src/hotspot/share/runtime/stackOverflow.cpp
+++ b/src/hotspot/share/runtime/stackOverflow.cpp
@@ -103,7 +103,7 @@ void StackOverflow::create_stack_guard_pages() {
   } else {
     log_warning(os, thread)("Attempt to protect stack guard pages failed ("
       PTR_FORMAT "-" PTR_FORMAT ").", p2i(low_addr), p2i(low_addr + len));
-    if (os::uncommit_memory((char *) low_addr, len, !ExecMem)) {
+    if (os::uncommit_memory((char *) low_addr, len)) {
       log_warning(os, thread)("Attempt to deallocate stack guard pages failed.");
     }
     return;
diff --git a/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp b/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
index 06378fcdc00..d2539b73382 100644
--- a/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
+++ b/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
@@ -101,7 +101,7 @@ class CommittedVirtualMemoryTest {
   static void test_committed_region_impl(size_t num_pages, size_t touch_pages, int* page_num) {
     const size_t page_sz = os::vm_page_size();
     const size_t size = num_pages * page_sz;
-    char* base = os::reserve_memory(size, false, mtThreadStack);
+    char* base = os::reserve_memory(size, mtThreadStack);
     bool result = os::commit_memory(base, size, false);
     size_t index;
     ASSERT_NE(base, (char*)NULL);
@@ -169,7 +169,7 @@ class CommittedVirtualMemoryTest {
     const size_t page_sz = os::vm_page_size();
     const size_t num_pages = 4;
     const size_t size = num_pages * page_sz;
-    char* base = os::reserve_memory(size, false, mtTest);
+    char* base = os::reserve_memory(size, mtTest);
     ASSERT_NE(base, (char*)NULL);
     result = os::commit_memory(base, size, false);
 

From 051357ef977ecab77fa9b2b1e61f94f288e716f9 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 10 Nov 2020 06:22:22 -0800
Subject: [PATCH 15/94] Fix merge

---
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.cpp     | 172 ++----------------
 .../bsd_aarch64/vm_version_bsd_aarch64.cpp    |   2 +-
 .../share/native/libharfbuzz/hb-common.h      |   2 +-
 3 files changed, 18 insertions(+), 158 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index 7a74a1f8f3d..b061a747f15 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -176,44 +176,16 @@ frame os::fetch_frame_from_context(const void* ucVoid) {
   return frame(sp, fp, epc);
 }
 
-bool os::Bsd::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
-  address pc = (address) os::Bsd::ucontext_get_pc(uc);
-  if (Interpreter::contains(pc)) {
-    // interpreter performs stack banging after the fixed frame header has
-    // been generated while the compilers perform it before. To maintain
-    // semantic consistency between interpreted and compiled frames, the
-    // method returns the Java sender of the current frame.
-    *fr = os::fetch_frame_from_context(uc);
-    if (!fr->is_first_java_frame()) {
-      assert(fr->safe_for_sender(thread), "Safety check");
-      *fr = fr->java_sender();
-    }
-  } else {
-    // more complex code with compiled code
-    assert(!Interpreter::contains(pc), "Interpreted methods should have been handled above");
-    CodeBlob* cb = CodeCache::find_blob(pc);
-    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {
-      // Not sure where the pc points to, fallback to default
-      // stack overflow handling
-      return false;
-    } else {
-      // In compiled code, the stack banging is performed before LR
-      // has been saved in the frame.  LR is live, and SP and FP
-      // belong to the caller.
-      intptr_t* fp = os::Bsd::ucontext_get_fp(uc);
-      intptr_t* sp = os::Bsd::ucontext_get_sp(uc);
-      address pc = (address)(uc->context_lr
+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {
+  const ucontext_t* uc = (const ucontext_t*)ucVoid;
+  // In compiled code, the stack banging is performed before LR
+  // has been saved in the frame.  LR is live, and SP and FP
+  // belong to the caller.
+  intptr_t* fp = os::Bsd::ucontext_get_fp(uc);
+  intptr_t* sp = os::Bsd::ucontext_get_sp(uc);
+  address pc = (address)(uc->context_lr
                          - NativeInstruction::instruction_size);
-      *fr = frame(sp, fp, pc);
-      if (!fr->is_java_frame()) {
-        assert(fr->safe_for_sender(thread), "Safety check");
-        assert(!fr->is_first_frame(), "Safety check");
-        *fr = fr->java_sender();
-      }
-    }
-  }
-  assert(fr->is_java_frame(), "Safety check");
-  return true;
+  return frame(sp, fp, pc);
 }
 
 // By default, gcc always saves frame pointer rfp on this stack. This
@@ -235,58 +207,9 @@ NOINLINE frame os::current_frame() {
   }
 }
 
-extern "C" JNIEXPORT int
-JVM_handle_bsd_signal(int sig,
-                        siginfo_t* info,
-                        void* ucVoid,
-                        int abort_if_unrecognized) {
-  ucontext_t* uc = (ucontext_t*) ucVoid;
-
-  Thread* t = Thread::current_or_null_safe();
-
-  // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
-  // (no destructors can be run)
-  os::ThreadCrashProtection::check_crash_protection(sig, t);
-
-  SignalHandlerMark shm(t);
-
-  // Note: it's not uncommon that JNI code uses signal/sigset to install
-  // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
-  // or have a SIGILL handler when detecting CPU type). When that happens,
-  // JVM_handle_bsd_signal() might be invoked with junk info/ucVoid. To
-  // avoid unnecessary crash when libjsig is not preloaded, try handle signals
-  // that do not require siginfo/ucontext first.
-
-  if (sig == SIGPIPE || sig == SIGXFSZ) {
-    // allow chained handler to go first
-    if (PosixSignals::chained_handler(sig, info, ucVoid)) {
-      return true;
-    } else {
-      // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
-      return true;
-    }
-  }
-
-#ifdef CAN_SHOW_REGISTERS_ON_ASSERT
-  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {
-    if (handle_assert_poison_fault(ucVoid, info->si_addr)) {
-      return 1;
-    }
-  }
-#endif
+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
+                                             ucontext_t* uc, JavaThread* thread) {
 
-  JavaThread* thread = NULL;
-  VMThread* vmthread = NULL;
-  if (PosixSignals::are_signal_handlers_installed()) {
-    if (t != NULL ){
-      if(t->is_Java_thread()) {
-        thread = (JavaThread*)t;
-      }
-      else if(t->is_VM_thread()){
-        vmthread = (VMThread *)t;
-      }
-    }
-  }
 /*
   NOTE: does not seem to work on bsd.
   if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {
@@ -307,7 +230,7 @@ JVM_handle_bsd_signal(int sig,
 
     if (StubRoutines::is_safefetch_fault(pc)) {
       os::Bsd::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
-      return 1;
+      return true;
     }
 
     // Handle ALL stack overflow variations here
@@ -323,41 +246,8 @@ JVM_handle_bsd_signal(int sig,
       if (thread->is_in_full_stack(addr)) {
         Thread::WXWriteFromExecSetter wx_write;
         // stack overflow
-        StackOverflow* overflow_state = thread->stack_overflow_state();
-        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {
-          if (thread->thread_state() == _thread_in_Java) {
-            if (overflow_state->in_stack_reserved_zone(addr)) {
-              frame fr;
-              if (os::Bsd::get_frame_at_stack_banging_point(thread, uc, &fr)) {
-                assert(fr.is_java_frame(), "Must be a Java frame");
-                frame activation =
-                  SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
-                if (activation.sp() != NULL) {
-                  overflow_state->disable_stack_reserved_zone();
-                  if (activation.is_interpreted_frame()) {
-                    overflow_state->set_reserved_stack_activation((address)(
-                      activation.fp() + frame::interpreter_frame_initial_sp_offset));
-                  } else {
-                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());
-                  }
-                  return 1;
-                }
-              }
-            }
-            // Throw a stack overflow exception.  Guard pages will be reenabled
-            // while unwinding the stack.
-            overflow_state->disable_stack_yellow_reserved_zone();
-            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
-          } else {
-            // Thread was in the vm or native code.  Return and try to finish.
-            overflow_state->disable_stack_yellow_reserved_zone();
-            return 1;
-          }
-        } else if (overflow_state->in_stack_red_zone(addr)) {
-          // Fatal red zone violation.  Disable the guard pages and fall through
-          // to handle_unexpected_exception way down below.
-          overflow_state->disable_stack_red_zone();
-          tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
+        if (os::Posix::handle_stack_overflow(thread, addr, pc, uc, &stub)) {
+          return true; // continue
         }
       }
     }
@@ -414,14 +304,7 @@ JVM_handle_bsd_signal(int sig,
           tty->print_cr("trap: %s: (SIGILL)", msg);
         }
 
-PRAGMA_DIAG_PUSH
-PRAGMA_DISABLE_GCC_WARNING("-Wformat-nonliteral")
-PRAGMA_DISABLE_GCC_WARNING("-Wuninitialized")
-        va_list detail_args;
-        VMError::report_and_die(INTERNAL_ERROR, msg, detail_msg, detail_args, thread,
-                                pc, info, ucVoid, NULL, 0, 0);
-        va_end(detail_args);
-PRAGMA_DIAG_POP
+        return false;
       }
       else
 
@@ -516,30 +399,7 @@ PRAGMA_DIAG_POP
     return true;
   }
 
-  // signal-chaining
-  if (PosixSignals::chained_handler(sig, info, ucVoid)) {
-     return true;
-  }
-
-  if (!abort_if_unrecognized) {
-    // caller wants another chance, so give it to him
-    return false;
-  }
-
-  if (pc == NULL && uc != NULL) {
-    pc = os::Bsd::ucontext_get_pc(uc);
-  }
-
-  // unmask current signal
-  sigset_t newset;
-  sigemptyset(&newset);
-  sigaddset(&newset, sig);
-  sigprocmask(SIG_UNBLOCK, &newset, NULL);
-
-  VMError::report_and_die(t, sig, pc, info, ucVoid);
-
-  ShouldNotReachHere();
-  return true; // Mute compiler
+  return false; // Mute compiler
 }
 
 void os::Bsd::init_thread_fpu_state(void) {
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
index 57a62fde87d..b850f62f79d 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
@@ -32,7 +32,7 @@ int VM_Version::get_current_sve_vector_length() {
   return -1;
 }
 
-int VM_Version::set_and_get_current_sve_vector_lenght(int length) {
+int VM_Version::set_and_get_current_sve_vector_length(int length) {
   ShouldNotReachHere();
   return -1;
 }
diff --git a/src/java.desktop/share/native/libharfbuzz/hb-common.h b/src/java.desktop/share/native/libharfbuzz/hb-common.h
index 9614e720b32..5b5e998a15f 100644
--- a/src/java.desktop/share/native/libharfbuzz/hb-common.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-common.h
@@ -110,7 +110,7 @@ typedef union _hb_var_int_t {
 typedef uint32_t hb_tag_t;
 
 #define HB_TAG(c1,c2,c3,c4) ((hb_tag_t)((((uint32_t)(c1)&0xFF)<<24)|(((uint32_t)(c2)&0xFF)<<16)|(((uint32_t)(c3)&0xFF)<<8)|((uint32_t)(c4)&0xFF)))
-#define HB_UNTAG(tag)   (uint8_t)(((tag)>>24)&0xFF), (uint8_t)(((tag)>>16)&0xFF), (uint8_t)(((tag)>>8)&0xFF), (uint8_t)((tag)&0xFF)
+#define HB_UNTAG(tag)   (char)(((tag)>>24)&0xFF), (char)(((tag)>>16)&0xFF), (char)(((tag)>>8)&0xFF), (char)((tag)&0xFF)
 
 #define HB_TAG_NONE HB_TAG(0,0,0,0)
 #define HB_TAG_MAX HB_TAG(0xff,0xff,0xff,0xff)

From 33c47611da31068d4e25c27d6f77ed11ca99e545 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Thu, 12 Nov 2020 09:46:48 +0300
Subject: [PATCH 16/94] Add missing include StubRoutines inline

---
 src/hotspot/os/aix/os_aix.cpp                              | 1 +
 src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp | 1 +
 2 files changed, 2 insertions(+)

diff --git a/src/hotspot/os/aix/os_aix.cpp b/src/hotspot/os/aix/os_aix.cpp
index 71cc3056a55..816c516d40c 100644
--- a/src/hotspot/os/aix/os_aix.cpp
+++ b/src/hotspot/os/aix/os_aix.cpp
@@ -66,6 +66,7 @@
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/statSampler.hpp"
 #include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadCritical.hpp"
 #include "runtime/timer.hpp"
diff --git a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
index 2cd3b95a72b..034e113e742 100644
--- a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
+++ b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
@@ -35,6 +35,7 @@
 #include "runtime/init.hpp"
 #include "runtime/os.hpp"
 #include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "utilities/align.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/growableArray.hpp"

From b41b3a949e349d5b6ac57ff745bf8308d6a1720e Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@openjdk.org>
Date: Tue, 25 Aug 2020 07:12:38 -0700
Subject: [PATCH 17/94] Import JDK-8234930 v3: Use MAP_JIT when allocating
 pages for code cache on macOS

---
 src/hotspot/os/aix/os_aix.cpp                 |  4 +-
 src/hotspot/os/bsd/os_bsd.cpp                 | 38 ++++++++++++++-----
 src/hotspot/os/linux/os_linux.cpp             |  6 +--
 src/hotspot/os/windows/os_windows.cpp         |  6 +--
 .../share/gc/g1/g1PageBasedVirtualSpace.cpp   |  2 +-
 src/hotspot/share/gc/parallel/psCardTable.cpp |  3 +-
 .../share/gc/parallel/psVirtualspace.cpp      |  2 +-
 src/hotspot/share/gc/shared/cardTable.cpp     |  3 +-
 .../share/gc/shenandoah/shenandoahHeap.cpp    |  4 +-
 .../gc/shenandoah/shenandoahHeapRegion.cpp    |  2 +-
 .../share/gc/z/zMarkStackAllocator.cpp        |  2 +-
 .../share/memory/allocation.inline.hpp        |  4 +-
 .../memory/metaspace/virtualSpaceNode.cpp     |  2 +-
 src/hotspot/share/memory/virtualspace.cpp     | 12 ++++--
 src/hotspot/share/prims/whitebox.cpp          |  2 +-
 src/hotspot/share/runtime/os.cpp              | 10 ++---
 src/hotspot/share/runtime/os.hpp              |  8 ++--
 src/hotspot/share/runtime/stackOverflow.cpp   |  2 +-
 .../runtime/test_committed_virtualmemory.cpp  |  4 +-
 19 files changed, 71 insertions(+), 45 deletions(-)

diff --git a/src/hotspot/os/aix/os_aix.cpp b/src/hotspot/os/aix/os_aix.cpp
index 816c516d40c..83151a722f7 100644
--- a/src/hotspot/os/aix/os_aix.cpp
+++ b/src/hotspot/os/aix/os_aix.cpp
@@ -1977,7 +1977,7 @@ void os::pd_commit_memory_or_exit(char* addr, size_t size,
   pd_commit_memory_or_exit(addr, size, exec, mesg);
 }
 
-bool os::pd_uncommit_memory(char* addr, size_t size) {
+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
   assert(is_aligned_to(addr, os::vm_page_size()),
     "addr " PTR_FORMAT " not aligned to vm_page_size (" PTR_FORMAT ")",
     p2i(addr), os::vm_page_size());
@@ -2054,7 +2054,7 @@ char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info
 }
 
 // Reserves and attaches a shared memory segment.
-char* os::pd_reserve_memory(size_t bytes) {
+char* os::pd_reserve_memory(size_t bytes, bool executable) {
   // Always round to os::vm_page_size(), which may be larger than 4K.
   bytes = align_up(bytes, os::vm_page_size());
 
diff --git a/src/hotspot/os/bsd/os_bsd.cpp b/src/hotspot/os/bsd/os_bsd.cpp
index 0589c264331..508c2284e6f 100644
--- a/src/hotspot/os/bsd/os_bsd.cpp
+++ b/src/hotspot/os/bsd/os_bsd.cpp
@@ -1694,12 +1694,16 @@ static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
 //       problem.
 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
-#ifdef __OpenBSD__
+#if defined(__OpenBSD__)
   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
   Events::log(NULL, "Protecting memory [" INTPTR_FORMAT "," INTPTR_FORMAT "] with protection modes %x", p2i(addr), p2i(addr+size), prot);
   if (::mprotect(addr, size, prot) == 0) {
     return true;
   }
+#elif defined(__APPLE__)
+  if (::mprotect(addr, size, prot) == 0) {
+    return true;
+  }
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
                                      MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
@@ -1782,11 +1786,22 @@ char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info
 }
 
 
-bool os::pd_uncommit_memory(char* addr, size_t size) {
-#ifdef __OpenBSD__
+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
+#if defined(__OpenBSD__)
   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
   Events::log(NULL, "Protecting memory [" INTPTR_FORMAT "," INTPTR_FORMAT "] with PROT_NONE", p2i(addr), p2i(addr+size));
   return ::mprotect(addr, size, PROT_NONE) == 0;
+#elif defined(__APPLE__)
+  if (exec) {
+    if (::madvise(addr, size, MADV_FREE) != 0) {
+      return false;
+    }
+    return ::mprotect(addr, size, PROT_NONE) == 0;
+  } else {
+    uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
+        MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
+    return res  != (uintptr_t) MAP_FAILED;
+  }
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
@@ -1801,15 +1816,20 @@ bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
 // If this is a growable mapping, remove the guard pages entirely by
 // munmap()ping them.  If not, just call uncommit_memory().
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  return os::uncommit_memory(addr, size);
+  return os::uncommit_memory(addr, size, !ExecMem);
 }
 
 // 'requested_addr' is only treated as a hint, the return value may or
 // may not start from the requested address. Unlike Bsd mmap(), this
 // function returns NULL to indicate failure.
-static char* anon_mmap(char* requested_addr, size_t bytes) {
+static char* anon_mmap(char* requested_addr, size_t bytes, bool executable) {
   // MAP_FIXED is intentionally left out, to leave existing mappings intact.
-  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
+  int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
+#ifdef __APPLE__
+  if (executable) {
+    flags |= MAP_JIT;
+  }
+#endif
 
   // Map reserved/uncommitted pages PROT_NONE so we fail early if we
   // touch an uncommitted page. Otherwise, the read/write might
@@ -1823,8 +1843,8 @@ static int anon_munmap(char * addr, size_t size) {
   return ::munmap(addr, size) == 0;
 }
 
-char* os::pd_reserve_memory(size_t bytes) {
-  return anon_mmap(NULL /* addr */, bytes);
+char* os::pd_reserve_memory(size_t bytes, bool executable) {
+  return anon_mmap(NULL /* addr */, bytes, executable);
 }
 
 bool os::pd_release_memory(char* addr, size_t size) {
@@ -1934,7 +1954,7 @@ char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes) {
 
   // Bsd mmap allows caller to pass an address as hint; give it a try first,
   // if kernel honors the hint then we can return immediately.
-  char * addr = anon_mmap(requested_addr, bytes);
+  char * addr = anon_mmap(requested_addr, bytes, false/*executable*/);
   if (addr == requested_addr) {
     return requested_addr;
   }
diff --git a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
index e7e332c16b5..53568154b8a 100644
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -3289,7 +3289,7 @@ struct bitmask* os::Linux::_numa_nodes_ptr;
 struct bitmask* os::Linux::_numa_interleave_bitmask;
 struct bitmask* os::Linux::_numa_membind_bitmask;
 
-bool os::pd_uncommit_memory(char* addr, size_t size) {
+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
   return res  != (uintptr_t) MAP_FAILED;
@@ -3474,7 +3474,7 @@ bool os::remove_stack_guard_pages(char* addr, size_t size) {
     return ::munmap(addr, size) == 0;
   }
 
-  return os::uncommit_memory(addr, size);
+  return os::uncommit_memory(addr, size, !ExecMem);
 }
 
 // 'requested_addr' is only treated as a hint, the return value may or
@@ -3533,7 +3533,7 @@ static int anon_munmap(char * addr, size_t size) {
   return ::munmap(addr, size) == 0;
 }
 
-char* os::pd_reserve_memory(size_t bytes) {
+char* os::pd_reserve_memory(size_t bytes, bool executable) {
   return anon_mmap(NULL, bytes);
 }
 
diff --git a/src/hotspot/os/windows/os_windows.cpp b/src/hotspot/os/windows/os_windows.cpp
index 3b829cddac7..c29c3811228 100644
--- a/src/hotspot/os/windows/os_windows.cpp
+++ b/src/hotspot/os/windows/os_windows.cpp
@@ -3182,7 +3182,7 @@ char* os::map_memory_to_file_aligned(size_t size, size_t alignment, int fd) {
   return map_or_reserve_memory_aligned(size, alignment, fd);
 }
 
-char* os::pd_reserve_memory(size_t bytes) {
+char* os::pd_reserve_memory(size_t bytes, bool executable) {
   return pd_attempt_reserve_memory_at(NULL /* addr */, bytes);
 }
 
@@ -3383,7 +3383,7 @@ void os::pd_commit_memory_or_exit(char* addr, size_t size,
   pd_commit_memory_or_exit(addr, size, exec, mesg);
 }
 
-bool os::pd_uncommit_memory(char* addr, size_t bytes) {
+bool os::pd_uncommit_memory(char* addr, size_t bytes, bool exec) {
   if (bytes == 0) {
     // Don't bother the OS with noops.
     return true;
@@ -3402,7 +3402,7 @@ bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
 }
 
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  return os::uncommit_memory(addr, size);
+  return os::uncommit_memory(addr, size, !ExecMem);
 }
 
 static bool protect_pages_individually(char* addr, size_t bytes, unsigned int p, DWORD *old_status) {
diff --git a/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp b/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
index 58eea806fbb..13cbb350ba8 100644
--- a/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
+++ b/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
@@ -217,7 +217,7 @@ void G1PageBasedVirtualSpace::uncommit_internal(size_t start_page, size_t end_pa
             "Given start page " SIZE_FORMAT " is larger or equal to end page " SIZE_FORMAT, start_page, end_page);
 
   char* start_addr = page_start(start_page);
-  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)));
+  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)), !ExecMem);
 }
 
 void G1PageBasedVirtualSpace::uncommit(size_t start_page, size_t size_in_pages) {
diff --git a/src/hotspot/share/gc/parallel/psCardTable.cpp b/src/hotspot/share/gc/parallel/psCardTable.cpp
index 9ad29779ed7..322802a92c8 100644
--- a/src/hotspot/share/gc/parallel/psCardTable.cpp
+++ b/src/hotspot/share/gc/parallel/psCardTable.cpp
@@ -587,7 +587,8 @@ bool PSCardTable::resize_commit_uncommit(int changed_region,
       MemRegion(cur_committed.start(), new_start_aligned));
     if (!uncommit_region.is_empty()) {
       if (!os::uncommit_memory((char*)uncommit_region.start(),
-                               uncommit_region.byte_size())) {
+                               uncommit_region.byte_size(),
+                               !ExecMem)) {
         // If the uncommit fails, ignore it.  Let the
         // committed table resizing go even though the committed
         // table will over state the committed space.
diff --git a/src/hotspot/share/gc/parallel/psVirtualspace.cpp b/src/hotspot/share/gc/parallel/psVirtualspace.cpp
index 473a1f26854..f25d295093a 100644
--- a/src/hotspot/share/gc/parallel/psVirtualspace.cpp
+++ b/src/hotspot/share/gc/parallel/psVirtualspace.cpp
@@ -113,7 +113,7 @@ bool PSVirtualSpace::shrink_by(size_t bytes) {
   }
 
   char* const base_addr = committed_high_addr() - bytes;
-  bool result = special() || os::uncommit_memory(base_addr, bytes);
+  bool result = special() || os::uncommit_memory(base_addr, bytes, !ExecMem);
   if (result) {
     _committed_high_addr -= bytes;
   }
diff --git a/src/hotspot/share/gc/shared/cardTable.cpp b/src/hotspot/share/gc/shared/cardTable.cpp
index b2a7118e8aa..a74070c8d47 100644
--- a/src/hotspot/share/gc/shared/cardTable.cpp
+++ b/src/hotspot/share/gc/shared/cardTable.cpp
@@ -254,7 +254,8 @@ void CardTable::resize_covered_region(MemRegion new_region) {
                                                 cur_committed.end()));
       if (!uncommit_region.is_empty()) {
         if (!os::uncommit_memory((char*)uncommit_region.start(),
-                                 uncommit_region.byte_size())) {
+                                 uncommit_region.byte_size(),
+                                 !ExecMem)) {
           assert(false, "Card table contraction failed");
           // The call failed so don't change the end of the
           // committed region.  This is better than taking the
diff --git a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
index 7c388284665..ecf3bc62b86 100644
--- a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
@@ -1346,7 +1346,7 @@ void ShenandoahHeap::scan_roots_for_iteration(ShenandoahScanObjectStack* oop_sta
 }
 
 void ShenandoahHeap::reclaim_aux_bitmap_for_iteration() {
-  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
+  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), !ExecMem)) {
     log_warning(gc)("Could not uncommit native memory for auxiliary marking bitmap for heap iteration");
   }
 }
@@ -2842,7 +2842,7 @@ bool ShenandoahHeap::uncommit_bitmap_slice(ShenandoahHeapRegion *r) {
   size_t slice = r->index() / _bitmap_regions_per_slice;
   size_t off = _bitmap_bytes_per_slice * slice;
   size_t len = _bitmap_bytes_per_slice;
-  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len)) {
+  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len, !ExecMem)) {
     return false;
   }
   return true;
diff --git a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
index 2dd5f161d1d..eba696a98ad 100644
--- a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
@@ -628,7 +628,7 @@ void ShenandoahHeapRegion::do_commit() {
 
 void ShenandoahHeapRegion::do_uncommit() {
   ShenandoahHeap* heap = ShenandoahHeap::heap();
-  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {
+  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes, !ExecMem)) {
     report_java_out_of_memory("Unable to uncommit region");
   }
   if (!heap->uncommit_bitmap_slice(this)) {
diff --git a/src/hotspot/share/gc/z/zMarkStackAllocator.cpp b/src/hotspot/share/gc/z/zMarkStackAllocator.cpp
index 7673cca7a2d..dbb4e7f4711 100644
--- a/src/hotspot/share/gc/z/zMarkStackAllocator.cpp
+++ b/src/hotspot/share/gc/z/zMarkStackAllocator.cpp
@@ -42,7 +42,7 @@ ZMarkStackSpace::ZMarkStackSpace() :
 
   // Reserve address space
   const size_t size = ZMarkStackSpaceLimit;
-  const uintptr_t addr = (uintptr_t)os::reserve_memory(size, mtGC);
+  const uintptr_t addr = (uintptr_t)os::reserve_memory(size, !ExecMem, mtGC);
   if (addr == 0) {
     log_error_pd(gc, marking)("Failed to reserve address space for mark stacks");
     return;
diff --git a/src/hotspot/share/memory/allocation.inline.hpp b/src/hotspot/share/memory/allocation.inline.hpp
index fb62038ed1b..e913c0c8053 100644
--- a/src/hotspot/share/memory/allocation.inline.hpp
+++ b/src/hotspot/share/memory/allocation.inline.hpp
@@ -56,7 +56,7 @@ template <class E>
 E* MmapArrayAllocator<E>::allocate_or_null(size_t length, MEMFLAGS flags) {
   size_t size = size_for(length);
 
-  char* addr = os::reserve_memory(size, flags);
+  char* addr = os::reserve_memory(size, !ExecMem, flags);
   if (addr == NULL) {
     return NULL;
   }
@@ -73,7 +73,7 @@ template <class E>
 E* MmapArrayAllocator<E>::allocate(size_t length, MEMFLAGS flags) {
   size_t size = size_for(length);
 
-  char* addr = os::reserve_memory(size, flags);
+  char* addr = os::reserve_memory(size, !ExecMem, flags);
   if (addr == NULL) {
     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, "Allocator (reserve)");
   }
diff --git a/src/hotspot/share/memory/metaspace/virtualSpaceNode.cpp b/src/hotspot/share/memory/metaspace/virtualSpaceNode.cpp
index 88a6b9fe27c..a25d8c74619 100644
--- a/src/hotspot/share/memory/metaspace/virtualSpaceNode.cpp
+++ b/src/hotspot/share/memory/metaspace/virtualSpaceNode.cpp
@@ -183,7 +183,7 @@ void VirtualSpaceNode::uncommit_range(MetaWord* p, size_t word_size) {
   }
 
   // Uncommit...
-  if (os::uncommit_memory((char*)p, word_size * BytesPerWord) == false) {
+  if (os::uncommit_memory((char*)p, word_size * BytesPerWord, !ExecMem) == false) {
     // Note: this can actually happen, since uncommit may increase the number of mappings.
     fatal("Failed to uncommit metaspace.");
   }
diff --git a/src/hotspot/share/memory/virtualspace.cpp b/src/hotspot/share/memory/virtualspace.cpp
index ab5849d6ac7..43dc803b8f1 100644
--- a/src/hotspot/share/memory/virtualspace.cpp
+++ b/src/hotspot/share/memory/virtualspace.cpp
@@ -218,7 +218,11 @@ void ReservedSpace::initialize(size_t size, size_t alignment, bool large,
         base = NULL;
       }
     } else {
-      base = map_or_reserve_memory(size, _fd_for_heap);
+      if (_executable) {
+        base = os::reserve_memory(size, ExecMem);
+      } else {
+        base = map_or_reserve_memory(size, _fd_for_heap);
+      }
     }
 
     if (base == NULL) return;
@@ -1006,7 +1010,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(middle_high_boundary() <= aligned_upper_new_high &&
            aligned_upper_new_high + upper_needs <= upper_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs)) {
+    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs, _executable)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
@@ -1017,7 +1021,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(lower_high_boundary() <= aligned_middle_new_high &&
            aligned_middle_new_high + middle_needs <= middle_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs)) {
+    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs, _executable)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
@@ -1028,7 +1032,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(low_boundary() <= aligned_lower_new_high &&
            aligned_lower_new_high + lower_needs <= lower_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs)) {
+    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs, _executable)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
diff --git a/src/hotspot/share/prims/whitebox.cpp b/src/hotspot/share/prims/whitebox.cpp
index 21f1a20bd59..83be6f1833f 100644
--- a/src/hotspot/share/prims/whitebox.cpp
+++ b/src/hotspot/share/prims/whitebox.cpp
@@ -782,7 +782,7 @@ WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size
 WB_END
 
 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
-  os::uncommit_memory((char *)(uintptr_t)addr, size);
+  os::uncommit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 WB_END
 
 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
diff --git a/src/hotspot/share/runtime/os.cpp b/src/hotspot/share/runtime/os.cpp
index 243cd8eb342..4cf2a9fc101 100644
--- a/src/hotspot/share/runtime/os.cpp
+++ b/src/hotspot/share/runtime/os.cpp
@@ -1652,8 +1652,8 @@ bool os::create_stack_guard_pages(char* addr, size_t bytes) {
   return os::pd_create_stack_guard_pages(addr, bytes);
 }
 
-char* os::reserve_memory(size_t bytes, MEMFLAGS flags) {
-  char* result = pd_reserve_memory(bytes);
+char* os::reserve_memory(size_t bytes, bool executable, MEMFLAGS flags) {
+  char* result = pd_reserve_memory(bytes, executable);
   if (result != NULL) {
     MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC);
     if (flags != mtOther) {
@@ -1701,16 +1701,16 @@ void os::commit_memory_or_exit(char* addr, size_t size, size_t alignment_hint,
   MemTracker::record_virtual_memory_commit((address)addr, size, CALLER_PC);
 }
 
-bool os::uncommit_memory(char* addr, size_t bytes) {
+bool os::uncommit_memory(char* addr, size_t bytes, bool exec) {
   bool res;
   if (MemTracker::tracking_level() > NMT_minimal) {
     Tracker tkr(Tracker::uncommit);
-    res = pd_uncommit_memory(addr, bytes);
+    res = pd_uncommit_memory(addr, bytes, exec);
     if (res) {
       tkr.record((address)addr, bytes);
     }
   } else {
-    res = pd_uncommit_memory(addr, bytes);
+    res = pd_uncommit_memory(addr, bytes, exec);
   }
   return res;
 }
diff --git a/src/hotspot/share/runtime/os.hpp b/src/hotspot/share/runtime/os.hpp
index a7f0df698c3..0cff690f606 100644
--- a/src/hotspot/share/runtime/os.hpp
+++ b/src/hotspot/share/runtime/os.hpp
@@ -118,7 +118,7 @@ class os: AllStatic {
     _page_sizes[1] = 0; // sentinel
   }
 
-  static char*  pd_reserve_memory(size_t bytes);
+  static char*  pd_reserve_memory(size_t bytes, bool executable);
 
   static char*  pd_attempt_reserve_memory_at(char* addr, size_t bytes);
 
@@ -132,7 +132,7 @@ class os: AllStatic {
   static void   pd_commit_memory_or_exit(char* addr, size_t size,
                                          size_t alignment_hint,
                                          bool executable, const char* mesg);
-  static bool   pd_uncommit_memory(char* addr, size_t bytes);
+  static bool   pd_uncommit_memory(char* addr, size_t bytes, bool exec);
   static bool   pd_release_memory(char* addr, size_t bytes);
 
   static char*  pd_attempt_map_memory_to_file_at(char* addr, size_t bytes, int file_desc);
@@ -319,7 +319,7 @@ class os: AllStatic {
   static int    vm_allocation_granularity();
 
   // Reserves virtual memory.
-  static char*  reserve_memory(size_t bytes, MEMFLAGS flags = mtOther);
+  static char*  reserve_memory(size_t bytes, bool executable = false, MEMFLAGS flags = mtOther);
 
   // Reserves virtual memory that starts at an address that is aligned to 'alignment'.
   static char*  reserve_memory_aligned(size_t size, size_t alignment);
@@ -348,7 +348,7 @@ class os: AllStatic {
   static void   commit_memory_or_exit(char* addr, size_t size,
                                       size_t alignment_hint,
                                       bool executable, const char* mesg);
-  static bool   uncommit_memory(char* addr, size_t bytes);
+  static bool   uncommit_memory(char* addr, size_t bytes, bool exec);
   static bool   release_memory(char* addr, size_t bytes);
 
   // Touch memory pages that cover the memory range from start to end (exclusive)
diff --git a/src/hotspot/share/runtime/stackOverflow.cpp b/src/hotspot/share/runtime/stackOverflow.cpp
index 01aba3ea2de..0b706e71703 100644
--- a/src/hotspot/share/runtime/stackOverflow.cpp
+++ b/src/hotspot/share/runtime/stackOverflow.cpp
@@ -103,7 +103,7 @@ void StackOverflow::create_stack_guard_pages() {
   } else {
     log_warning(os, thread)("Attempt to protect stack guard pages failed ("
       PTR_FORMAT "-" PTR_FORMAT ").", p2i(low_addr), p2i(low_addr + len));
-    if (os::uncommit_memory((char *) low_addr, len)) {
+    if (os::uncommit_memory((char *) low_addr, len, !ExecMem)) {
       log_warning(os, thread)("Attempt to deallocate stack guard pages failed.");
     }
     return;
diff --git a/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp b/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
index d2539b73382..06378fcdc00 100644
--- a/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
+++ b/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
@@ -101,7 +101,7 @@ class CommittedVirtualMemoryTest {
   static void test_committed_region_impl(size_t num_pages, size_t touch_pages, int* page_num) {
     const size_t page_sz = os::vm_page_size();
     const size_t size = num_pages * page_sz;
-    char* base = os::reserve_memory(size, mtThreadStack);
+    char* base = os::reserve_memory(size, false, mtThreadStack);
     bool result = os::commit_memory(base, size, false);
     size_t index;
     ASSERT_NE(base, (char*)NULL);
@@ -169,7 +169,7 @@ class CommittedVirtualMemoryTest {
     const size_t page_sz = os::vm_page_size();
     const size_t num_pages = 4;
     const size_t size = num_pages * page_sz;
-    char* base = os::reserve_memory(size, mtTest);
+    char* base = os::reserve_memory(size, false, mtTest);
     ASSERT_NE(base, (char*)NULL);
     result = os::commit_memory(base, size, false);
 

From b8df9dd448d0be19535c25609063caccaaa4b5c3 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 10 Nov 2020 09:07:34 -0800
Subject: [PATCH 18/94] JDK-8253816: Add missing WX transition

---
 src/hotspot/share/prims/whitebox.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/hotspot/share/prims/whitebox.cpp b/src/hotspot/share/prims/whitebox.cpp
index 83be6f1833f..8a902494ba0 100644
--- a/src/hotspot/share/prims/whitebox.cpp
+++ b/src/hotspot/share/prims/whitebox.cpp
@@ -2398,6 +2398,7 @@ WB_END
 
 WB_ENTRY(jstring, WB_GetLibcName(JNIEnv* env, jobject o))
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   jstring info_string = env->NewStringUTF(XSTR(LIBC));
   CHECK_JNI_EXCEPTION_(env, NULL);
   return info_string;

From e3ab9962a13b6aa7878d1b42d8aec2bafef91777 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Wed, 11 Nov 2020 03:43:51 -0800
Subject: [PATCH 19/94] JDK-8254941: Update SA implementation

---
 .../native/libsaproc/MacosxDebuggerLocal.m    | 48 +++++++-------
 .../macosx/native/libsaproc/libproc_impl.h    | 66 +++++++++----------
 .../bsd/aarch64/BsdAARCH64CFrame.java         |  1 +
 3 files changed, 58 insertions(+), 57 deletions(-)

diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
index 5a8d7c028fb..29b4d4f67ec 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
@@ -551,16 +551,16 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
 #elif defined(aarch64)
 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
 
-  regs[REG_INDEX(R0)] = gregs.r_r0;
-  regs[REG_INDEX(R1)] = gregs.r_r1;
-  regs[REG_INDEX(R2)] = gregs.r_r2;
-  regs[REG_INDEX(R3)] = gregs.r_r3;
-  regs[REG_INDEX(R4)] = gregs.r_r4;
-  regs[REG_INDEX(R5)] = gregs.r_r5;
-  regs[REG_INDEX(R6)] = gregs.r_r6;
-  regs[REG_INDEX(R7)] = gregs.r_r7;
-  regs[REG_INDEX(R8)] = gregs.r_r8;
-  regs[REG_INDEX(R9)] = gregs.r_r9;
+  regs[REG_INDEX(R0)]  = gregs.r_r0;
+  regs[REG_INDEX(R1)]  = gregs.r_r1;
+  regs[REG_INDEX(R2)]  = gregs.r_r2;
+  regs[REG_INDEX(R3)]  = gregs.r_r3;
+  regs[REG_INDEX(R4)]  = gregs.r_r4;
+  regs[REG_INDEX(R5)]  = gregs.r_r5;
+  regs[REG_INDEX(R6)]  = gregs.r_r6;
+  regs[REG_INDEX(R7)]  = gregs.r_r7;
+  regs[REG_INDEX(R8)]  = gregs.r_r8;
+  regs[REG_INDEX(R9)]  = gregs.r_r9;
   regs[REG_INDEX(R10)] = gregs.r_r10;
   regs[REG_INDEX(R11)] = gregs.r_r11;
   regs[REG_INDEX(R12)] = gregs.r_r12;
@@ -580,10 +580,10 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
   regs[REG_INDEX(R26)] = gregs.r_r26;
   regs[REG_INDEX(R27)] = gregs.r_r27;
   regs[REG_INDEX(R28)] = gregs.r_r28;
-  regs[REG_INDEX(FP)] = gregs.r_fp;
-  regs[REG_INDEX(LR)] = gregs.r_lr;
-  regs[REG_INDEX(SP)] = gregs.r_sp;
-  regs[REG_INDEX(PC)] = gregs.r_pc;
+  regs[REG_INDEX(FP)]  = gregs.r_fp;
+  regs[REG_INDEX(LR)]  = gregs.r_lr;
+  regs[REG_INDEX(SP)]  = gregs.r_sp;
+  regs[REG_INDEX(PC)]  = gregs.r_pc;
 
 #else
 #error UNSUPPORTED_ARCH
@@ -736,16 +736,16 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
 #elif defined(aarch64)
 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
 
-  primitiveArray[REG_INDEX(R0)] = state.__x[0];
-  primitiveArray[REG_INDEX(R1)] = state.__x[1];
-  primitiveArray[REG_INDEX(R2)] = state.__x[2];
-  primitiveArray[REG_INDEX(R3)] = state.__x[3];
-  primitiveArray[REG_INDEX(R4)] = state.__x[4];
-  primitiveArray[REG_INDEX(R5)] = state.__x[5];
-  primitiveArray[REG_INDEX(R6)] = state.__x[6];
-  primitiveArray[REG_INDEX(R7)] = state.__x[7];
-  primitiveArray[REG_INDEX(R8)] = state.__x[8];
-  primitiveArray[REG_INDEX(R9)] = state.__x[9];
+  primitiveArray[REG_INDEX(R0)]  = state.__x[0];
+  primitiveArray[REG_INDEX(R1)]  = state.__x[1];
+  primitiveArray[REG_INDEX(R2)]  = state.__x[2];
+  primitiveArray[REG_INDEX(R3)]  = state.__x[3];
+  primitiveArray[REG_INDEX(R4)]  = state.__x[4];
+  primitiveArray[REG_INDEX(R5)]  = state.__x[5];
+  primitiveArray[REG_INDEX(R6)]  = state.__x[6];
+  primitiveArray[REG_INDEX(R7)]  = state.__x[7];
+  primitiveArray[REG_INDEX(R8)]  = state.__x[8];
+  primitiveArray[REG_INDEX(R9)]  = state.__x[9];
   primitiveArray[REG_INDEX(R10)] = state.__x[10];
   primitiveArray[REG_INDEX(R11)] = state.__x[11];
   primitiveArray[REG_INDEX(R12)] = state.__x[12];
diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
index c12ee989b76..f5bdbc2cdd0 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
@@ -86,39 +86,39 @@ typedef struct reg {
 #elif defined(aarch64)
 /*** registers copied from bsd/arm64 */
 typedef struct reg {
-   register_t     r_r0;
-   register_t     r_r1;
-   register_t     r_r2;
-   register_t     r_r3;
-   register_t     r_r4;
-   register_t     r_r5;
-   register_t     r_r6;
-   register_t     r_r7;
-   register_t     r_r8;
-   register_t     r_r9;
-   register_t     r_r10;
-   register_t     r_r11;
-   register_t     r_r12;
-   register_t     r_r13;
-   register_t     r_r14;
-   register_t     r_r15;
-   register_t     r_r16;
-   register_t     r_r17;
-   register_t     r_r18;
-   register_t     r_r19;
-   register_t     r_r20;
-   register_t     r_r21;
-   register_t     r_r22;
-   register_t     r_r23;
-   register_t     r_r24;
-   register_t     r_r25;
-   register_t     r_r26;
-   register_t     r_r27;
-   register_t     r_r28;
-   register_t     r_fp;
-   register_t     r_lr;
-   register_t     r_sp;
-   register_t     r_pc;
+  register_t      r_r0;
+  register_t      r_r1;
+  register_t      r_r2;
+  register_t      r_r3;
+  register_t      r_r4;
+  register_t      r_r5;
+  register_t      r_r6;
+  register_t      r_r7;
+  register_t      r_r8;
+  register_t      r_r9;
+  register_t      r_r10;
+  register_t      r_r11;
+  register_t      r_r12;
+  register_t      r_r13;
+  register_t      r_r14;
+  register_t      r_r15;
+  register_t      r_r16;
+  register_t      r_r17;
+  register_t      r_r18;
+  register_t      r_r19;
+  register_t      r_r20;
+  register_t      r_r21;
+  register_t      r_r22;
+  register_t      r_r23;
+  register_t      r_r24;
+  register_t      r_r25;
+  register_t      r_r26;
+  register_t      r_r27;
+  register_t      r_r28;
+  register_t      r_fp;
+  register_t      r_lr;
+  register_t      r_sp;
+  register_t      r_pc;
 } reg;
 
 #else
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
index b321935c25e..b39fee212f9 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Red Hat Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it

From f037321cdb094f1b53b27763d2020381ca05f8b0 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Mon, 12 Oct 2020 20:14:48 +0300
Subject: [PATCH 20/94] JDK-8255776: Change build system for macOS/AArch64

ZULU-18973
---
 make/autoconf/platform.m4 | 25 +++++++++++++++++++------
 1 file changed, 19 insertions(+), 6 deletions(-)

diff --git a/make/autoconf/platform.m4 b/make/autoconf/platform.m4
index 2f39d2b0ca7..3f8abb37a3b 100644
--- a/make/autoconf/platform.m4
+++ b/make/autoconf/platform.m4
@@ -55,10 +55,23 @@ AC_DEFUN([PLATFORM_EXTRACT_VARS_FROM_CPU],
       VAR_CPU_ENDIAN=little
       ;;
     arm*)
-      VAR_CPU=arm
-      VAR_CPU_ARCH=arm
-      VAR_CPU_BITS=32
-      VAR_CPU_ENDIAN=little
+      # Second argument is the os name from the trip/quad.
+      # on macos-aarch64, triplet returned by autoconf is
+      # arm-darwin*, but on darwin only aarch64 is present.
+      case "$2" in
+        *darwin*)
+          VAR_CPU=aarch64
+          VAR_CPU_ARCH=aarch64
+          VAR_CPU_BITS=64
+          VAR_CPU_ENDIAN=little
+        ;;
+        *)
+          VAR_CPU=arm
+          VAR_CPU_ARCH=arm
+          VAR_CPU_BITS=32
+          VAR_CPU_ENDIAN=little
+        ;;
+      esac
       ;;
     aarch64)
       VAR_CPU=aarch64
@@ -257,7 +270,7 @@ AC_DEFUN([PLATFORM_EXTRACT_TARGET_AND_BUILD],
 
   # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU/LIBC variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($build_os)
-  PLATFORM_EXTRACT_VARS_FROM_CPU($build_cpu)
+  PLATFORM_EXTRACT_VARS_FROM_CPU($build_cpu, $build_os)
   PLATFORM_EXTRACT_VARS_FROM_LIBC($build_os)
   # ..and setup our own variables. (Do this explicitly to facilitate searching)
   OPENJDK_BUILD_OS="$VAR_OS"
@@ -295,7 +308,7 @@ AC_DEFUN([PLATFORM_EXTRACT_TARGET_AND_BUILD],
 
   # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU/LIBC variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($host_os)
-  PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu)
+  PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu, $host_os)
   PLATFORM_EXTRACT_VARS_FROM_LIBC($host_os)
   # ... and setup our own variables. (Do this explicitly to facilitate searching)
   OPENJDK_TARGET_OS="$VAR_OS"

From 9a75bc3a0a0ae55a7648083f47070ebe0fde456b Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Sun, 1 Nov 2020 23:59:34 -0800
Subject: [PATCH 21/94] JDK-8253816: Fix W^X transitions in gtests

ZULU-18344
---
 test/hotspot/gtest/code/test_vtableStub.cpp   |  2 +
 .../gtest/gc/shared/test_oopStorage.cpp       | 40 +++++++++++++++----
 .../gc/shared/test_oopStorage_parperf.cpp     |  2 +
 test/hotspot/gtest/runtime/test_os.cpp        |  4 ++
 4 files changed, 40 insertions(+), 8 deletions(-)

diff --git a/test/hotspot/gtest/code/test_vtableStub.cpp b/test/hotspot/gtest/code/test_vtableStub.cpp
index 5242ad643bd..9dae675f35f 100644
--- a/test/hotspot/gtest/code/test_vtableStub.cpp
+++ b/test/hotspot/gtest/code/test_vtableStub.cpp
@@ -30,6 +30,7 @@
 TEST_VM(code, vtableStubs) {
   // Should be in VM to use locks
   ThreadInVMfromNative ThreadInVMfromNative(JavaThread::current());
+  Thread::WXWriteFromExecSetter wx_exec;
 
   VtableStubs::find_vtable_stub(0); // min vtable index
   for (int i = 0; i < 15; i++) {
@@ -42,6 +43,7 @@ TEST_VM(code, vtableStubs) {
 TEST_VM(code, itableStubs) {
   // Should be in VM to use locks
   ThreadInVMfromNative ThreadInVMfromNative(JavaThread::current());
+  Thread::WXWriteFromExecSetter wx_exec;
 
   VtableStubs::find_itable_stub(0); // min itable index
   for (int i = 0; i < 15; i++) {
diff --git a/test/hotspot/gtest/gc/shared/test_oopStorage.cpp b/test/hotspot/gtest/gc/shared/test_oopStorage.cpp
index 5fdea55980b..39e92a4f3cb 100644
--- a/test/hotspot/gtest/gc/shared/test_oopStorage.cpp
+++ b/test/hotspot/gtest/gc/shared/test_oopStorage.cpp
@@ -147,6 +147,9 @@ static bool process_deferred_updates(OopStorage& storage) {
 }
 
 static void release_entry(OopStorage& storage, oop* entry, bool process_deferred = true) {
+  // missing transition to vm state
+  Thread::WXWriteFromExecSetter wx_write;
+
   *entry = NULL;
   storage.release(entry);
   if (process_deferred) {
@@ -469,11 +472,17 @@ class OopStorageTestBlockRelease : public OopStorageTestWithAllocation {
       QuickSort::sort(to_release, nrelease, PointerCompare(), false);
     }
 
-    _storage.release(to_release, nrelease);
-    EXPECT_EQ(_max_entries - nrelease, _storage.allocation_count());
+    {
+      // missing transition to vm state
+      Thread::WXWriteFromExecSetter wx_write;
+      _storage.release(to_release, nrelease);
+      EXPECT_EQ(_max_entries - nrelease, _storage.allocation_count());
+    }
 
     for (size_t i = 0; i < nrelease; ++i) {
       release_entry(_storage, _entries[2 * i + 1], false);
+      // missing transition to vm state
+      Thread::WXWriteFromExecSetter wx_write;
       EXPECT_EQ(_max_entries - nrelease - (i + 1), _storage.allocation_count());
     }
     EXPECT_TRUE(process_deferred_updates(_storage));
@@ -501,6 +510,8 @@ TEST_VM_F(OopStorageTest, invalid_pointer) {
   {
     char* mem = NEW_C_HEAP_ARRAY(char, 1000, mtInternal);
     oop* ptr = reinterpret_cast<oop*>(align_down(mem + 250, sizeof(oop)));
+    // missing transition to vm state
+    Thread::WXWriteFromExecSetter wx_write;
     // Predicate returns false for some malloc'ed block.
     EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(ptr));
     FREE_C_HEAP_ARRAY(char, mem);
@@ -509,6 +520,8 @@ TEST_VM_F(OopStorageTest, invalid_pointer) {
   {
     oop obj;
     oop* ptr = &obj;
+    // missing transition to vm state
+    Thread::WXWriteFromExecSetter wx_write;
     // Predicate returns false for some "random" location.
     EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(ptr));
   }
@@ -1027,11 +1040,16 @@ TEST_VM_F(OopStorageTestWithAllocation, allocation_status) {
   oop* garbage = reinterpret_cast<oop*>(1024 * 1024);
   release_entry(_storage, released);
 
-  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));
-  EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, _storage.allocation_status(released));
+  {
+    // missing transition to vm state
+    Thread::WXWriteFromExecSetter wx_write;
+
+    EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));
+    EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, _storage.allocation_status(released));
 #ifndef DISABLE_GARBAGE_ALLOCATION_STATUS_TESTS
-  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));
+    EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));
 #endif
+  }
 
   for (size_t i = 0; i < _max_entries; ++i) {
     if ((_entries[i] != retained) && (_entries[i] != released)) {
@@ -1042,13 +1060,19 @@ TEST_VM_F(OopStorageTestWithAllocation, allocation_status) {
 
   {
     ThreadInVMfromNative invm(JavaThread::current());
+    Thread::WXWriteFromExecSetter wx_write;
     while (_storage.delete_empty_blocks()) {}
   }
-  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));
+
+  {
+    // missing transition to vm state
+    Thread::WXWriteFromExecSetter wx_write;
+    EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));
 #ifndef DISABLE_GARBAGE_ALLOCATION_STATUS_TESTS
-  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(released));
-  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));
+    EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(released));
+    EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));
 #endif // DISABLE_GARBAGE_ALLOCATION_STATUS_TESTS
+  }
 }
 
 TEST_VM_F(OopStorageTest, usage_info) {
diff --git a/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp b/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
index dea8fe7903a..b55822fb26a 100644
--- a/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
+++ b/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
@@ -96,6 +96,8 @@ OopStorageParIterPerf::OopStorageParIterPerf() :
 }
 
 OopStorageParIterPerf::~OopStorageParIterPerf() {
+  // missing transition to vm state
+  Thread::WXWriteFromExecSetter wx_write;
   _storage.release(_entries, ARRAY_SIZE(_entries));
 }
 
diff --git a/test/hotspot/gtest/runtime/test_os.cpp b/test/hotspot/gtest/runtime/test_os.cpp
index 6e3c7e6ac8e..f1027c23ede 100644
--- a/test/hotspot/gtest/runtime/test_os.cpp
+++ b/test/hotspot/gtest/runtime/test_os.cpp
@@ -157,6 +157,10 @@ static void do_test_print_hex_dump(address addr, size_t len, int unitsize, const
   char buf[256];
   buf[0] = '\0';
   stringStream ss(buf, sizeof(buf));
+
+  // missing transition to vm state
+  Thread::WXWriteFromExecSetter wx_write;
+
   os::print_hex_dump(&ss, addr, addr + len, unitsize);
 //  tty->print_cr("expected: %s", expected);
 //  tty->print_cr("result: %s", buf);

From 0008b77f5fece306ef6318b469ff3cfa94b0050c Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Mon, 2 Nov 2020 10:09:24 -0800
Subject: [PATCH 22/94] JDK-8254941: Implement SA

ZULU-18759, ZULU-17253
---
 .../native/libsaproc/MacosxDebuggerLocal.m    | 13 ++++++++---
 .../sun/jvm/hotspot/asm/Disassembler.java     |  5 ++---
 .../bsd/aarch64/BsdAARCH64CFrame.java         |  8 +++----
 .../bsd/aarch64/BsdAARCH64ThreadContext.java  |  1 +
 .../BsdAARCH64JavaThreadPDAccess.java         | 22 +++++++++----------
 5 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
index 29b4d4f67ec..b09b34db5e5 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
@@ -160,16 +160,23 @@ static void throw_new_debugger_exception(JNIEnv* env, const char* errMsg) {
   return (struct ps_prochandle*)(intptr_t)ptr;
 }
 
-#if defined(amd64)
+#if defined(__i386__)
+    #define hsdb_thread_state_t     x86_thread_state32_t
+    #define hsdb_float_state_t      x86_float_state32_t
+    #define HSDB_THREAD_STATE       x86_THREAD_STATE32
+    #define HSDB_FLOAT_STATE        x86_FLOAT_STATE32
+    #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE32_COUNT
+    #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE32_COUNT
+#elif defined(__x86_64__)
     #define hsdb_thread_state_t     x86_thread_state64_t
     #define hsdb_float_state_t      x86_float_state64_t
     #define HSDB_THREAD_STATE       x86_THREAD_STATE64
     #define HSDB_FLOAT_STATE        x86_FLOAT_STATE64
     #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE64_COUNT
     #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE64_COUNT
-#elif defined(aarch64)
+#elif defined(__aarch64__)
     #define hsdb_thread_state_t     arm_thread_state64_t
-    #define hsdb_float_state_t      arm_float_state64_t
+    #define hsdb_float_state_t      arm_neon_state64_t
     #define HSDB_THREAD_STATE       ARM_THREAD_STATE64
     #define HSDB_FLOAT_STATE        ARM_NEON_STATE64
     #define HSDB_THREAD_STATE_COUNT ARM_THREAD_STATE64_COUNT
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java
index 0f29c1cdbea..2bf8e752a9c 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java
@@ -86,12 +86,11 @@ private Disassembler(long startPc, byte[] code) {
                libname +=  "-" + arch + ".so";
             }
          } else if (os.lastIndexOf("Mac OS X", 0) != -1) {
+            path.append(sep + "lib" + sep);
             if (arch.equals("amd64") || arch.equals("x86_64")) {
-               path.append(sep + "lib" + sep);
                libname += "-amd64" + ".dylib";       // x86_64 => amd64
             } else {
-               path.append(sep + "lib" + sep);
-               libname +=  "-" + arch + ".so";
+               libname += "-" + arch + ".dylib";
             }
          } else {
             path.append(sep + "lib" + sep + "arch" + sep);
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
index b39fee212f9..4a8927a0194 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
@@ -57,20 +57,20 @@ public CFrame sender(ThreadProxy thread) {
       AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();
       Address rsp = context.getRegisterAsAddress(AARCH64ThreadContext.SP);
 
-      if ( (fp == null) || fp.lessThan(rsp) ) {
+      if ((fp == null) || fp.lessThan(rsp)) {
         return null;
       }
 
       // Check alignment of fp
-      if (dbg.getAddressValue(fp) % ADDRESS_SIZE != 0) {
+      if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {
         return null;
       }
 
-      Address nextFP = fp.getAddressAt( 0 * ADDRESS_SIZE);
+      Address nextFP = fp.getAddressAt(0 * ADDRESS_SIZE);
       if (nextFP == null || nextFP.lessThanOrEqual(fp)) {
         return null;
       }
-      Address nextPC  = fp.getAddressAt( 1 * ADDRESS_SIZE);
+      Address nextPC  = fp.getAddressAt(1 * ADDRESS_SIZE);
       if (nextPC == null) {
         return null;
       }
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
index 1e0fcf15bb1..49d09bcfe0f 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Red Hat Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
index 53b34d648a4..ab48e3eee32 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Red Hat Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -32,7 +33,6 @@
 import sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal;
 import sun.jvm.hotspot.runtime.*;
 import sun.jvm.hotspot.runtime.aarch64.*;
-import sun.jvm.hotspot.runtime.x86.*;
 import sun.jvm.hotspot.types.*;
 import sun.jvm.hotspot.utilities.*;
 import sun.jvm.hotspot.utilities.Observable;
@@ -70,19 +70,19 @@ private static synchronized void initialize(TypeDataBase db) {
     osThreadUniqueThreadIDField = osThreadType.getCIntegerField("_unique_thread_id");
   }
 
-  public    Address getLastJavaFP(Address addr) {
+  public Address getLastJavaFP(Address addr) {
     return lastJavaFPField.getValue(addr.addOffsetTo(sun.jvm.hotspot.runtime.JavaThread.getAnchorField().getOffset()));
   }
 
-  public    Address getLastJavaPC(Address addr) {
+  public Address getLastJavaPC(Address addr) {
     return null;
   }
 
-  public    Address getBaseOfStackPointer(Address addr) {
+  public Address getBaseOfStackPointer(Address addr) {
     return null;
   }
 
-  public    Frame getLastFramePD(JavaThread thread, Address addr) {
+  public Frame getLastFramePD(JavaThread thread, Address addr) {
     Address fp = thread.getLastJavaFP();
     if (fp == null) {
       return null; // no information
@@ -90,11 +90,11 @@ public    Frame getLastFramePD(JavaThread thread, Address addr) {
     return new AARCH64Frame(thread.getLastJavaSP(), fp);
   }
 
-  public    RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {
+  public RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {
     return new AARCH64RegisterMap(thread, updateMap);
   }
 
-  public    Frame getCurrentFrameGuess(JavaThread thread, Address addr) {
+  public Frame getCurrentFrameGuess(JavaThread thread, Address addr) {
     ThreadProxy t = getThreadProxy(addr);
     AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();
     AARCH64CurrentFrameGuess guesser = new AARCH64CurrentFrameGuess(context, thread);
@@ -108,23 +108,23 @@ public    Frame getCurrentFrameGuess(JavaThread thread, Address addr) {
     }
   }
 
-  public    void printThreadIDOn(Address addr, PrintStream tty) {
+  public void printThreadIDOn(Address addr, PrintStream tty) {
     tty.print(getThreadProxy(addr));
   }
 
-  public    void printInfoOn(Address threadAddr, PrintStream tty) {
+  public void printInfoOn(Address threadAddr, PrintStream tty) {
     tty.print("Thread id: ");
     printThreadIDOn(threadAddr, tty);
 //    tty.println("\nPostJavaState: " + getPostJavaState(threadAddr));
   }
 
-  public    Address getLastSP(Address addr) {
+  public Address getLastSP(Address addr) {
     ThreadProxy t = getThreadProxy(addr);
     AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();
     return context.getRegisterAsAddress(AARCH64ThreadContext.SP);
   }
 
-  public    ThreadProxy getThreadProxy(Address addr) {
+  public ThreadProxy getThreadProxy(Address addr) {
     // Addr is the address of the JavaThread.
     // Fetch the OSThread (for now and for simplicity, not making a
     // separate "OSThread" class in this package)

From 5feabb45f5dc9af74a0ccb21aa1b22db0c38da91 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@openjdk.org>
Date: Fri, 7 Aug 2020 03:28:54 -0700
Subject: [PATCH 23/94] JDK-8253839: Do not use objc_msgSend_stret

ZULU-17145
---
 .../macosx/native/libjava/java_props_macosx.c | 39 ++++++++++++++-----
 1 file changed, 29 insertions(+), 10 deletions(-)

diff --git a/src/java.base/macosx/native/libjava/java_props_macosx.c b/src/java.base/macosx/native/libjava/java_props_macosx.c
index 7df1e15a926..fd33e83c9e0 100644
--- a/src/java.base/macosx/native/libjava/java_props_macosx.c
+++ b/src/java.base/macosx/native/libjava/java_props_macosx.c
@@ -222,23 +222,42 @@ char *setupMacOSXLocale(int cat) {
     }
 }
 
+// 10.9 SDK does not include the NSOperatingSystemVersion struct.
+// For now, create our own
+typedef struct {
+        NSInteger majorVersion;
+        NSInteger minorVersion;
+        NSInteger patchVersion;
+} OSVerStruct;
+
 void setOSNameAndVersion(java_props_t *sprops) {
     // Hardcode os_name, and fill in os_version
     sprops->os_name = strdup("Mac OS X");
 
     char* osVersionCStr = NULL;
-    // Mac OS 10.2 includes the [NSProcessInfo operatingSystemVersionString] function,
-    // but it's not in the 10.2 SDK.  So, call it via objc_msgSend_stret.
-    if ([[NSProcessInfo processInfo] respondsToSelector:@selector(operatingSystemVersionString)]) {
-        NSString* (*procInfoFn)(id rec, SEL sel) = (NSString* (*)(id, SEL))objc_msgSend;
-        NSString *nsVerStr = procInfoFn([NSProcessInfo processInfo],
-                                       @selector(operatingSystemVersionString));
-        if (nsVerStr != NULL) {
-            // Copy out the char*
-            osVersionCStr = strdup([nsVerStr UTF8String]);
+    // Mac OS 10.9 includes the [NSProcessInfo operatingSystemVersion] function,
+    // but it's not in the 10.9 SDK.  So, call it via NSInvocation.
+    if ([[NSProcessInfo processInfo] respondsToSelector:@selector(operatingSystemVersion)]) {
+	OSVerStruct osVer;
+	NSMethodSignature *sig = [[NSProcessInfo processInfo] methodSignatureForSelector:
+		@selector(operatingSystemVersion)];
+	NSInvocation *invoke = [NSInvocation invocationWithMethodSignature:sig];
+	invoke.selector = @selector(operatingSystemVersion);
+	[invoke invokeWithTarget:[NSProcessInfo processInfo]];
+	[invoke getReturnValue:&osVer];
+
+        NSString *nsVerStr;
+        if (osVer.patchVersion == 0) { // Omit trailing ".0"
+            nsVerStr = [NSString stringWithFormat:@"%ld.%ld",
+                    (long)osVer.majorVersion, (long)osVer.minorVersion];
+        } else {
+            nsVerStr = [NSString stringWithFormat:@"%ld.%ld.%ld",
+                    (long)osVer.majorVersion, (long)osVer.minorVersion, (long)osVer.patchVersion];
         }
+        // Copy out the char*
+        osVersionCStr = strdup([nsVerStr UTF8String]);
     }
-    // Fallback if running on pre-10.2 Mac OS
+    // Fallback if running on pre-10.9 Mac OS
     if (osVersionCStr == NULL) {
         NSDictionary *version = [NSDictionary dictionaryWithContentsOfFile :
                                  @"/System/Library/CoreServices/SystemVersion.plist"];

From 7d8c1e10553f0de1c84142ab7703b4619ea215af Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@openjdk.org>
Date: Fri, 24 Jul 2020 19:16:13 +0300
Subject: [PATCH 24/94] JDK-8255776: Make tier1 is broken with xcode12

ZULU-18174
---
 make/test/JtregNativeJdk.gmk | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/make/test/JtregNativeJdk.gmk b/make/test/JtregNativeJdk.gmk
index 57c5bf4035e..5c34460434a 100644
--- a/make/test/JtregNativeJdk.gmk
+++ b/make/test/JtregNativeJdk.gmk
@@ -78,8 +78,8 @@ endif
 ifeq ($(call isTargetOs, macosx), true)
   BUILD_JDK_JTREG_EXCLUDE += exelauncher.c
   BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libTestMainKeyWindow := -ObjC
-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestMainKeyWindow := \
-      -framework Cocoa -framework JavaNativeFoundation
+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestMainKeyWindow := -framework Cocoa \
+      -Wl$(COMMA)-rpath$(COMMA)@loader_path/../lib -framework JavaNativeFoundation
   BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeJniInvocationTest := -ljli
 else
   BUILD_JDK_JTREG_EXCLUDE += libTestMainKeyWindow.c

From 1cc5358311995e8f116b874611892cde781effd5 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@openjdk.org>
Date: Thu, 10 Sep 2020 09:36:26 +0300
Subject: [PATCH 25/94] JDK-8255776: Make codesign to rewrite signature when
 signing

ZULU-18231
---
 make/common/NativeCompilation.gmk | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/make/common/NativeCompilation.gmk b/make/common/NativeCompilation.gmk
index ded7fdf8c59..c0945d2c81a 100644
--- a/make/common/NativeCompilation.gmk
+++ b/make/common/NativeCompilation.gmk
@@ -1163,7 +1163,7 @@ define SetupNativeCompilationBody
                 # This only works if the openjdk_codesign identity is present on the system. Let
                 # silently fail otherwise.
                 ifneq ($(CODESIGN), )
-		  $(CODESIGN) -s "$(MACOSX_CODESIGN_IDENTITY)" --timestamp --options runtime \
+		  $(CODESIGN) -f -s "$(MACOSX_CODESIGN_IDENTITY)" --timestamp --options runtime \
 		      --entitlements $$(call GetEntitlementsFile, $$@) $$@
                 endif
   endif

From 0d65571599e6bba02d93c1a2a83d26adf2451846 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@openjdk.org>
Date: Fri, 11 Sep 2020 16:42:10 +0300
Subject: [PATCH 26/94] JDK-8253819: Disable aot on macarm until it's ready

ZULU-18265
---
 make/autoconf/jvm-features.m4 | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/make/autoconf/jvm-features.m4 b/make/autoconf/jvm-features.m4
index 5ad791795a7..c51503ab97d 100644
--- a/make/autoconf/jvm-features.m4
+++ b/make/autoconf/jvm-features.m4
@@ -242,7 +242,7 @@ AC_DEFUN_ONCE([JVM_FEATURES_CHECK_AOT],
     elif test "x$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU" = "xlinux-aarch64"; then
       AC_MSG_RESULT([yes])
     else
-      AC_MSG_RESULT([no, $OPENJDK_TARGET_CPU])
+      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])
       AVAILABLE=false
     fi
 

From bc800642bee5a24c6c677eaff5935696a9ac2457 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Thu, 15 Oct 2020 18:33:12 +0300
Subject: [PATCH 27/94] JDK-8253819: Disable CDS on macarm

ZULU-18865
---
 make/autoconf/jvm-features.m4 | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/make/autoconf/jvm-features.m4 b/make/autoconf/jvm-features.m4
index c51503ab97d..5a88f49bae9 100644
--- a/make/autoconf/jvm-features.m4
+++ b/make/autoconf/jvm-features.m4
@@ -264,7 +264,9 @@ AC_DEFUN_ONCE([JVM_FEATURES_CHECK_CDS],
 [
   JVM_FEATURES_CHECK_AVAILABILITY(cds, [
     AC_MSG_CHECKING([if platform is supported by CDS])
-    if test "x$OPENJDK_TARGET_OS" != xaix; then
+    if test "x$OPENJDK_TARGET_OS" != xaix && \
+        !( test "x$OPENJDK_TARGET_OS" = "xmacosx" && \
+        test "x$OPENJDK_TARGET_CPU" = "xaarch64" ) ; then
       AC_MSG_RESULT([yes])
     else
       AC_MSG_RESULT([no, $OPENJDK_TARGET_OS])

From fe696e6880d25d6b28aa9dba5d737f82381b475b Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Thu, 24 Sep 2020 06:10:08 -0700
Subject: [PATCH 28/94] JDK-8253819: MacARM: CPU feature detection

ZULU-17241
---
 .../bsd_aarch64/vm_version_bsd_aarch64.cpp    | 54 +++++++++++++++++--
 1 file changed, 49 insertions(+), 5 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
index b850f62f79d..95cf0aa9e21 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
@@ -24,22 +24,66 @@
  */
 
 #include "precompiled.hpp"
+#include "runtime/java.hpp"
 #include "runtime/os.hpp"
 #include "runtime/vm_version.hpp"
 
+#include <sys/sysctl.h>
+
 int VM_Version::get_current_sve_vector_length() {
-  ShouldNotReachHere();
+  ShouldNotCallThis();
   return -1;
 }
 
 int VM_Version::set_and_get_current_sve_vector_length(int length) {
-  ShouldNotReachHere();
+  ShouldNotCallThis();
   return -1;
 }
 
+static bool cpu_has(const char* optional) {
+  uint32_t val;
+  size_t len = sizeof(val);
+  if (sysctlbyname(optional, &val, &len, NULL, 0)) {
+    return false;
+  }
+  return val;
+}
+
 void VM_Version::get_os_cpu_info() {
-  _icache_line_size = _dcache_line_size = 64;
+  size_t sysctllen;
+
+  // hw.optional.floatingpoint always returns 1.
+  // ID_AA64PFR0_EL1 describes AdvSIMD always equals to FP field.
+  _features = CPU_FP | CPU_ASIMD;
+
+  // Only few features are available via sysctl, see line 614
+  // https://opensource.apple.com/source/xnu/xnu-6153.141.1/bsd/kern/kern_mib.c.auto.html
+  if (cpu_has("hw.optional.armv8_crc32"))     _features |= CPU_CRC32;
+  if (cpu_has("hw.optional.armv8_1_atomics")) _features |= CPU_LSE;
+
+  int cache_line_size;
+  int hw_conf_cache_line[] = { CTL_HW, HW_CACHELINE };
+  sysctllen = sizeof(cache_line_size);
+  if (sysctl(hw_conf_cache_line, 2, &cache_line_size, &sysctllen, NULL, 0)) {
+    cache_line_size = 16;
+  }
+  _icache_line_size = 16; // minimal line lenght CCSIDR_EL1 can hold
+  _dcache_line_size = cache_line_size;
+
+  uint64_t dczid_el0;
+  __asm__ (
+    "mrs %0, DCZID_EL0\n"
+    : "=r"(dczid_el0)
+  );
+  if (!(dczid_el0 & 0x10)) {
+    _zva_length = 4 << (dczid_el0 & 0xf);
+  }
 
-  // Disable DC ZVA
-  _zva_length = -1;
+  int family;
+  sysctllen = sizeof(family);
+  if (sysctlbyname("hw.cpufamily", &family, &sysctllen, NULL, 0)) {
+    family = 0;
+  }
+  _model = family;
+  _cpu = CPU_APPLE;
 }

From 3bdd1f93b8ff716ac72bc710b80f7298d96c5c1d Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Mon, 21 Sep 2020 19:29:36 +0300
Subject: [PATCH 29/94] JDK-8253839: gssapi.h needs to be updated for aarch64

ZULU-18340
---
 src/java.security.jgss/share/native/libj2gss/gssapi.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/java.security.jgss/share/native/libj2gss/gssapi.h b/src/java.security.jgss/share/native/libj2gss/gssapi.h
index 764dabdbe8d..6efc456666f 100644
--- a/src/java.security.jgss/share/native/libj2gss/gssapi.h
+++ b/src/java.security.jgss/share/native/libj2gss/gssapi.h
@@ -43,7 +43,7 @@
 extern "C" {
 #endif /* __cplusplus */
 
-#if defined(TARGET_OS_MAC)
+#if TARGET_OS_MAC && (defined(__ppc__) || defined(__ppc64__) || defined(__i386__) || defined(__x86_64__))
 #    pragma pack(push,2)
 #endif
 
@@ -695,7 +695,7 @@ GSS_DLLIMP OM_uint32 gss_canonicalize_name(
         gss_name_t *            /* output_name */
 );
 
-#if defined(TARGET_OS_MAC)
+#if TARGET_OS_MAC && (defined(__ppc__) || defined(__ppc64__) || defined(__i386__) || defined(__x86_64__))
 #    pragma pack(pop)
 #endif
 

From 355c9c1c648a6f2cfc9ffb68e74f2db076e48332 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Wed, 7 Oct 2020 12:46:15 +0300
Subject: [PATCH 30/94] JDK-8253839: Fix NativeCallStack for aarch64

ZULU-18362
---
 src/hotspot/share/utilities/nativeCallStack.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/hotspot/share/utilities/nativeCallStack.cpp b/src/hotspot/share/utilities/nativeCallStack.cpp
index 1093a13eaec..a44791456f5 100644
--- a/src/hotspot/share/utilities/nativeCallStack.cpp
+++ b/src/hotspot/share/utilities/nativeCallStack.cpp
@@ -34,9 +34,9 @@ NativeCallStack::NativeCallStack(int toSkip, bool fillStack) :
   if (fillStack) {
     // We need to skip the NativeCallStack::NativeCallStack frame if a tail call is NOT used
     // to call os::get_native_stack. A tail call is used if _NMT_NOINLINE_ is not defined
-    // (which means this is not a slowdebug build), and we are on 64-bit (except Windows).
-    // This is not necessarily a rule, but what has been obvserved to date.
-#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64))
+    // (which means this is not a slowdebug build), and we are on 64-bit (except Windows
+    // and MacOS-aarch64). This is not necessarily a rule, but what has been obvserved to date.
+#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64) || (defined(BSD) && defined (__aarch64__)))
     // Not a tail call.
     toSkip++;
 #if (defined(_NMT_NOINLINE_) && defined(BSD) && defined(_LP64))

From b01425ed72f95fab0fe361b1b130a9df69000cc8 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Wed, 18 Nov 2020 10:21:59 -0800
Subject: [PATCH 31/94] Fixes after review

---
 .../bsd_aarch64/vm_version_bsd_aarch64.cpp    |  5 +-
 .../native/libsaproc/MacosxDebuggerLocal.m    | 59 ++++++++-----------
 .../bsd/aarch64/BsdAARCH64ThreadContext.java  |  1 -
 .../BsdAARCH64JavaThreadPDAccess.java         |  1 -
 4 files changed, 30 insertions(+), 36 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
index 95cf0aa9e21..68037726990 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
@@ -52,8 +52,11 @@ static bool cpu_has(const char* optional) {
 void VM_Version::get_os_cpu_info() {
   size_t sysctllen;
 
-  // hw.optional.floatingpoint always returns 1.
+  // hw.optional.floatingpoint always returns 1, see
+  // https://github.com/apple/darwin-xnu/blob/master/bsd/kern/kern_mib.c#L416.
   // ID_AA64PFR0_EL1 describes AdvSIMD always equals to FP field.
+  assert(cpu_has("hw.optional.floatingpoint"), "should be");
+  assert(cpu_has("hw.optional.neon"), "should be");
   _features = CPU_FP | CPU_ASIMD;
 
   // Only few features are available via sysctl, see line 614
diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
index b09b34db5e5..b971974c902 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
@@ -160,21 +160,14 @@ static void throw_new_debugger_exception(JNIEnv* env, const char* errMsg) {
   return (struct ps_prochandle*)(intptr_t)ptr;
 }
 
-#if defined(__i386__)
-    #define hsdb_thread_state_t     x86_thread_state32_t
-    #define hsdb_float_state_t      x86_float_state32_t
-    #define HSDB_THREAD_STATE       x86_THREAD_STATE32
-    #define HSDB_FLOAT_STATE        x86_FLOAT_STATE32
-    #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE32_COUNT
-    #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE32_COUNT
-#elif defined(__x86_64__)
+#if defined(amd64)
     #define hsdb_thread_state_t     x86_thread_state64_t
     #define hsdb_float_state_t      x86_float_state64_t
     #define HSDB_THREAD_STATE       x86_THREAD_STATE64
     #define HSDB_FLOAT_STATE        x86_FLOAT_STATE64
     #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE64_COUNT
     #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE64_COUNT
-#elif defined(__aarch64__)
+#elif defined(aarch64)
     #define hsdb_thread_state_t     arm_thread_state64_t
     #define hsdb_float_state_t      arm_neon_state64_t
     #define HSDB_THREAD_STATE       ARM_THREAD_STATE64
@@ -558,16 +551,16 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
 #elif defined(aarch64)
 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
 
-  regs[REG_INDEX(R0)]  = gregs.r_r0;
-  regs[REG_INDEX(R1)]  = gregs.r_r1;
-  regs[REG_INDEX(R2)]  = gregs.r_r2;
-  regs[REG_INDEX(R3)]  = gregs.r_r3;
-  regs[REG_INDEX(R4)]  = gregs.r_r4;
-  regs[REG_INDEX(R5)]  = gregs.r_r5;
-  regs[REG_INDEX(R6)]  = gregs.r_r6;
-  regs[REG_INDEX(R7)]  = gregs.r_r7;
-  regs[REG_INDEX(R8)]  = gregs.r_r8;
-  regs[REG_INDEX(R9)]  = gregs.r_r9;
+  regs[REG_INDEX(R0)] = gregs.r_r0;
+  regs[REG_INDEX(R1)] = gregs.r_r1;
+  regs[REG_INDEX(R2)] = gregs.r_r2;
+  regs[REG_INDEX(R3)] = gregs.r_r3;
+  regs[REG_INDEX(R4)] = gregs.r_r4;
+  regs[REG_INDEX(R5)] = gregs.r_r5;
+  regs[REG_INDEX(R6)] = gregs.r_r6;
+  regs[REG_INDEX(R7)] = gregs.r_r7;
+  regs[REG_INDEX(R8)] = gregs.r_r8;
+  regs[REG_INDEX(R9)] = gregs.r_r9;
   regs[REG_INDEX(R10)] = gregs.r_r10;
   regs[REG_INDEX(R11)] = gregs.r_r11;
   regs[REG_INDEX(R12)] = gregs.r_r12;
@@ -587,10 +580,10 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
   regs[REG_INDEX(R26)] = gregs.r_r26;
   regs[REG_INDEX(R27)] = gregs.r_r27;
   regs[REG_INDEX(R28)] = gregs.r_r28;
-  regs[REG_INDEX(FP)]  = gregs.r_fp;
-  regs[REG_INDEX(LR)]  = gregs.r_lr;
-  regs[REG_INDEX(SP)]  = gregs.r_sp;
-  regs[REG_INDEX(PC)]  = gregs.r_pc;
+  regs[REG_INDEX(FP)] = gregs.r_fp;
+  regs[REG_INDEX(LR)] = gregs.r_lr;
+  regs[REG_INDEX(SP)] = gregs.r_sp;
+  regs[REG_INDEX(PC)] = gregs.r_pc;
 
 #else
 #error UNSUPPORTED_ARCH
@@ -743,16 +736,16 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
 #elif defined(aarch64)
 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
 
-  primitiveArray[REG_INDEX(R0)]  = state.__x[0];
-  primitiveArray[REG_INDEX(R1)]  = state.__x[1];
-  primitiveArray[REG_INDEX(R2)]  = state.__x[2];
-  primitiveArray[REG_INDEX(R3)]  = state.__x[3];
-  primitiveArray[REG_INDEX(R4)]  = state.__x[4];
-  primitiveArray[REG_INDEX(R5)]  = state.__x[5];
-  primitiveArray[REG_INDEX(R6)]  = state.__x[6];
-  primitiveArray[REG_INDEX(R7)]  = state.__x[7];
-  primitiveArray[REG_INDEX(R8)]  = state.__x[8];
-  primitiveArray[REG_INDEX(R9)]  = state.__x[9];
+  primitiveArray[REG_INDEX(R0)] = state.__x[0];
+  primitiveArray[REG_INDEX(R1)] = state.__x[1];
+  primitiveArray[REG_INDEX(R2)] = state.__x[2];
+  primitiveArray[REG_INDEX(R3)] = state.__x[3];
+  primitiveArray[REG_INDEX(R4)] = state.__x[4];
+  primitiveArray[REG_INDEX(R5)] = state.__x[5];
+  primitiveArray[REG_INDEX(R6)] = state.__x[6];
+  primitiveArray[REG_INDEX(R7)] = state.__x[7];
+  primitiveArray[REG_INDEX(R8)] = state.__x[8];
+  primitiveArray[REG_INDEX(R9)] = state.__x[9];
   primitiveArray[REG_INDEX(R10)] = state.__x[10];
   primitiveArray[REG_INDEX(R11)] = state.__x[11];
   primitiveArray[REG_INDEX(R12)] = state.__x[12];
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
index 49d09bcfe0f..1e0fcf15bb1 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
@@ -1,6 +1,5 @@
 /*
  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2015, Red Hat Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
index ab48e3eee32..ed438b044dc 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
@@ -1,6 +1,5 @@
 /*
  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2015, Red Hat Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it

From 47396be77b0d567fd3fc99736454da834bca4c1f Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Thu, 19 Nov 2020 08:39:00 -0800
Subject: [PATCH 32/94] Add Xcode reference in gssapi.h

---
 src/java.security.jgss/share/native/libj2gss/gssapi.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/java.security.jgss/share/native/libj2gss/gssapi.h b/src/java.security.jgss/share/native/libj2gss/gssapi.h
index 6efc456666f..467a0b85a6e 100644
--- a/src/java.security.jgss/share/native/libj2gss/gssapi.h
+++ b/src/java.security.jgss/share/native/libj2gss/gssapi.h
@@ -43,6 +43,8 @@
 extern "C" {
 #endif /* __cplusplus */
 
+// Condition was copied from
+// Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/gssapi/gssapi.h
 #if TARGET_OS_MAC && (defined(__ppc__) || defined(__ppc64__) || defined(__i386__) || defined(__x86_64__))
 #    pragma pack(push,2)
 #endif

From 8383f41ca7faa59dab17f6bb47fecd5a93ab72e3 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <drakon.mega@gmail.com>
Date: Thu, 17 Dec 2020 18:30:07 +0300
Subject: [PATCH 33/94] JDK-8253816: Switch to Exec W^X mode after JNI
 DetachCurrentThread (#10)

---
 src/hotspot/share/prims/jni.cpp               |   4 +
 .../TestCodegenAttach.java                    |  41 +++++++
 .../codegenAttachThread/libcodegenAttach.c    | 115 ++++++++++++++++++
 3 files changed, 160 insertions(+)
 create mode 100644 test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java
 create mode 100644 test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c

diff --git a/src/hotspot/share/prims/jni.cpp b/src/hotspot/share/prims/jni.cpp
index 445fd0c30db..d05003d00dc 100644
--- a/src/hotspot/share/prims/jni.cpp
+++ b/src/hotspot/share/prims/jni.cpp
@@ -4106,6 +4106,10 @@ jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
   thread->exit(false, JavaThread::jni_detach);
   thread->smr_delete();
 
+  // Go to the execute mode, the initial state of the thread on creation.
+  // Use os interface as the thread is not a java one anymore.
+  os::current_thread_enable_wx(WXExec);
+
   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
   return JNI_OK;
 }
diff --git a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java
new file mode 100644
index 00000000000..333608470b4
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @requires os.arch == "aarch64" & os.family == "mac"
+ * @run main/othervm/native TestCodegenAttach
+ */
+
+public class TestCodegenAttach {
+
+    static native void testCodegenAttach();
+
+    static {
+        System.loadLibrary("codegenAttach");
+    }
+
+    public static void main(String[] args) throws Throwable {
+        testCodegenAttach();
+    }
+}
diff --git a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c
new file mode 100644
index 00000000000..aa9669a69d7
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+
+#include <pthread.h>
+#include <string.h>
+
+#include <sys/mman.h>
+
+#include "jni.h"
+
+JavaVM* jvm;
+
+#ifdef __APPLE__
+#define MACOS_ONLY(x) x
+#else // __APPLE__
+#define MACOS_ONLY(x)
+#endif
+
+static void* codegen;
+
+static int thread_start2(int val) {
+  JNIEnv *env;
+  jclass class_id;
+  jmethodID method_id;
+  int res;
+
+  printf("Native thread is running and attaching ...\n");
+
+  res = (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);
+  if (res != JNI_OK) {
+    fprintf(stderr, "Test ERROR. Can't attach current thread: %d\n", res);
+    exit(1);
+  }
+
+  res = (*jvm)->DetachCurrentThread(jvm);
+  if (res != JNI_OK) {
+    fprintf(stderr, "Test ERROR. Can't detach current thread: %d\n", res);
+    exit(1);
+  }
+
+  printf("Native thread is about to finish\n");
+  return 1 + val;
+}
+
+static int trampoline(int(*fn)(int), int arg) {
+  int val = fn(arg);
+  // ensure code in MAP_JIT area after target function returns
+  return 1 + val;
+}
+
+static void * thread_start(void* unused) {
+  int val = ((int(*)(int(*)(int),int))codegen)(thread_start2, 10);
+  printf("return val = %d\n", val);
+  return NULL;
+}
+
+JNIEXPORT void JNICALL
+Java_TestCodegenAttach_testCodegenAttach
+(JNIEnv *env, jclass cls) {
+
+  codegen = mmap(NULL, 0x1000,
+      PROT_READ | PROT_WRITE | PROT_EXEC,
+      MAP_PRIVATE | MAP_ANONYMOUS MACOS_ONLY(| MAP_JIT), -1, 0);
+  if (codegen == MAP_FAILED) {
+    perror("mmap");
+    exit(1);
+  }
+
+  MACOS_ONLY(pthread_jit_write_protect_np(false));
+
+  memcpy(codegen, trampoline, 128);
+
+  MACOS_ONLY(pthread_jit_write_protect_np(true));
+
+  pthread_t thread;
+  int res = (*env)->GetJavaVM(env, &jvm);
+  if (res != JNI_OK) {
+    fprintf(stderr, "Test ERROR. Can't extract JavaVM: %d\n", res);
+    exit(1);
+  }
+
+  if ((res = pthread_create(&thread, NULL, thread_start, NULL)) != 0) {
+    fprintf(stderr, "TEST ERROR: pthread_create failed: %s (%d)\n", strerror(res), res);
+    exit(1);
+  }
+
+  if ((res = pthread_join(thread, NULL)) != 0) {
+    fprintf(stderr, "TEST ERROR: pthread_join failed: %s (%d)\n", strerror(res), res);
+    exit(1);
+  }
+}

From 4885779f4c13ceb973e3bce8b63386eabab5b6eb Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 15 Jan 2021 04:17:46 -0800
Subject: [PATCH 34/94] Fix libcodegenAttach build failures on various OS

---
 .../codegenAttachThread/libcodegenAttach.c    | 32 ++++++++++++-------
 1 file changed, 20 insertions(+), 12 deletions(-)

diff --git a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c
index aa9669a69d7..7ea0623def1 100644
--- a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c
+++ b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c
@@ -21,24 +21,21 @@
  * questions.
  */
 
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdbool.h>
 
-#include <pthread.h>
 #include <string.h>
 
-#include <sys/mman.h>
-
 #include "jni.h"
 
-JavaVM* jvm;
+#if defined(__APPLE__) && defined(__aarch64__)
+
+#include <pthread.h>
+#include <sys/mman.h>
 
-#ifdef __APPLE__
-#define MACOS_ONLY(x) x
-#else // __APPLE__
-#define MACOS_ONLY(x)
-#endif
+JavaVM* jvm;
 
 static void* codegen;
 
@@ -84,17 +81,17 @@ Java_TestCodegenAttach_testCodegenAttach
 
   codegen = mmap(NULL, 0x1000,
       PROT_READ | PROT_WRITE | PROT_EXEC,
-      MAP_PRIVATE | MAP_ANONYMOUS MACOS_ONLY(| MAP_JIT), -1, 0);
+      MAP_PRIVATE | MAP_ANONYMOUS | MAP_JIT, -1, 0);
   if (codegen == MAP_FAILED) {
     perror("mmap");
     exit(1);
   }
 
-  MACOS_ONLY(pthread_jit_write_protect_np(false));
+  pthread_jit_write_protect_np(false);
 
   memcpy(codegen, trampoline, 128);
 
-  MACOS_ONLY(pthread_jit_write_protect_np(true));
+  pthread_jit_write_protect_np(true);
 
   pthread_t thread;
   int res = (*env)->GetJavaVM(env, &jvm);
@@ -113,3 +110,14 @@ Java_TestCodegenAttach_testCodegenAttach
     exit(1);
   }
 }
+
+#else
+
+JNIEXPORT void JNICALL
+Java_TestCodegenAttach_testCodegenAttach
+(JNIEnv *env, jclass cls) {
+  printf("should not reach here\n");
+  exit(1);
+}
+
+#endif // __APPLE__ && __aarch64__

From 99a3dce87a9b9eccc18b74eb136e1bc96a1443f0 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 15 Jan 2021 06:02:49 -0800
Subject: [PATCH 35/94] Revert "Import JDK-8234930 v3: Use MAP_JIT when
 allocating pages for code cache on macOS"

This reverts commit b41b3a949e349d5b6ac57ff745bf8308d6a1720e.
---
 src/hotspot/os/aix/os_aix.cpp                 |  4 +-
 src/hotspot/os/bsd/os_bsd.cpp                 | 38 +++++--------------
 src/hotspot/os/linux/os_linux.cpp             |  6 +--
 src/hotspot/os/windows/os_windows.cpp         |  6 +--
 .../share/gc/g1/g1PageBasedVirtualSpace.cpp   |  2 +-
 src/hotspot/share/gc/parallel/psCardTable.cpp |  3 +-
 .../share/gc/parallel/psVirtualspace.cpp      |  2 +-
 src/hotspot/share/gc/shared/cardTable.cpp     |  3 +-
 .../share/gc/shenandoah/shenandoahHeap.cpp    |  4 +-
 .../gc/shenandoah/shenandoahHeapRegion.cpp    |  2 +-
 .../share/gc/z/zMarkStackAllocator.cpp        |  2 +-
 .../share/memory/allocation.inline.hpp        |  4 +-
 .../memory/metaspace/virtualSpaceNode.cpp     |  2 +-
 src/hotspot/share/memory/virtualspace.cpp     | 12 ++----
 src/hotspot/share/prims/whitebox.cpp          |  2 +-
 src/hotspot/share/runtime/os.cpp              | 10 ++---
 src/hotspot/share/runtime/os.hpp              |  8 ++--
 src/hotspot/share/runtime/stackOverflow.cpp   |  2 +-
 .../runtime/test_committed_virtualmemory.cpp  |  4 +-
 19 files changed, 45 insertions(+), 71 deletions(-)

diff --git a/src/hotspot/os/aix/os_aix.cpp b/src/hotspot/os/aix/os_aix.cpp
index 83151a722f7..816c516d40c 100644
--- a/src/hotspot/os/aix/os_aix.cpp
+++ b/src/hotspot/os/aix/os_aix.cpp
@@ -1977,7 +1977,7 @@ void os::pd_commit_memory_or_exit(char* addr, size_t size,
   pd_commit_memory_or_exit(addr, size, exec, mesg);
 }
 
-bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
+bool os::pd_uncommit_memory(char* addr, size_t size) {
   assert(is_aligned_to(addr, os::vm_page_size()),
     "addr " PTR_FORMAT " not aligned to vm_page_size (" PTR_FORMAT ")",
     p2i(addr), os::vm_page_size());
@@ -2054,7 +2054,7 @@ char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info
 }
 
 // Reserves and attaches a shared memory segment.
-char* os::pd_reserve_memory(size_t bytes, bool executable) {
+char* os::pd_reserve_memory(size_t bytes) {
   // Always round to os::vm_page_size(), which may be larger than 4K.
   bytes = align_up(bytes, os::vm_page_size());
 
diff --git a/src/hotspot/os/bsd/os_bsd.cpp b/src/hotspot/os/bsd/os_bsd.cpp
index 508c2284e6f..0589c264331 100644
--- a/src/hotspot/os/bsd/os_bsd.cpp
+++ b/src/hotspot/os/bsd/os_bsd.cpp
@@ -1694,16 +1694,12 @@ static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
 //       problem.
 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
-#if defined(__OpenBSD__)
+#ifdef __OpenBSD__
   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
   Events::log(NULL, "Protecting memory [" INTPTR_FORMAT "," INTPTR_FORMAT "] with protection modes %x", p2i(addr), p2i(addr+size), prot);
   if (::mprotect(addr, size, prot) == 0) {
     return true;
   }
-#elif defined(__APPLE__)
-  if (::mprotect(addr, size, prot) == 0) {
-    return true;
-  }
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
                                      MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
@@ -1786,22 +1782,11 @@ char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info
 }
 
 
-bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
-#if defined(__OpenBSD__)
+bool os::pd_uncommit_memory(char* addr, size_t size) {
+#ifdef __OpenBSD__
   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
   Events::log(NULL, "Protecting memory [" INTPTR_FORMAT "," INTPTR_FORMAT "] with PROT_NONE", p2i(addr), p2i(addr+size));
   return ::mprotect(addr, size, PROT_NONE) == 0;
-#elif defined(__APPLE__)
-  if (exec) {
-    if (::madvise(addr, size, MADV_FREE) != 0) {
-      return false;
-    }
-    return ::mprotect(addr, size, PROT_NONE) == 0;
-  } else {
-    uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
-        MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
-    return res  != (uintptr_t) MAP_FAILED;
-  }
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
@@ -1816,20 +1801,15 @@ bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
 // If this is a growable mapping, remove the guard pages entirely by
 // munmap()ping them.  If not, just call uncommit_memory().
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  return os::uncommit_memory(addr, size, !ExecMem);
+  return os::uncommit_memory(addr, size);
 }
 
 // 'requested_addr' is only treated as a hint, the return value may or
 // may not start from the requested address. Unlike Bsd mmap(), this
 // function returns NULL to indicate failure.
-static char* anon_mmap(char* requested_addr, size_t bytes, bool executable) {
+static char* anon_mmap(char* requested_addr, size_t bytes) {
   // MAP_FIXED is intentionally left out, to leave existing mappings intact.
-  int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
-#ifdef __APPLE__
-  if (executable) {
-    flags |= MAP_JIT;
-  }
-#endif
+  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
 
   // Map reserved/uncommitted pages PROT_NONE so we fail early if we
   // touch an uncommitted page. Otherwise, the read/write might
@@ -1843,8 +1823,8 @@ static int anon_munmap(char * addr, size_t size) {
   return ::munmap(addr, size) == 0;
 }
 
-char* os::pd_reserve_memory(size_t bytes, bool executable) {
-  return anon_mmap(NULL /* addr */, bytes, executable);
+char* os::pd_reserve_memory(size_t bytes) {
+  return anon_mmap(NULL /* addr */, bytes);
 }
 
 bool os::pd_release_memory(char* addr, size_t size) {
@@ -1954,7 +1934,7 @@ char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes) {
 
   // Bsd mmap allows caller to pass an address as hint; give it a try first,
   // if kernel honors the hint then we can return immediately.
-  char * addr = anon_mmap(requested_addr, bytes, false/*executable*/);
+  char * addr = anon_mmap(requested_addr, bytes);
   if (addr == requested_addr) {
     return requested_addr;
   }
diff --git a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
index 53568154b8a..e7e332c16b5 100644
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -3289,7 +3289,7 @@ struct bitmask* os::Linux::_numa_nodes_ptr;
 struct bitmask* os::Linux::_numa_interleave_bitmask;
 struct bitmask* os::Linux::_numa_membind_bitmask;
 
-bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
+bool os::pd_uncommit_memory(char* addr, size_t size) {
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
   return res  != (uintptr_t) MAP_FAILED;
@@ -3474,7 +3474,7 @@ bool os::remove_stack_guard_pages(char* addr, size_t size) {
     return ::munmap(addr, size) == 0;
   }
 
-  return os::uncommit_memory(addr, size, !ExecMem);
+  return os::uncommit_memory(addr, size);
 }
 
 // 'requested_addr' is only treated as a hint, the return value may or
@@ -3533,7 +3533,7 @@ static int anon_munmap(char * addr, size_t size) {
   return ::munmap(addr, size) == 0;
 }
 
-char* os::pd_reserve_memory(size_t bytes, bool executable) {
+char* os::pd_reserve_memory(size_t bytes) {
   return anon_mmap(NULL, bytes);
 }
 
diff --git a/src/hotspot/os/windows/os_windows.cpp b/src/hotspot/os/windows/os_windows.cpp
index c29c3811228..3b829cddac7 100644
--- a/src/hotspot/os/windows/os_windows.cpp
+++ b/src/hotspot/os/windows/os_windows.cpp
@@ -3182,7 +3182,7 @@ char* os::map_memory_to_file_aligned(size_t size, size_t alignment, int fd) {
   return map_or_reserve_memory_aligned(size, alignment, fd);
 }
 
-char* os::pd_reserve_memory(size_t bytes, bool executable) {
+char* os::pd_reserve_memory(size_t bytes) {
   return pd_attempt_reserve_memory_at(NULL /* addr */, bytes);
 }
 
@@ -3383,7 +3383,7 @@ void os::pd_commit_memory_or_exit(char* addr, size_t size,
   pd_commit_memory_or_exit(addr, size, exec, mesg);
 }
 
-bool os::pd_uncommit_memory(char* addr, size_t bytes, bool exec) {
+bool os::pd_uncommit_memory(char* addr, size_t bytes) {
   if (bytes == 0) {
     // Don't bother the OS with noops.
     return true;
@@ -3402,7 +3402,7 @@ bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
 }
 
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  return os::uncommit_memory(addr, size, !ExecMem);
+  return os::uncommit_memory(addr, size);
 }
 
 static bool protect_pages_individually(char* addr, size_t bytes, unsigned int p, DWORD *old_status) {
diff --git a/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp b/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
index 13cbb350ba8..58eea806fbb 100644
--- a/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
+++ b/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
@@ -217,7 +217,7 @@ void G1PageBasedVirtualSpace::uncommit_internal(size_t start_page, size_t end_pa
             "Given start page " SIZE_FORMAT " is larger or equal to end page " SIZE_FORMAT, start_page, end_page);
 
   char* start_addr = page_start(start_page);
-  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)), !ExecMem);
+  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)));
 }
 
 void G1PageBasedVirtualSpace::uncommit(size_t start_page, size_t size_in_pages) {
diff --git a/src/hotspot/share/gc/parallel/psCardTable.cpp b/src/hotspot/share/gc/parallel/psCardTable.cpp
index 322802a92c8..9ad29779ed7 100644
--- a/src/hotspot/share/gc/parallel/psCardTable.cpp
+++ b/src/hotspot/share/gc/parallel/psCardTable.cpp
@@ -587,8 +587,7 @@ bool PSCardTable::resize_commit_uncommit(int changed_region,
       MemRegion(cur_committed.start(), new_start_aligned));
     if (!uncommit_region.is_empty()) {
       if (!os::uncommit_memory((char*)uncommit_region.start(),
-                               uncommit_region.byte_size(),
-                               !ExecMem)) {
+                               uncommit_region.byte_size())) {
         // If the uncommit fails, ignore it.  Let the
         // committed table resizing go even though the committed
         // table will over state the committed space.
diff --git a/src/hotspot/share/gc/parallel/psVirtualspace.cpp b/src/hotspot/share/gc/parallel/psVirtualspace.cpp
index f25d295093a..473a1f26854 100644
--- a/src/hotspot/share/gc/parallel/psVirtualspace.cpp
+++ b/src/hotspot/share/gc/parallel/psVirtualspace.cpp
@@ -113,7 +113,7 @@ bool PSVirtualSpace::shrink_by(size_t bytes) {
   }
 
   char* const base_addr = committed_high_addr() - bytes;
-  bool result = special() || os::uncommit_memory(base_addr, bytes, !ExecMem);
+  bool result = special() || os::uncommit_memory(base_addr, bytes);
   if (result) {
     _committed_high_addr -= bytes;
   }
diff --git a/src/hotspot/share/gc/shared/cardTable.cpp b/src/hotspot/share/gc/shared/cardTable.cpp
index a74070c8d47..b2a7118e8aa 100644
--- a/src/hotspot/share/gc/shared/cardTable.cpp
+++ b/src/hotspot/share/gc/shared/cardTable.cpp
@@ -254,8 +254,7 @@ void CardTable::resize_covered_region(MemRegion new_region) {
                                                 cur_committed.end()));
       if (!uncommit_region.is_empty()) {
         if (!os::uncommit_memory((char*)uncommit_region.start(),
-                                 uncommit_region.byte_size(),
-                                 !ExecMem)) {
+                                 uncommit_region.byte_size())) {
           assert(false, "Card table contraction failed");
           // The call failed so don't change the end of the
           // committed region.  This is better than taking the
diff --git a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
index ecf3bc62b86..7c388284665 100644
--- a/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
@@ -1346,7 +1346,7 @@ void ShenandoahHeap::scan_roots_for_iteration(ShenandoahScanObjectStack* oop_sta
 }
 
 void ShenandoahHeap::reclaim_aux_bitmap_for_iteration() {
-  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), !ExecMem)) {
+  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
     log_warning(gc)("Could not uncommit native memory for auxiliary marking bitmap for heap iteration");
   }
 }
@@ -2842,7 +2842,7 @@ bool ShenandoahHeap::uncommit_bitmap_slice(ShenandoahHeapRegion *r) {
   size_t slice = r->index() / _bitmap_regions_per_slice;
   size_t off = _bitmap_bytes_per_slice * slice;
   size_t len = _bitmap_bytes_per_slice;
-  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len, !ExecMem)) {
+  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len)) {
     return false;
   }
   return true;
diff --git a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
index eba696a98ad..2dd5f161d1d 100644
--- a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
@@ -628,7 +628,7 @@ void ShenandoahHeapRegion::do_commit() {
 
 void ShenandoahHeapRegion::do_uncommit() {
   ShenandoahHeap* heap = ShenandoahHeap::heap();
-  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes, !ExecMem)) {
+  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {
     report_java_out_of_memory("Unable to uncommit region");
   }
   if (!heap->uncommit_bitmap_slice(this)) {
diff --git a/src/hotspot/share/gc/z/zMarkStackAllocator.cpp b/src/hotspot/share/gc/z/zMarkStackAllocator.cpp
index dbb4e7f4711..7673cca7a2d 100644
--- a/src/hotspot/share/gc/z/zMarkStackAllocator.cpp
+++ b/src/hotspot/share/gc/z/zMarkStackAllocator.cpp
@@ -42,7 +42,7 @@ ZMarkStackSpace::ZMarkStackSpace() :
 
   // Reserve address space
   const size_t size = ZMarkStackSpaceLimit;
-  const uintptr_t addr = (uintptr_t)os::reserve_memory(size, !ExecMem, mtGC);
+  const uintptr_t addr = (uintptr_t)os::reserve_memory(size, mtGC);
   if (addr == 0) {
     log_error_pd(gc, marking)("Failed to reserve address space for mark stacks");
     return;
diff --git a/src/hotspot/share/memory/allocation.inline.hpp b/src/hotspot/share/memory/allocation.inline.hpp
index e913c0c8053..fb62038ed1b 100644
--- a/src/hotspot/share/memory/allocation.inline.hpp
+++ b/src/hotspot/share/memory/allocation.inline.hpp
@@ -56,7 +56,7 @@ template <class E>
 E* MmapArrayAllocator<E>::allocate_or_null(size_t length, MEMFLAGS flags) {
   size_t size = size_for(length);
 
-  char* addr = os::reserve_memory(size, !ExecMem, flags);
+  char* addr = os::reserve_memory(size, flags);
   if (addr == NULL) {
     return NULL;
   }
@@ -73,7 +73,7 @@ template <class E>
 E* MmapArrayAllocator<E>::allocate(size_t length, MEMFLAGS flags) {
   size_t size = size_for(length);
 
-  char* addr = os::reserve_memory(size, !ExecMem, flags);
+  char* addr = os::reserve_memory(size, flags);
   if (addr == NULL) {
     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, "Allocator (reserve)");
   }
diff --git a/src/hotspot/share/memory/metaspace/virtualSpaceNode.cpp b/src/hotspot/share/memory/metaspace/virtualSpaceNode.cpp
index a25d8c74619..88a6b9fe27c 100644
--- a/src/hotspot/share/memory/metaspace/virtualSpaceNode.cpp
+++ b/src/hotspot/share/memory/metaspace/virtualSpaceNode.cpp
@@ -183,7 +183,7 @@ void VirtualSpaceNode::uncommit_range(MetaWord* p, size_t word_size) {
   }
 
   // Uncommit...
-  if (os::uncommit_memory((char*)p, word_size * BytesPerWord, !ExecMem) == false) {
+  if (os::uncommit_memory((char*)p, word_size * BytesPerWord) == false) {
     // Note: this can actually happen, since uncommit may increase the number of mappings.
     fatal("Failed to uncommit metaspace.");
   }
diff --git a/src/hotspot/share/memory/virtualspace.cpp b/src/hotspot/share/memory/virtualspace.cpp
index 43dc803b8f1..ab5849d6ac7 100644
--- a/src/hotspot/share/memory/virtualspace.cpp
+++ b/src/hotspot/share/memory/virtualspace.cpp
@@ -218,11 +218,7 @@ void ReservedSpace::initialize(size_t size, size_t alignment, bool large,
         base = NULL;
       }
     } else {
-      if (_executable) {
-        base = os::reserve_memory(size, ExecMem);
-      } else {
-        base = map_or_reserve_memory(size, _fd_for_heap);
-      }
+      base = map_or_reserve_memory(size, _fd_for_heap);
     }
 
     if (base == NULL) return;
@@ -1010,7 +1006,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(middle_high_boundary() <= aligned_upper_new_high &&
            aligned_upper_new_high + upper_needs <= upper_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs, _executable)) {
+    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
@@ -1021,7 +1017,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(lower_high_boundary() <= aligned_middle_new_high &&
            aligned_middle_new_high + middle_needs <= middle_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs, _executable)) {
+    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
@@ -1032,7 +1028,7 @@ void VirtualSpace::shrink_by(size_t size) {
     assert(low_boundary() <= aligned_lower_new_high &&
            aligned_lower_new_high + lower_needs <= lower_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs, _executable)) {
+    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
diff --git a/src/hotspot/share/prims/whitebox.cpp b/src/hotspot/share/prims/whitebox.cpp
index 8a902494ba0..f765208ca3d 100644
--- a/src/hotspot/share/prims/whitebox.cpp
+++ b/src/hotspot/share/prims/whitebox.cpp
@@ -782,7 +782,7 @@ WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size
 WB_END
 
 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
-  os::uncommit_memory((char *)(uintptr_t)addr, size, !ExecMem);
+  os::uncommit_memory((char *)(uintptr_t)addr, size);
 WB_END
 
 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
diff --git a/src/hotspot/share/runtime/os.cpp b/src/hotspot/share/runtime/os.cpp
index 4cf2a9fc101..243cd8eb342 100644
--- a/src/hotspot/share/runtime/os.cpp
+++ b/src/hotspot/share/runtime/os.cpp
@@ -1652,8 +1652,8 @@ bool os::create_stack_guard_pages(char* addr, size_t bytes) {
   return os::pd_create_stack_guard_pages(addr, bytes);
 }
 
-char* os::reserve_memory(size_t bytes, bool executable, MEMFLAGS flags) {
-  char* result = pd_reserve_memory(bytes, executable);
+char* os::reserve_memory(size_t bytes, MEMFLAGS flags) {
+  char* result = pd_reserve_memory(bytes);
   if (result != NULL) {
     MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC);
     if (flags != mtOther) {
@@ -1701,16 +1701,16 @@ void os::commit_memory_or_exit(char* addr, size_t size, size_t alignment_hint,
   MemTracker::record_virtual_memory_commit((address)addr, size, CALLER_PC);
 }
 
-bool os::uncommit_memory(char* addr, size_t bytes, bool exec) {
+bool os::uncommit_memory(char* addr, size_t bytes) {
   bool res;
   if (MemTracker::tracking_level() > NMT_minimal) {
     Tracker tkr(Tracker::uncommit);
-    res = pd_uncommit_memory(addr, bytes, exec);
+    res = pd_uncommit_memory(addr, bytes);
     if (res) {
       tkr.record((address)addr, bytes);
     }
   } else {
-    res = pd_uncommit_memory(addr, bytes, exec);
+    res = pd_uncommit_memory(addr, bytes);
   }
   return res;
 }
diff --git a/src/hotspot/share/runtime/os.hpp b/src/hotspot/share/runtime/os.hpp
index 0cff690f606..a7f0df698c3 100644
--- a/src/hotspot/share/runtime/os.hpp
+++ b/src/hotspot/share/runtime/os.hpp
@@ -118,7 +118,7 @@ class os: AllStatic {
     _page_sizes[1] = 0; // sentinel
   }
 
-  static char*  pd_reserve_memory(size_t bytes, bool executable);
+  static char*  pd_reserve_memory(size_t bytes);
 
   static char*  pd_attempt_reserve_memory_at(char* addr, size_t bytes);
 
@@ -132,7 +132,7 @@ class os: AllStatic {
   static void   pd_commit_memory_or_exit(char* addr, size_t size,
                                          size_t alignment_hint,
                                          bool executable, const char* mesg);
-  static bool   pd_uncommit_memory(char* addr, size_t bytes, bool exec);
+  static bool   pd_uncommit_memory(char* addr, size_t bytes);
   static bool   pd_release_memory(char* addr, size_t bytes);
 
   static char*  pd_attempt_map_memory_to_file_at(char* addr, size_t bytes, int file_desc);
@@ -319,7 +319,7 @@ class os: AllStatic {
   static int    vm_allocation_granularity();
 
   // Reserves virtual memory.
-  static char*  reserve_memory(size_t bytes, bool executable = false, MEMFLAGS flags = mtOther);
+  static char*  reserve_memory(size_t bytes, MEMFLAGS flags = mtOther);
 
   // Reserves virtual memory that starts at an address that is aligned to 'alignment'.
   static char*  reserve_memory_aligned(size_t size, size_t alignment);
@@ -348,7 +348,7 @@ class os: AllStatic {
   static void   commit_memory_or_exit(char* addr, size_t size,
                                       size_t alignment_hint,
                                       bool executable, const char* mesg);
-  static bool   uncommit_memory(char* addr, size_t bytes, bool exec);
+  static bool   uncommit_memory(char* addr, size_t bytes);
   static bool   release_memory(char* addr, size_t bytes);
 
   // Touch memory pages that cover the memory range from start to end (exclusive)
diff --git a/src/hotspot/share/runtime/stackOverflow.cpp b/src/hotspot/share/runtime/stackOverflow.cpp
index 0b706e71703..01aba3ea2de 100644
--- a/src/hotspot/share/runtime/stackOverflow.cpp
+++ b/src/hotspot/share/runtime/stackOverflow.cpp
@@ -103,7 +103,7 @@ void StackOverflow::create_stack_guard_pages() {
   } else {
     log_warning(os, thread)("Attempt to protect stack guard pages failed ("
       PTR_FORMAT "-" PTR_FORMAT ").", p2i(low_addr), p2i(low_addr + len));
-    if (os::uncommit_memory((char *) low_addr, len, !ExecMem)) {
+    if (os::uncommit_memory((char *) low_addr, len)) {
       log_warning(os, thread)("Attempt to deallocate stack guard pages failed.");
     }
     return;
diff --git a/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp b/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
index 06378fcdc00..d2539b73382 100644
--- a/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
+++ b/test/hotspot/gtest/runtime/test_committed_virtualmemory.cpp
@@ -101,7 +101,7 @@ class CommittedVirtualMemoryTest {
   static void test_committed_region_impl(size_t num_pages, size_t touch_pages, int* page_num) {
     const size_t page_sz = os::vm_page_size();
     const size_t size = num_pages * page_sz;
-    char* base = os::reserve_memory(size, false, mtThreadStack);
+    char* base = os::reserve_memory(size, mtThreadStack);
     bool result = os::commit_memory(base, size, false);
     size_t index;
     ASSERT_NE(base, (char*)NULL);
@@ -169,7 +169,7 @@ class CommittedVirtualMemoryTest {
     const size_t page_sz = os::vm_page_size();
     const size_t num_pages = 4;
     const size_t size = num_pages * page_sz;
-    char* base = os::reserve_memory(size, false, mtTest);
+    char* base = os::reserve_memory(size, mtTest);
     ASSERT_NE(base, (char*)NULL);
     result = os::commit_memory(base, size, false);
 

From 85f76ebd410b1a0a3682e576c401107e389f537b Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Mon, 30 Nov 2020 01:28:15 -0800
Subject: [PATCH 36/94] JDK-8221554: bsd_aarch64 part

---
 src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
index 0039fc89fd7..93e5bc2f9f6 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
@@ -51,6 +51,8 @@ inline void OrderAccess::fence() {
   FULL_MEM_BARRIER;
 }
 
-inline void OrderAccess::cross_modify_fence() { }
+inline void OrderAccess::cross_modify_fence_impl() {
+  asm volatile("isb" : : : "memory");
+}
 
 #endif // OS_CPU_BSD_AARCH64_ORDERACCESS_BSD_AARCH64_HPP

From 7fe50a996b6f436932452d220b351c73153ed945 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 15 Jan 2021 09:38:12 -0800
Subject: [PATCH 37/94] JDK-8257882: bsd_aarch64 part

---
 src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp    | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp | 4 ++++
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
index c003a0469a1..2252bebe8c7 100644
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
@@ -320,7 +320,7 @@ void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
   // Always clear the pc because it could have been set by make_walkable()
   str(zr, Address(rthread, JavaThread::last_Java_pc_offset()));
 
-  str(zr, Address(rthread, JavaThread::saved_fp_address_offset()));
+  str(zr, Address(rthread, JavaFrameAnchor::saved_fp_address_offset()));
 }
 
 // Calls to C land
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
index c10f0da1003..f91fb7dd14b 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
@@ -38,6 +38,10 @@
     return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();
   }
 
+  static ByteSize saved_fp_address_offset() {
+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::saved_fp_address_offset();
+  }
+
   bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,
     bool isInJava);
 

From 80ad49a478a4402469acaea615d5c083faf8e215 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Mon, 30 Nov 2020 01:35:21 -0800
Subject: [PATCH 38/94] JDK-8253742: bsd_aarch64 part

---
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.cpp        | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index b061a747f15..ba305e480dd 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -134,11 +134,11 @@ char* os::non_memory_address_word() {
   return (char*) 0xffffffffffff;
 }
 
-address os::Bsd::ucontext_get_pc(const ucontext_t * uc) {
+address os::Posix::ucontext_get_pc(const ucontext_t * uc) {
   return (address)uc->context_pc;
 }
 
-void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {
+void os::Posix::ucontext_set_pc(ucontext_t * uc, address pc) {
   uc->context_pc = (intptr_t)pc ;
 }
 
@@ -157,7 +157,7 @@ address os::fetch_frame_from_context(const void* ucVoid,
   const ucontext_t* uc = (const ucontext_t*)ucVoid;
 
   if (uc != NULL) {
-    epc = os::Bsd::ucontext_get_pc(uc);
+    epc = os::Posix::ucontext_get_pc(uc);
     if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);
     if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);
   } else {
@@ -226,10 +226,10 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
 
   //%note os_trap_1
   if (info != NULL && uc != NULL && thread != NULL) {
-    pc = (address) os::Bsd::ucontext_get_pc(uc);
+    pc = (address) os::Posix::ucontext_get_pc(uc);
 
     if (StubRoutines::is_safefetch_fault(pc)) {
-      os::Bsd::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
+      os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
       return true;
     }
 
@@ -358,7 +358,7 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
     static __thread address last_addr = (address) -1;
 
     address addr = (address) info->si_addr;
-    address pc = os::Bsd::ucontext_get_pc(uc);
+    address pc = os::Posix::ucontext_get_pc(uc);
 
     if (pc != addr && uc->context_esr == 0x9200004F) { //TODO: figure out what this value means
       // We are faulting trying to write a R-X page
@@ -395,7 +395,7 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
     // save all thread context in case we need to restore it
     if (thread != NULL) thread->set_saved_exception_pc(pc);
 
-    os::Bsd::ucontext_set_pc(uc, stub);
+    os::Posix::ucontext_set_pc(uc, stub);
     return true;
   }
 
@@ -595,7 +595,7 @@ void os::print_context(outputStream *st, const void *context) {
   // Note: it may be unsafe to inspect memory near pc. For example, pc may
   // point to garbage if entry point in an nmethod is corrupted. Leave
   // this at the end, and hope for the best.
-  address pc = os::Bsd::ucontext_get_pc(uc);
+  address pc = os::Posix::ucontext_get_pc(uc);
   print_instructions(st, pc, 4/*native instruction size*/);
   st->cr();
 }

From ec1def6bd0f058b662e980fa2ca18ef636a51623 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Mon, 18 Jan 2021 05:28:44 -0800
Subject: [PATCH 39/94] Use r18_tls instead of r18_reserved

---
 src/hotspot/cpu/aarch64/aarch64.ad                       | 4 ++--
 src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp          | 6 +++---
 src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp       | 2 +-
 src/hotspot/cpu/aarch64/register_aarch64.cpp             | 2 +-
 src/hotspot/cpu/aarch64/register_aarch64.hpp             | 2 +-
 src/hotspot/cpu/aarch64/register_definitions_aarch64.cpp | 2 +-
 6 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/src/hotspot/cpu/aarch64/aarch64.ad b/src/hotspot/cpu/aarch64/aarch64.ad
index 1c759271428..fd556cebd9a 100644
--- a/src/hotspot/cpu/aarch64/aarch64.ad
+++ b/src/hotspot/cpu/aarch64/aarch64.ad
@@ -114,8 +114,8 @@ reg_def R16     ( SOC, SOC, Op_RegI, 16, r16->as_VMReg()        );
 reg_def R16_H   ( SOC, SOC, Op_RegI, 16, r16->as_VMReg()->next());
 reg_def R17     ( SOC, SOC, Op_RegI, 17, r17->as_VMReg()        );
 reg_def R17_H   ( SOC, SOC, Op_RegI, 17, r17->as_VMReg()->next());
-reg_def R18     ( SOC, SOC, Op_RegI, 18, r18_reserved->as_VMReg()        );
-reg_def R18_H   ( SOC, SOC, Op_RegI, 18, r18_reserved->as_VMReg()->next());
+reg_def R18     ( SOC, SOC, Op_RegI, 18, r18_tls->as_VMReg()        );
+reg_def R18_H   ( SOC, SOC, Op_RegI, 18, r18_tls->as_VMReg()->next());
 reg_def R19     ( SOC, SOE, Op_RegI, 19, r19->as_VMReg()        );
 reg_def R19_H   ( SOC, SOE, Op_RegI, 19, r19->as_VMReg()->next());
 reg_def R20     ( SOC, SOE, Op_RegI, 20, r20->as_VMReg()        ); // caller esp
diff --git a/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp b/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp
index 845a3af730c..0da37ae08a6 100644
--- a/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp
@@ -183,7 +183,7 @@ void FrameMap::initialize() {
   map_register(i, r17); r17_opr = LIR_OprFact::single_cpu(i); i++;
 #ifndef R18_RESERVED
   // See comment in register_aarch64.hpp
-  map_register(i, r18_reserved); r18_opr = LIR_OprFact::single_cpu(i); i++;
+  map_register(i, r18_tls); r18_opr = LIR_OprFact::single_cpu(i); i++;
 #endif
   map_register(i, r19); r19_opr = LIR_OprFact::single_cpu(i); i++;
   map_register(i, r20); r20_opr = LIR_OprFact::single_cpu(i); i++;
@@ -204,7 +204,7 @@ void FrameMap::initialize() {
 
 #ifdef R18_RESERVED
   // See comment in register_aarch64.hpp
-  map_register(i, r18_reserved); r18_opr = LIR_OprFact::single_cpu(i); i++;
+  map_register(i, r18_tls); r18_opr = LIR_OprFact::single_cpu(i); i++;
 #endif
 
   rscratch1_opr = r8_opr;
@@ -264,7 +264,7 @@ void FrameMap::initialize() {
   r15_oop_opr = as_oop_opr(r15);
   r16_oop_opr = as_oop_opr(r16);
   r17_oop_opr = as_oop_opr(r17);
-  r18_oop_opr = as_oop_opr(r18_reserved);
+  r18_oop_opr = as_oop_opr(r18_tls);
   r19_oop_opr = as_oop_opr(r19);
   r20_oop_opr = as_oop_opr(r20);
   r21_oop_opr = as_oop_opr(r21);
diff --git a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
index 2252bebe8c7..9242a8a5990 100644
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
@@ -2636,7 +2636,7 @@ void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[])
 RegSet MacroAssembler::call_clobbered_registers() {
   RegSet regs = RegSet::range(r0, r17) - RegSet::of(rscratch1, rscratch2);
 #ifndef R18_RESERVED
-  regs += r18_reserved;
+  regs += r18_tls;
 #endif
   return regs;
 }
diff --git a/src/hotspot/cpu/aarch64/register_aarch64.cpp b/src/hotspot/cpu/aarch64/register_aarch64.cpp
index d24a47f2dbe..24c3f32c2b6 100644
--- a/src/hotspot/cpu/aarch64/register_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/register_aarch64.cpp
@@ -41,7 +41,7 @@ const char* RegisterImpl::name() const {
     "c_rarg0", "c_rarg1", "c_rarg2", "c_rarg3", "c_rarg4", "c_rarg5", "c_rarg6", "c_rarg7",
     "rscratch1", "rscratch2",
     "r10", "r11", "r12", "r13", "r14", "r15", "r16",
-    "r17", "r18_reserved", "r19",
+    "r17", "r18_tls", "r19",
     "resp", "rdispatch", "rbcp", "r23", "rlocals", "rmonitors", "rcpool", "rheapbase",
     "rthread", "rfp", "lr", "sp"
   };
diff --git a/src/hotspot/cpu/aarch64/register_aarch64.hpp b/src/hotspot/cpu/aarch64/register_aarch64.hpp
index 53fa0ec45dc..5a152d62777 100644
--- a/src/hotspot/cpu/aarch64/register_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/register_aarch64.hpp
@@ -99,7 +99,7 @@ CONSTANT_REGISTER_DECLARATION(Register, r17,  (17));
 // It's easier to avoid allocating r18 altogether.
 //
 // See https://docs.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions?view=vs-2019#integer-registers
-CONSTANT_REGISTER_DECLARATION(Register, r18_reserved,  (18));
+CONSTANT_REGISTER_DECLARATION(Register, r18_tls,  (18));
 CONSTANT_REGISTER_DECLARATION(Register, r19,  (19));
 CONSTANT_REGISTER_DECLARATION(Register, r20,  (20));
 CONSTANT_REGISTER_DECLARATION(Register, r21,  (21));
diff --git a/src/hotspot/cpu/aarch64/register_definitions_aarch64.cpp b/src/hotspot/cpu/aarch64/register_definitions_aarch64.cpp
index 482f77e0e4a..f48c70d09e6 100644
--- a/src/hotspot/cpu/aarch64/register_definitions_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/register_definitions_aarch64.cpp
@@ -50,7 +50,7 @@ REGISTER_DEFINITION(Register, r14);
 REGISTER_DEFINITION(Register, r15);
 REGISTER_DEFINITION(Register, r16);
 REGISTER_DEFINITION(Register, r17);
-REGISTER_DEFINITION(Register, r18_reserved); // see comment in register_aarch64.hpp
+REGISTER_DEFINITION(Register, r18_tls); // see comment in register_aarch64.hpp
 REGISTER_DEFINITION(Register, r19);
 REGISTER_DEFINITION(Register, r20);
 REGISTER_DEFINITION(Register, r21);

From c88419ab31f7de2ede9987d6f4c00609f0e12b33 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Mon, 18 Jan 2021 08:25:33 -0800
Subject: [PATCH 40/94] Fix windows_aarch64

---
 src/hotspot/os/windows/os_windows.cpp                     | 2 +-
 src/hotspot/os_cpu/windows_aarch64/os_windows_aarch64.hpp | 6 ++++++
 2 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/src/hotspot/os/windows/os_windows.cpp b/src/hotspot/os/windows/os_windows.cpp
index 9eed244f3f5..df2e0b8fc5a 100644
--- a/src/hotspot/os/windows/os_windows.cpp
+++ b/src/hotspot/os/windows/os_windows.cpp
@@ -62,7 +62,7 @@
 #include "runtime/safepointMechanism.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/statSampler.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadCritical.hpp"
 #include "runtime/timer.hpp"
diff --git a/src/hotspot/os_cpu/windows_aarch64/os_windows_aarch64.hpp b/src/hotspot/os_cpu/windows_aarch64/os_windows_aarch64.hpp
index fedf5848f9e..7088a1797d6 100644
--- a/src/hotspot/os_cpu/windows_aarch64/os_windows_aarch64.hpp
+++ b/src/hotspot/os_cpu/windows_aarch64/os_windows_aarch64.hpp
@@ -33,4 +33,10 @@
     return true;
   }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_HPP

From a71bac70a79ed2cf919f59d0f20add80e7938ff3 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Wed, 20 Jan 2021 12:48:25 +0300
Subject: [PATCH 41/94] Fix gtests in debug

---
 .../hotspot/gtest/metaspace/metaspaceGtestContexts.hpp |  4 +++-
 test/hotspot/gtest/metaspace/test_blocktree.cpp        | 10 ++++++++++
 test/hotspot/gtest/metaspace/test_freeblocks.cpp       |  5 +++++
 test/hotspot/gtest/metaspace/test_metaspace_misc.cpp   |  1 +
 test/hotspot/gtest/runtime/test_safefetch.cpp          |  3 +++
 5 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/test/hotspot/gtest/metaspace/metaspaceGtestContexts.hpp b/test/hotspot/gtest/metaspace/metaspaceGtestContexts.hpp
index 7d2f0074fcc..976bd1014ee 100644
--- a/test/hotspot/gtest/metaspace/metaspaceGtestContexts.hpp
+++ b/test/hotspot/gtest/metaspace/metaspaceGtestContexts.hpp
@@ -37,9 +37,11 @@ using metaspace::chunklevel_t;
 using namespace metaspace::chunklevel;
 
 class MetaspaceGtestContext : public metaspace::MetaspaceTestContext {
+  Thread::WXWriteFromExecSetter _wx_write;
 public:
   MetaspaceGtestContext(size_t commit_limit = 0, size_t reserve_limit = 0) :
-    metaspace::MetaspaceTestContext("gtest-metaspace-context", commit_limit, reserve_limit)
+    metaspace::MetaspaceTestContext("gtest-metaspace-context", commit_limit, reserve_limit),
+    _wx_write()
   {}
 };
 
diff --git a/test/hotspot/gtest/metaspace/test_blocktree.cpp b/test/hotspot/gtest/metaspace/test_blocktree.cpp
index e149e9777fe..4c87e92e5d6 100644
--- a/test/hotspot/gtest/metaspace/test_blocktree.cpp
+++ b/test/hotspot/gtest/metaspace/test_blocktree.cpp
@@ -54,6 +54,7 @@ static void create_nodes(const size_t sizes[], FeederBuffer& fb, BlockTree& bt)
 }
 
 TEST_VM(metaspace, BlockTree_basic) {
+  Thread::WXWriteFromExecSetter wx_write;
 
   BlockTree bt;
   CHECK_BT_CONTENT(bt, 0, 0);
@@ -155,6 +156,8 @@ TEST_VM(metaspace, BlockTree_find_nearest_fit) {
     0 // stop
   };
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   BlockTree bt;
   FeederBuffer fb(4 * K);
 
@@ -170,6 +173,8 @@ TEST_VM(metaspace, BlockTree_find_nearest_fit) {
 // should exercise the list-part of the tree.
 TEST_VM(metaspace, BlockTree_basic_siblings)
 {
+  Thread::WXWriteFromExecSetter wx_write;
+
   BlockTree bt;
   FeederBuffer fb(4 * K);
 
@@ -204,6 +209,8 @@ TEST_VM(metaspace, BlockTree_print_test) {
     0 // stop
   };
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   BlockTree bt;
   FeederBuffer fb(4 * K);
 
@@ -222,6 +229,8 @@ TEST_VM_ASSERT_MSG(metaspace, BlockTree_overwriter_test, ".*failed: Invalid node
   static const size_t sizes1[] = { 30, 17, 0 };
   static const size_t sizes2[] = { 12, 12, 0 };
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   BlockTree bt;
   FeederBuffer fb(4 * K);
 
@@ -419,6 +428,7 @@ class BlockTreeTest {
 
 #define DO_TEST(name, feedingpattern, min, max) \
   TEST_VM(metaspace, BlockTree_##name##_##feedingpattern) { \
+    Thread::WXWriteFromExecSetter wx_write; \
     BlockTreeTest btt(min, max); \
     btt.test_##feedingpattern(); \
   }
diff --git a/test/hotspot/gtest/metaspace/test_freeblocks.cpp b/test/hotspot/gtest/metaspace/test_freeblocks.cpp
index e51759dc1aa..b1960caeb62 100644
--- a/test/hotspot/gtest/metaspace/test_freeblocks.cpp
+++ b/test/hotspot/gtest/metaspace/test_freeblocks.cpp
@@ -201,6 +201,8 @@ class FreeBlocksTest {
 
 TEST_VM(metaspace, freeblocks_basics) {
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   FreeBlocks fbl;
   MetaWord tmp[1024];
   CHECK_CONTENT(fbl, 0, 0);
@@ -218,14 +220,17 @@ TEST_VM(metaspace, freeblocks_basics) {
 }
 
 TEST_VM(metaspace, freeblocks_small) {
+  Thread::WXWriteFromExecSetter wx_write;
   FreeBlocksTest::test_small_allocations();
 }
 
 TEST_VM(metaspace, freeblocks_medium) {
+  Thread::WXWriteFromExecSetter wx_write;
   FreeBlocksTest::test_medium_allocations();
 }
 
 TEST_VM(metaspace, freeblocks_large) {
+  Thread::WXWriteFromExecSetter wx_write;
   FreeBlocksTest::test_large_allocations();
 }
 
diff --git a/test/hotspot/gtest/metaspace/test_metaspace_misc.cpp b/test/hotspot/gtest/metaspace/test_metaspace_misc.cpp
index e749c84c88e..ed2924b99b0 100644
--- a/test/hotspot/gtest/metaspace/test_metaspace_misc.cpp
+++ b/test/hotspot/gtest/metaspace/test_metaspace_misc.cpp
@@ -54,6 +54,7 @@ TEST_VM(metaspace, misc_sizes)   {
 }
 
 TEST_VM(metaspace, misc_max_alloc_size)   {
+  Thread::WXWriteFromExecSetter wx_write;
 
   // Make sure we can allocate what we promise to allocate
   const size_t sz = Metaspace::max_allocation_word_size();
diff --git a/test/hotspot/gtest/runtime/test_safefetch.cpp b/test/hotspot/gtest/runtime/test_safefetch.cpp
index 14e79a3160e..01673e6b3f8 100644
--- a/test/hotspot/gtest/runtime/test_safefetch.cpp
+++ b/test/hotspot/gtest/runtime/test_safefetch.cpp
@@ -41,12 +41,14 @@ TEST_VM(os, safefetch_can_use) {
 }
 
 TEST_VM(os, safefetch_positive) {
+  Thread::WXWriteFromExecSetter wx_write;
   intptr_t v = pattern;
   intptr_t a = SafeFetchN(&v, 1);
   ASSERT_EQ(v, a);
 }
 
 TEST_VM(os, safefetch_negative) {
+  Thread::WXWriteFromExecSetter wx_write;
   intptr_t a = SafeFetchN(invalid_address, pattern);
   ASSERT_EQ(pattern, a);
   a = SafeFetchN(invalid_address, ~pattern);
@@ -67,6 +69,7 @@ class VM_TestSafeFetchAtSafePoint : public VM_GTestExecuteAtSafepoint {
 
 TEST_VM(os, safefetch_negative_at_safepoint) {
   VM_TestSafeFetchAtSafePoint op;
+  Thread::WXWriteFromExecSetter wx_write;
   ThreadInVMfromNative invm(JavaThread::current());
   VMThread::execute(&op);
 }

From 943b93fb09043c1d3f543e6817b84344dce35324 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Wed, 20 Jan 2021 17:12:46 +0300
Subject: [PATCH 42/94] Revert gtest changes

---
 test/hotspot/gtest/code/test_vtableStub.cpp   |  2 -
 .../gtest/gc/shared/test_oopStorage.cpp       | 40 ++++---------------
 .../gc/shared/test_oopStorage_parperf.cpp     |  2 -
 .../metaspace/metaspaceGtestContexts.hpp      |  4 +-
 .../gtest/metaspace/test_blocktree.cpp        | 10 -----
 .../gtest/metaspace/test_freeblocks.cpp       |  5 ---
 .../gtest/metaspace/test_metaspace_misc.cpp   |  1 -
 test/hotspot/gtest/runtime/test_os.cpp        |  4 --
 test/hotspot/gtest/runtime/test_safefetch.cpp |  5 +--
 9 files changed, 10 insertions(+), 63 deletions(-)

diff --git a/test/hotspot/gtest/code/test_vtableStub.cpp b/test/hotspot/gtest/code/test_vtableStub.cpp
index 9dae675f35f..5242ad643bd 100644
--- a/test/hotspot/gtest/code/test_vtableStub.cpp
+++ b/test/hotspot/gtest/code/test_vtableStub.cpp
@@ -30,7 +30,6 @@
 TEST_VM(code, vtableStubs) {
   // Should be in VM to use locks
   ThreadInVMfromNative ThreadInVMfromNative(JavaThread::current());
-  Thread::WXWriteFromExecSetter wx_exec;
 
   VtableStubs::find_vtable_stub(0); // min vtable index
   for (int i = 0; i < 15; i++) {
@@ -43,7 +42,6 @@ TEST_VM(code, vtableStubs) {
 TEST_VM(code, itableStubs) {
   // Should be in VM to use locks
   ThreadInVMfromNative ThreadInVMfromNative(JavaThread::current());
-  Thread::WXWriteFromExecSetter wx_exec;
 
   VtableStubs::find_itable_stub(0); // min itable index
   for (int i = 0; i < 15; i++) {
diff --git a/test/hotspot/gtest/gc/shared/test_oopStorage.cpp b/test/hotspot/gtest/gc/shared/test_oopStorage.cpp
index 39e92a4f3cb..5fdea55980b 100644
--- a/test/hotspot/gtest/gc/shared/test_oopStorage.cpp
+++ b/test/hotspot/gtest/gc/shared/test_oopStorage.cpp
@@ -147,9 +147,6 @@ static bool process_deferred_updates(OopStorage& storage) {
 }
 
 static void release_entry(OopStorage& storage, oop* entry, bool process_deferred = true) {
-  // missing transition to vm state
-  Thread::WXWriteFromExecSetter wx_write;
-
   *entry = NULL;
   storage.release(entry);
   if (process_deferred) {
@@ -472,17 +469,11 @@ class OopStorageTestBlockRelease : public OopStorageTestWithAllocation {
       QuickSort::sort(to_release, nrelease, PointerCompare(), false);
     }
 
-    {
-      // missing transition to vm state
-      Thread::WXWriteFromExecSetter wx_write;
-      _storage.release(to_release, nrelease);
-      EXPECT_EQ(_max_entries - nrelease, _storage.allocation_count());
-    }
+    _storage.release(to_release, nrelease);
+    EXPECT_EQ(_max_entries - nrelease, _storage.allocation_count());
 
     for (size_t i = 0; i < nrelease; ++i) {
       release_entry(_storage, _entries[2 * i + 1], false);
-      // missing transition to vm state
-      Thread::WXWriteFromExecSetter wx_write;
       EXPECT_EQ(_max_entries - nrelease - (i + 1), _storage.allocation_count());
     }
     EXPECT_TRUE(process_deferred_updates(_storage));
@@ -510,8 +501,6 @@ TEST_VM_F(OopStorageTest, invalid_pointer) {
   {
     char* mem = NEW_C_HEAP_ARRAY(char, 1000, mtInternal);
     oop* ptr = reinterpret_cast<oop*>(align_down(mem + 250, sizeof(oop)));
-    // missing transition to vm state
-    Thread::WXWriteFromExecSetter wx_write;
     // Predicate returns false for some malloc'ed block.
     EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(ptr));
     FREE_C_HEAP_ARRAY(char, mem);
@@ -520,8 +509,6 @@ TEST_VM_F(OopStorageTest, invalid_pointer) {
   {
     oop obj;
     oop* ptr = &obj;
-    // missing transition to vm state
-    Thread::WXWriteFromExecSetter wx_write;
     // Predicate returns false for some "random" location.
     EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(ptr));
   }
@@ -1040,16 +1027,11 @@ TEST_VM_F(OopStorageTestWithAllocation, allocation_status) {
   oop* garbage = reinterpret_cast<oop*>(1024 * 1024);
   release_entry(_storage, released);
 
-  {
-    // missing transition to vm state
-    Thread::WXWriteFromExecSetter wx_write;
-
-    EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));
-    EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, _storage.allocation_status(released));
+  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));
+  EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, _storage.allocation_status(released));
 #ifndef DISABLE_GARBAGE_ALLOCATION_STATUS_TESTS
-    EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));
+  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));
 #endif
-  }
 
   for (size_t i = 0; i < _max_entries; ++i) {
     if ((_entries[i] != retained) && (_entries[i] != released)) {
@@ -1060,19 +1042,13 @@ TEST_VM_F(OopStorageTestWithAllocation, allocation_status) {
 
   {
     ThreadInVMfromNative invm(JavaThread::current());
-    Thread::WXWriteFromExecSetter wx_write;
     while (_storage.delete_empty_blocks()) {}
   }
-
-  {
-    // missing transition to vm state
-    Thread::WXWriteFromExecSetter wx_write;
-    EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));
+  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));
 #ifndef DISABLE_GARBAGE_ALLOCATION_STATUS_TESTS
-    EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(released));
-    EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));
+  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(released));
+  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));
 #endif // DISABLE_GARBAGE_ALLOCATION_STATUS_TESTS
-  }
 }
 
 TEST_VM_F(OopStorageTest, usage_info) {
diff --git a/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp b/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
index b55822fb26a..dea8fe7903a 100644
--- a/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
+++ b/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
@@ -96,8 +96,6 @@ OopStorageParIterPerf::OopStorageParIterPerf() :
 }
 
 OopStorageParIterPerf::~OopStorageParIterPerf() {
-  // missing transition to vm state
-  Thread::WXWriteFromExecSetter wx_write;
   _storage.release(_entries, ARRAY_SIZE(_entries));
 }
 
diff --git a/test/hotspot/gtest/metaspace/metaspaceGtestContexts.hpp b/test/hotspot/gtest/metaspace/metaspaceGtestContexts.hpp
index 976bd1014ee..7d2f0074fcc 100644
--- a/test/hotspot/gtest/metaspace/metaspaceGtestContexts.hpp
+++ b/test/hotspot/gtest/metaspace/metaspaceGtestContexts.hpp
@@ -37,11 +37,9 @@ using metaspace::chunklevel_t;
 using namespace metaspace::chunklevel;
 
 class MetaspaceGtestContext : public metaspace::MetaspaceTestContext {
-  Thread::WXWriteFromExecSetter _wx_write;
 public:
   MetaspaceGtestContext(size_t commit_limit = 0, size_t reserve_limit = 0) :
-    metaspace::MetaspaceTestContext("gtest-metaspace-context", commit_limit, reserve_limit),
-    _wx_write()
+    metaspace::MetaspaceTestContext("gtest-metaspace-context", commit_limit, reserve_limit)
   {}
 };
 
diff --git a/test/hotspot/gtest/metaspace/test_blocktree.cpp b/test/hotspot/gtest/metaspace/test_blocktree.cpp
index 4c87e92e5d6..e149e9777fe 100644
--- a/test/hotspot/gtest/metaspace/test_blocktree.cpp
+++ b/test/hotspot/gtest/metaspace/test_blocktree.cpp
@@ -54,7 +54,6 @@ static void create_nodes(const size_t sizes[], FeederBuffer& fb, BlockTree& bt)
 }
 
 TEST_VM(metaspace, BlockTree_basic) {
-  Thread::WXWriteFromExecSetter wx_write;
 
   BlockTree bt;
   CHECK_BT_CONTENT(bt, 0, 0);
@@ -156,8 +155,6 @@ TEST_VM(metaspace, BlockTree_find_nearest_fit) {
     0 // stop
   };
 
-  Thread::WXWriteFromExecSetter wx_write;
-
   BlockTree bt;
   FeederBuffer fb(4 * K);
 
@@ -173,8 +170,6 @@ TEST_VM(metaspace, BlockTree_find_nearest_fit) {
 // should exercise the list-part of the tree.
 TEST_VM(metaspace, BlockTree_basic_siblings)
 {
-  Thread::WXWriteFromExecSetter wx_write;
-
   BlockTree bt;
   FeederBuffer fb(4 * K);
 
@@ -209,8 +204,6 @@ TEST_VM(metaspace, BlockTree_print_test) {
     0 // stop
   };
 
-  Thread::WXWriteFromExecSetter wx_write;
-
   BlockTree bt;
   FeederBuffer fb(4 * K);
 
@@ -229,8 +222,6 @@ TEST_VM_ASSERT_MSG(metaspace, BlockTree_overwriter_test, ".*failed: Invalid node
   static const size_t sizes1[] = { 30, 17, 0 };
   static const size_t sizes2[] = { 12, 12, 0 };
 
-  Thread::WXWriteFromExecSetter wx_write;
-
   BlockTree bt;
   FeederBuffer fb(4 * K);
 
@@ -428,7 +419,6 @@ class BlockTreeTest {
 
 #define DO_TEST(name, feedingpattern, min, max) \
   TEST_VM(metaspace, BlockTree_##name##_##feedingpattern) { \
-    Thread::WXWriteFromExecSetter wx_write; \
     BlockTreeTest btt(min, max); \
     btt.test_##feedingpattern(); \
   }
diff --git a/test/hotspot/gtest/metaspace/test_freeblocks.cpp b/test/hotspot/gtest/metaspace/test_freeblocks.cpp
index b1960caeb62..e51759dc1aa 100644
--- a/test/hotspot/gtest/metaspace/test_freeblocks.cpp
+++ b/test/hotspot/gtest/metaspace/test_freeblocks.cpp
@@ -201,8 +201,6 @@ class FreeBlocksTest {
 
 TEST_VM(metaspace, freeblocks_basics) {
 
-  Thread::WXWriteFromExecSetter wx_write;
-
   FreeBlocks fbl;
   MetaWord tmp[1024];
   CHECK_CONTENT(fbl, 0, 0);
@@ -220,17 +218,14 @@ TEST_VM(metaspace, freeblocks_basics) {
 }
 
 TEST_VM(metaspace, freeblocks_small) {
-  Thread::WXWriteFromExecSetter wx_write;
   FreeBlocksTest::test_small_allocations();
 }
 
 TEST_VM(metaspace, freeblocks_medium) {
-  Thread::WXWriteFromExecSetter wx_write;
   FreeBlocksTest::test_medium_allocations();
 }
 
 TEST_VM(metaspace, freeblocks_large) {
-  Thread::WXWriteFromExecSetter wx_write;
   FreeBlocksTest::test_large_allocations();
 }
 
diff --git a/test/hotspot/gtest/metaspace/test_metaspace_misc.cpp b/test/hotspot/gtest/metaspace/test_metaspace_misc.cpp
index ed2924b99b0..e749c84c88e 100644
--- a/test/hotspot/gtest/metaspace/test_metaspace_misc.cpp
+++ b/test/hotspot/gtest/metaspace/test_metaspace_misc.cpp
@@ -54,7 +54,6 @@ TEST_VM(metaspace, misc_sizes)   {
 }
 
 TEST_VM(metaspace, misc_max_alloc_size)   {
-  Thread::WXWriteFromExecSetter wx_write;
 
   // Make sure we can allocate what we promise to allocate
   const size_t sz = Metaspace::max_allocation_word_size();
diff --git a/test/hotspot/gtest/runtime/test_os.cpp b/test/hotspot/gtest/runtime/test_os.cpp
index a21bc9e948d..8ae768bcb95 100644
--- a/test/hotspot/gtest/runtime/test_os.cpp
+++ b/test/hotspot/gtest/runtime/test_os.cpp
@@ -162,10 +162,6 @@ static void do_test_print_hex_dump(address addr, size_t len, int unitsize, const
   char buf[256];
   buf[0] = '\0';
   stringStream ss(buf, sizeof(buf));
-
-  // missing transition to vm state
-  Thread::WXWriteFromExecSetter wx_write;
-
   os::print_hex_dump(&ss, addr, addr + len, unitsize);
 //  tty->print_cr("expected: %s", expected);
 //  tty->print_cr("result: %s", buf);
diff --git a/test/hotspot/gtest/runtime/test_safefetch.cpp b/test/hotspot/gtest/runtime/test_safefetch.cpp
index 01673e6b3f8..25d5fb092ec 100644
--- a/test/hotspot/gtest/runtime/test_safefetch.cpp
+++ b/test/hotspot/gtest/runtime/test_safefetch.cpp
@@ -24,7 +24,7 @@
 
 #include "precompiled.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
-#include "runtime/stubRoutines.inline.hpp"
+#include "runtime/stubRoutines.hpp"
 #include "runtime/vmOperations.hpp"
 #include "runtime/vmThread.hpp"
 #include "utilities/globalDefinitions.hpp"
@@ -41,14 +41,12 @@ TEST_VM(os, safefetch_can_use) {
 }
 
 TEST_VM(os, safefetch_positive) {
-  Thread::WXWriteFromExecSetter wx_write;
   intptr_t v = pattern;
   intptr_t a = SafeFetchN(&v, 1);
   ASSERT_EQ(v, a);
 }
 
 TEST_VM(os, safefetch_negative) {
-  Thread::WXWriteFromExecSetter wx_write;
   intptr_t a = SafeFetchN(invalid_address, pattern);
   ASSERT_EQ(pattern, a);
   a = SafeFetchN(invalid_address, ~pattern);
@@ -69,7 +67,6 @@ class VM_TestSafeFetchAtSafePoint : public VM_GTestExecuteAtSafepoint {
 
 TEST_VM(os, safefetch_negative_at_safepoint) {
   VM_TestSafeFetchAtSafePoint op;
-  Thread::WXWriteFromExecSetter wx_write;
   ThreadInVMfromNative invm(JavaThread::current());
   VMThread::execute(&op);
 }

From f0f62dad6aebdae90608407adcfd44f5f3420ad8 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Thu, 21 Jan 2021 08:47:43 +0300
Subject: [PATCH 43/94] Rework gtests to always have wx_write

---
 src/hotspot/share/logging/logStream.hpp       |  3 +-
 .../gc/shared/test_oopStorage_parperf.cpp     |  2 +
 test/hotspot/gtest/logging/test_logStream.cpp | 12 ++++--
 test/hotspot/gtest/runtime/test_safefetch.cpp |  2 +-
 test/hotspot/gtest/unittest.hpp               | 38 +++++++++++++++++--
 5 files changed, 48 insertions(+), 9 deletions(-)

diff --git a/src/hotspot/share/logging/logStream.hpp b/src/hotspot/share/logging/logStream.hpp
index b141be65a6a..9c7535ac52b 100644
--- a/src/hotspot/share/logging/logStream.hpp
+++ b/src/hotspot/share/logging/logStream.hpp
@@ -32,8 +32,7 @@
 
 class LogStream : public outputStream {
   // see test/hotspot/gtest/logging/test_logStream.cpp
-  friend class LogStreamTest_TestLineBufferAllocation_vm_Test;
-  friend class LogStreamTest_TestLineBufferAllocationCap_vm_Test;
+  friend class LogStreamTest;
 
   // Helper class, maintains the line buffer. For small line lengths,
   // we avoid malloc and use a fixed sized member char array. If LogStream
diff --git a/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp b/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
index dea8fe7903a..b55822fb26a 100644
--- a/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
+++ b/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
@@ -96,6 +96,8 @@ OopStorageParIterPerf::OopStorageParIterPerf() :
 }
 
 OopStorageParIterPerf::~OopStorageParIterPerf() {
+  // missing transition to vm state
+  Thread::WXWriteFromExecSetter wx_write;
   _storage.release(_entries, ARRAY_SIZE(_entries));
 }
 
diff --git a/test/hotspot/gtest/logging/test_logStream.cpp b/test/hotspot/gtest/logging/test_logStream.cpp
index e6628dc121d..fabe1d6953c 100644
--- a/test/hotspot/gtest/logging/test_logStream.cpp
+++ b/test/hotspot/gtest/logging/test_logStream.cpp
@@ -31,6 +31,12 @@
 class LogStreamTest : public LogTestFixture {
  protected:
   void verify_stream(outputStream* stream);
+  const char* current_line_buffer(LogStream& ls) {
+    return ls._current_line.buffer();
+  }
+  void current_line_reset(LogStream& ls) {
+    ls._current_line.reset();
+  }
 };
 
 void LogStreamTest::verify_stream(outputStream* stream) {
@@ -80,7 +86,7 @@ TEST_VM_F(LogStreamTest, TestLineBufferAllocation) {
       const int to_write = MIN2(interval, max_line_len - written);
       ls.write(test_string, interval);
       written += interval;
-      const char* const line_buffer = ls._current_line.buffer();
+      const char* const line_buffer = current_line_buffer(ls);
       for (int i = 0; i < written; i++) {
         ASSERT_TRUE(line_buffer[i] == 'A');
       }
@@ -96,10 +102,10 @@ TEST_VM_F(LogStreamTest, TestLineBufferAllocationCap) {
   for (size_t i = 0; i < (1*M + 512); i ++) {
     ls.print_raw("A");
   }
-  const char* const line_buffer = ls._current_line.buffer();
+  const char* const line_buffer = current_line_buffer(ls);
   ASSERT_TRUE(strlen(line_buffer) == 1*M - 1);
   // reset to prevent assert for unflushed content
-  ls._current_line.reset();
+  current_line_reset(ls);
 }
 
 TEST_VM_F(LogStreamTest, autoflush_on_destruction) {
diff --git a/test/hotspot/gtest/runtime/test_safefetch.cpp b/test/hotspot/gtest/runtime/test_safefetch.cpp
index 25d5fb092ec..14e79a3160e 100644
--- a/test/hotspot/gtest/runtime/test_safefetch.cpp
+++ b/test/hotspot/gtest/runtime/test_safefetch.cpp
@@ -24,7 +24,7 @@
 
 #include "precompiled.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/vmOperations.hpp"
 #include "runtime/vmThread.hpp"
 #include "utilities/globalDefinitions.hpp"
diff --git a/test/hotspot/gtest/unittest.hpp b/test/hotspot/gtest/unittest.hpp
index 140d14d25f2..9bf7debba9e 100644
--- a/test/hotspot/gtest/unittest.hpp
+++ b/test/hotspot/gtest/unittest.hpp
@@ -76,16 +76,46 @@
 
 #define TEST(category, name) GTEST_TEST(category, name)
 
-#define TEST_VM(category, name) GTEST_TEST(category, CONCAT(name, _vm))
+#define TEST_VM(category, name)                                     \
+  class category ## _  ## name ## _vm : public ::testing::Test {    \
+  public:                                                           \
+    static void do_test();                                          \
+  };                                                                \
+                                                                    \
+  GTEST_TEST(category, CONCAT(name, _vm)) {                         \
+    Thread::WXWriteFromExecSetter wx_write;                         \
+    category ## _ ## name ## _vm::do_test();                        \
+  }                                                                 \
+                                                                    \
+  void category ## _ ## name ## _vm::do_test()
 
 #define TEST_VM_F(test_fixture, name)                               \
-  GTEST_TEST_(test_fixture, name ## _vm, test_fixture,              \
-              ::testing::internal::GetTypeId<test_fixture>())
+  class test_fixture ## _  ## name ## _vm_f : public test_fixture { \
+  public:                                                           \
+    void SetUp() {                                                  \
+      Thread::WXWriteFromExecSetter wx_write;                       \
+      test_fixture::SetUp();                                        \
+    }                                                               \
+  protected:                                                        \
+    void do_test();                                                 \
+  };                                                                \
+                                                                    \
+  GTEST_TEST_(test_fixture ## _ ## name,                            \
+      name ## _vm,                                                  \
+      test_fixture ## _ ## name ## _vm_f,                           \
+      ::testing::internal::GetTypeId<                               \
+        test_fixture ## _ ## name ## _vm_f>()) {                    \
+    Thread::WXWriteFromExecSetter wx_write;                         \
+    do_test();                                                      \
+  }                                                                 \
+                                                                    \
+  void test_fixture ## _ ## name ## _vm_f::do_test()
 
 #define TEST_OTHER_VM(category, name)                               \
   static void test_  ## category ## _ ## name ## _();               \
                                                                     \
   static void child_ ## category ## _ ## name ## _() {              \
+    Thread::WXWriteFromExecSetter wx_write;                         \
     ::testing::GTEST_FLAG(throw_on_failure) = true;                 \
     test_ ## category ## _ ## name ## _();                          \
     fprintf(stderr, "OKIDOKI");                                     \
@@ -105,6 +135,7 @@
   static void test_  ## category ## _ ## name ## _();               \
                                                                     \
   static void child_ ## category ## _ ## name ## _() {              \
+    Thread::WXWriteFromExecSetter wx_write;                         \
     ::testing::GTEST_FLAG(throw_on_failure) = true;                 \
     test_ ## category ## _ ## name ## _();                          \
     exit(0);                                                        \
@@ -127,6 +158,7 @@
   static void test_  ## category ## _ ## name ## _();               \
                                                                     \
   static void child_ ## category ## _ ## name ## _() {              \
+    Thread::WXWriteFromExecSetter wx_write;                         \
     ::testing::GTEST_FLAG(throw_on_failure) = true;                 \
     test_ ## category ## _ ## name ## _();                          \
     exit(0);                                                        \

From ecbf70fcf422370c5cb84dd64ee89b23cffd8eb5 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Thu, 21 Jan 2021 15:14:59 +0300
Subject: [PATCH 44/94] JDK-8253816: Update after recent changes

---
 src/hotspot/share/prims/nativeEntryPoint.cpp       | 3 ++-
 src/hotspot/share/prims/universalNativeInvoker.cpp | 1 +
 src/hotspot/share/prims/vectorSupport.cpp          | 1 +
 3 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/hotspot/share/prims/nativeEntryPoint.cpp b/src/hotspot/share/prims/nativeEntryPoint.cpp
index 2ec76da7290..bf4dfe40e6a 100644
--- a/src/hotspot/share/prims/nativeEntryPoint.cpp
+++ b/src/hotspot/share/prims/nativeEntryPoint.cpp
@@ -38,7 +38,8 @@ static JNINativeMethod NEP_methods[] = {
 };
 
 JNI_LEAF(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class))
+  Thread::WXExecFromWriteSetter wx_exec;
   int status = env->RegisterNatives(NEP_class, NEP_methods, sizeof(NEP_methods)/sizeof(JNINativeMethod));
   guarantee(status == JNI_OK && !env->ExceptionOccurred(),
             "register jdk.internal.invoke.NativeEntryPoint natives");
-JNI_END
\ No newline at end of file
+JNI_END
diff --git a/src/hotspot/share/prims/universalNativeInvoker.cpp b/src/hotspot/share/prims/universalNativeInvoker.cpp
index bb1bbcd4eca..09c44dcfe64 100644
--- a/src/hotspot/share/prims/universalNativeInvoker.cpp
+++ b/src/hotspot/share/prims/universalNativeInvoker.cpp
@@ -56,6 +56,7 @@ static JNINativeMethod PI_methods[] = {
 };
 
 JNI_LEAF(void, JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass PI_class))
+  Thread::WXWriteFromExecSetter wx_write;
   int status = env->RegisterNatives(PI_class, PI_methods, sizeof(PI_methods)/sizeof(JNINativeMethod));
   guarantee(status == JNI_OK && !env->ExceptionOccurred(),
             "register jdk.internal.foreign.abi.programmable.ProgrammableInvoker natives");
diff --git a/src/hotspot/share/prims/vectorSupport.cpp b/src/hotspot/share/prims/vectorSupport.cpp
index be3bb27177e..505df9251d2 100644
--- a/src/hotspot/share/prims/vectorSupport.cpp
+++ b/src/hotspot/share/prims/vectorSupport.cpp
@@ -393,6 +393,7 @@ static JNINativeMethod jdk_internal_vm_vector_VectorSupport_methods[] = {
 
 JVM_ENTRY(void, JVM_RegisterVectorSupportMethods(JNIEnv* env, jclass vsclass)) {
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
 
   int ok = env->RegisterNatives(vsclass, jdk_internal_vm_vector_VectorSupport_methods, sizeof(jdk_internal_vm_vector_VectorSupport_methods)/sizeof(JNINativeMethod));
   guarantee(ok == 0, "register jdk.internal.vm.vector.VectorSupport natives");

From 3d4f4c2399f0a14dd9fc51f55fac1220cb898009 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Thu, 21 Jan 2021 01:55:19 -0800
Subject: [PATCH 45/94] Fix build

---
 src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp | 1 +
 test/hotspot/gtest/unittest.hpp                    | 3 +++
 2 files changed, 4 insertions(+)

diff --git a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp
index 4ffc97bb377..4697832dcd7 100644
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp
@@ -28,6 +28,7 @@
 
 #include "asm/assembler.inline.hpp"
 #include "oops/compressedOops.hpp"
+#include "runtime/vm_version.hpp"
 #include "utilities/powerOfTwo.hpp"
 
 // MacroAssembler extends Assembler by frequently used macros.
diff --git a/test/hotspot/gtest/unittest.hpp b/test/hotspot/gtest/unittest.hpp
index 9bf7debba9e..9ddb633eeb3 100644
--- a/test/hotspot/gtest/unittest.hpp
+++ b/test/hotspot/gtest/unittest.hpp
@@ -27,6 +27,9 @@
 #include <stdlib.h>
 #include <stdio.h>
 
+// For Thread definition
+#include "runtime/thread.hpp"
+
 #define GTEST_DONT_DEFINE_TEST 1
 
 // googlemock has ::testing::internal::Log function, so we need to temporary

From b90c13b7b35623e45cd5b512876c3fc8d8a035e8 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Sat, 23 Jan 2021 07:48:09 -0800
Subject: [PATCH 46/94] Enable -Wformat-nonliteral back

---
 make/autoconf/flags-cflags.m4 | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/make/autoconf/flags-cflags.m4 b/make/autoconf/flags-cflags.m4
index c476ef44616..2cddaad65c6 100644
--- a/make/autoconf/flags-cflags.m4
+++ b/make/autoconf/flags-cflags.m4
@@ -166,7 +166,7 @@ AC_DEFUN([FLAGS_SETUP_WARNINGS],
           -Wunused-function -Wundef -Wunused-value -Woverloaded-virtual"
       WARNINGS_ENABLE_ALL="-Wall -Wextra -Wformat=2 $WARNINGS_ENABLE_ADDITIONAL"
 
-      DISABLED_WARNINGS="unknown-warning-option unused-parameter unused format-nonliteral"
+      DISABLED_WARNINGS="unknown-warning-option unused-parameter unused"
 
       if test "x$OPENJDK_TARGET_OS" = xmacosx; then
         # missing-method-return-type triggers in JavaNativeFoundation framework

From 50b55f6684cd21f8b532fa979b7b6fbb4613266d Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Sat, 23 Jan 2021 19:51:07 +0300
Subject: [PATCH 47/94] Address feedback for signature generators

---
 .../cpu/aarch64/interpreterRT_aarch64.cpp     | 248 +++++-------------
 1 file changed, 65 insertions(+), 183 deletions(-)

diff --git a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
index 8318393bcb8..93edf13182a 100644
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
@@ -39,21 +39,24 @@
 #define __ _masm->
 
 //describe amount of space in bytes occupied by type on native stack
+class NativeStack : public AllStatic {
+public:
 #ifdef __APPLE__
-    const int nativeByteSpace        = sizeof(jbyte);
-    const int nativeShortSpace       = sizeof(jshort);
-    const int nativeIntSpace         = sizeof(jint);
-    const int nativeLongSpace        = wordSize;
-    const int nativeFloatSpace       = nativeIntSpace;
-    const int nativeDoubleSpace      = nativeLongSpace;
+  static const int byteSpace        = sizeof(jbyte);
+  static const int shortSpace       = sizeof(jshort);
+  static const int intSpace         = sizeof(jint);
+  static const int longSpace        = wordSize;
+  static const int floatSpace       = intSpace;
+  static const int doubleSpace      = longSpace;
 #else
-    const int nativeByteSpace        = wordSize;
-    const int nativeShortSpace       = wordSize;
-    const int nativeIntSpace         = wordSize;
-    const int nativeLongSpace        = wordSize;
-    const int nativeFloatSpace       = nativeIntSpace;
-    const int nativeDoubleSpace      = nativeLongSpace;
+  static const int byteSpace        = wordSize;
+  static const int shortSpace       = wordSize;
+  static const int intSpace         = wordSize;
+  static const int longSpace        = wordSize;
+  static const int floatSpace       = intSpace;
+  static const int doubleSpace      = longSpace;
 #endif
+};
 
 template <typename T>
 static inline void store_and_inc(char* &to, T value, int inc_size) {
@@ -82,198 +85,88 @@ InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 void InterpreterRuntime::SignatureHandlerGenerator::pass_byte() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
-  switch (_num_int_args) {
-  case 0:
-    __ ldr(c_rarg1, src);
-    _num_int_args++;
-    break;
-  case 1:
-    __ ldr(c_rarg2, src);
-    _num_int_args++;
-    break;
-  case 2:
-    __ ldr(c_rarg3, src);
-    _num_int_args++;
-    break;
-  case 3:
-    __ ldr(c_rarg4, src);
-    _num_int_args++;
-    break;
-  case 4:
-    __ ldr(c_rarg5, src);
-    _num_int_args++;
-    break;
-  case 5:
-    __ ldr(c_rarg6, src);
-    _num_int_args++;
-    break;
-  case 6:
-    __ ldr(c_rarg7, src);
-    _num_int_args++;
-    break;
-  default:
+  if (_num_int_args < Argument::n_int_register_parameters_c-1) {
+    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);
+  } else {
     __ ldrb(r0, src);
     __ strb(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeByteSpace;
-
-    _num_int_args++;
-    break;
+    _stack_offset += NativeStack::byteSpace;
   }
+
+  _num_int_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_short() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
-  switch (_num_int_args) {
-  case 0:
-    __ ldr(c_rarg1, src);
-    _num_int_args++;
-    break;
-  case 1:
-    __ ldr(c_rarg2, src);
-    _num_int_args++;
-    break;
-  case 2:
-    __ ldr(c_rarg3, src);
-    _num_int_args++;
-    break;
-  case 3:
-    __ ldr(c_rarg4, src);
-    _num_int_args++;
-    break;
-  case 4:
-    __ ldr(c_rarg5, src);
-    _num_int_args++;
-    break;
-  case 5:
-    __ ldr(c_rarg6, src);
-    _num_int_args++;
-    break;
-  case 6:
-    __ ldr(c_rarg7, src);
-    _num_int_args++;
-    break;
-  default:
-    _stack_offset = align_up(_stack_offset, nativeShortSpace);
+  if (_num_int_args < Argument::n_int_register_parameters_c-1) {
+    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);
+  } else {
+    _stack_offset = align_up(_stack_offset, NativeStack::shortSpace);
     __ ldrh(r0, src);
     __ strh(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeShortSpace;
-
-    _num_int_args++;
-    break;
+    _stack_offset += NativeStack::shortSpace;
   }
+
+  _num_int_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
-  switch (_num_int_args) {
-  case 0:
-    __ ldr(c_rarg1, src);
-    _num_int_args++;
-    break;
-  case 1:
-    __ ldr(c_rarg2, src);
-    _num_int_args++;
-    break;
-  case 2:
-    __ ldr(c_rarg3, src);
-    _num_int_args++;
-    break;
-  case 3:
-    __ ldr(c_rarg4, src);
-    _num_int_args++;
-    break;
-  case 4:
-    __ ldr(c_rarg5, src);
-    _num_int_args++;
-    break;
-  case 5:
-    __ ldr(c_rarg6, src);
-    _num_int_args++;
-    break;
-  case 6:
-    __ ldr(c_rarg7, src);
-    _num_int_args++;
-    break;
-  default:
-    _stack_offset = align_up(_stack_offset, nativeIntSpace);
-    __ ldr(r0, src);
-    __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeIntSpace;
-    _num_int_args++;
-    break;
+  if (_num_int_args < Argument::n_int_register_parameters_c-1) {
+    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);
+  } else {
+    _stack_offset = align_up(_stack_offset, NativeStack::intSpace);
+    __ ldrw(r0, src);
+    __ strw(r0, Address(to(), _stack_offset));
+    _stack_offset += NativeStack::intSpace;
   }
+
+  _num_int_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_long() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset() + 1));
 
-  switch (_num_int_args) {
-  case 0:
-    __ ldr(c_rarg1, src);
-    _num_int_args++;
-    break;
-  case 1:
-    __ ldr(c_rarg2, src);
-    _num_int_args++;
-    break;
-  case 2:
-    __ ldr(c_rarg3, src);
-    _num_int_args++;
-    break;
-  case 3:
-    __ ldr(c_rarg4, src);
-    _num_int_args++;
-    break;
-  case 4:
-    __ ldr(c_rarg5, src);
-    _num_int_args++;
-    break;
-  case 5:
-    __ ldr(c_rarg6, src);
-    _num_int_args++;
-    break;
-  case 6:
-    __ ldr(c_rarg7, src);
-    _num_int_args++;
-    break;
-  default:
-    _stack_offset = align_up(_stack_offset, nativeLongSpace);
+  if (_num_int_args < Argument::n_int_register_parameters_c-1) {
+    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);
+  } else {
+    _stack_offset = align_up(_stack_offset, NativeStack::longSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeLongSpace;
-    _num_int_args++;
-    break;
+    _stack_offset += NativeStack::longSpace;
   }
+
+  _num_int_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_float() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
   if (_num_fp_args < Argument::n_float_register_parameters_c) {
-    __ ldrs(as_FloatRegister(_num_fp_args++), src);
+    __ ldrs(as_FloatRegister(_num_fp_args), src);
   } else {
-      _stack_offset = align_up(_stack_offset, nativeFloatSpace);
+      _stack_offset = align_up(_stack_offset, NativeStack::floatSpace);
     __ ldrw(r0, src);
     __ strw(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeFloatSpace;
-    _num_fp_args++;
+    _stack_offset += NativeStack::floatSpace;
   }
+  _num_fp_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_double() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset() + 1));
 
   if (_num_fp_args < Argument::n_float_register_parameters_c) {
-    __ ldrd(as_FloatRegister(_num_fp_args++), src);
+    __ ldrd(as_FloatRegister(_num_fp_args), src);
   } else {
-    _stack_offset = align_up(_stack_offset, nativeDoubleSpace);
+    _stack_offset = align_up(_stack_offset, NativeStack::doubleSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeDoubleSpace;
-    _num_fp_args++;
+    _stack_offset += NativeStack::doubleSpace;
   }
+  _num_fp_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_object() {
@@ -410,12 +303,10 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = from_obj;
-      _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeByteSpace);
-
-      _num_int_args++;
+      store_and_inc(_to, from_obj, NativeStack::byteSpace);
     }
+    _num_int_args++;
   }
 
   virtual void pass_short()
@@ -426,12 +317,10 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = from_obj;
-      _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeShortSpace);
-
-      _num_int_args++;
+      store_and_inc(_to, from_obj, NativeStack::shortSpace);
     }
+    _num_int_args++;
   }
   virtual void pass_int()
   {
@@ -440,12 +329,10 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = from_obj;
-      _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeIntSpace);
-
-      _num_int_args++;
+      store_and_inc(_to, from_obj, NativeStack::intSpace);
     }
+    _num_int_args++;
   }
 
   virtual void pass_long()
@@ -455,11 +342,10 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = from_obj;
-      _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeLongSpace);
-      _num_int_args++;
+      store_and_inc(_to, from_obj, NativeStack::longSpace);
     }
+    _num_int_args++;
   }
 
   virtual void pass_object()
@@ -469,11 +355,10 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = (*from_addr == 0) ? NULL : (intptr_t)from_addr;
-      _num_int_args++;
     } else {
       store_and_inc(_to, (*from_addr == 0) ? (intptr_t)NULL : (intptr_t) from_addr, wordSize);
-      _num_int_args++;
     }
+    _num_int_args++;
   }
 
   virtual void pass_float()
@@ -483,12 +368,10 @@ class SlowSignatureHandler
 
     if (_num_fp_args < Argument::n_float_register_parameters_c) {
       *_fp_args++ = from_obj;
-      _num_fp_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeFloatSpace);
-
-      _num_fp_args++;
+      store_and_inc(_to, from_obj, NativeStack::floatSpace);
     }
+    _num_fp_args++;
   }
 
   virtual void pass_double()
@@ -499,11 +382,10 @@ class SlowSignatureHandler
     if (_num_fp_args < Argument::n_float_register_parameters_c) {
       *_fp_args++ = from_obj;
       *_fp_identifiers |= (1ull << _num_fp_args); // mark as double
-      _num_fp_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeDoubleSpace);
-      _num_fp_args++;
+      store_and_inc(_to, from_obj, NativeStack::doubleSpace);
     }
+    _num_fp_args++;
   }
 
  public:

From b3adff5408df64145efae048ed86e094a025d5f3 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Mon, 25 Jan 2021 18:55:24 +0300
Subject: [PATCH 48/94] Redo builsys support for aarch64-darwin

---
 make/autoconf/build-aux/autoconf-config.guess | 10 ++++++++
 make/autoconf/platform.m4                     | 25 +++++--------------
 2 files changed, 16 insertions(+), 19 deletions(-)

diff --git a/make/autoconf/build-aux/autoconf-config.guess b/make/autoconf/build-aux/autoconf-config.guess
index 15ee4389269..2dac331c9fd 100644
--- a/make/autoconf/build-aux/autoconf-config.guess
+++ b/make/autoconf/build-aux/autoconf-config.guess
@@ -1263,6 +1263,16 @@ EOF
 		      UNAME_PROCESSOR="x86_64"
 		  fi
 		fi ;;
+	    arm)
+		eval $set_cc_for_build
+		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		      grep IS_64BIT_ARCH >/dev/null
+		  then
+		      UNAME_PROCESSOR="aarch64"
+		  fi
+		fi ;;
 	    unknown) UNAME_PROCESSOR=powerpc ;;
 	esac
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
diff --git a/make/autoconf/platform.m4 b/make/autoconf/platform.m4
index 5b2e900b489..1890491773b 100644
--- a/make/autoconf/platform.m4
+++ b/make/autoconf/platform.m4
@@ -55,23 +55,10 @@ AC_DEFUN([PLATFORM_EXTRACT_VARS_FROM_CPU],
       VAR_CPU_ENDIAN=little
       ;;
     arm*)
-      # Second argument is the os name from the trip/quad.
-      # on macos-aarch64, triplet returned by autoconf is
-      # arm-darwin*, but on darwin only aarch64 is present.
-      case "$2" in
-        *darwin*)
-          VAR_CPU=aarch64
-          VAR_CPU_ARCH=aarch64
-          VAR_CPU_BITS=64
-          VAR_CPU_ENDIAN=little
-        ;;
-        *)
-          VAR_CPU=arm
-          VAR_CPU_ARCH=arm
-          VAR_CPU_BITS=32
-          VAR_CPU_ENDIAN=little
-        ;;
-      esac
+      VAR_CPU=arm
+      VAR_CPU_ARCH=arm
+      VAR_CPU_BITS=32
+      VAR_CPU_ENDIAN=little
       ;;
     aarch64)
       VAR_CPU=aarch64
@@ -270,7 +257,7 @@ AC_DEFUN([PLATFORM_EXTRACT_TARGET_AND_BUILD],
 
   # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU/LIBC variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($build_os)
-  PLATFORM_EXTRACT_VARS_FROM_CPU($build_cpu, $build_os)
+  PLATFORM_EXTRACT_VARS_FROM_CPU($build_cpu)
   PLATFORM_EXTRACT_VARS_FROM_LIBC($build_os)
   # ..and setup our own variables. (Do this explicitly to facilitate searching)
   OPENJDK_BUILD_OS="$VAR_OS"
@@ -308,7 +295,7 @@ AC_DEFUN([PLATFORM_EXTRACT_TARGET_AND_BUILD],
 
   # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU/LIBC variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($host_os)
-  PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu, $host_os)
+  PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu)
   PLATFORM_EXTRACT_VARS_FROM_LIBC($host_os)
   # ... and setup our own variables. (Do this explicitly to facilitate searching)
   OPENJDK_TARGET_OS="$VAR_OS"

From 0c2cb0a372bf1a8607810d773b53d6959616a816 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Mon, 25 Jan 2021 21:11:47 +0300
Subject: [PATCH 49/94] Refactor CDS disabling

---
 make/autoconf/jvm-features.m4 | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/make/autoconf/jvm-features.m4 b/make/autoconf/jvm-features.m4
index 8179ea86efd..51ce6da6cfb 100644
--- a/make/autoconf/jvm-features.m4
+++ b/make/autoconf/jvm-features.m4
@@ -264,13 +264,13 @@ AC_DEFUN_ONCE([JVM_FEATURES_CHECK_CDS],
 [
   JVM_FEATURES_CHECK_AVAILABILITY(cds, [
     AC_MSG_CHECKING([if platform is supported by CDS])
-    if test "x$OPENJDK_TARGET_OS" != xaix && \
-        !( test "x$OPENJDK_TARGET_OS" = "xmacosx" && \
+    if test "x$OPENJDK_TARGET_OS" = xaix || \
+        ( test "x$OPENJDK_TARGET_OS" = "xmacosx" && \
         test "x$OPENJDK_TARGET_CPU" = "xaarch64" ) ; then
-      AC_MSG_RESULT([yes])
-    else
-      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS])
+      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])
       AVAILABLE=false
+    else
+      AC_MSG_RESULT([yes])
     fi
   ])
 ])

From a8d8f4c8fa54fa0fd5797530accaa1a75fcad931 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 26 Jan 2021 16:18:39 +0300
Subject: [PATCH 50/94] Revert "Address feedback for signature generators"

This reverts commit 50b55f6684cd21f8b532fa979b7b6fbb4613266d.
---
 .../cpu/aarch64/interpreterRT_aarch64.cpp     | 248 +++++++++++++-----
 1 file changed, 183 insertions(+), 65 deletions(-)

diff --git a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
index 93edf13182a..8318393bcb8 100644
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
@@ -39,24 +39,21 @@
 #define __ _masm->
 
 //describe amount of space in bytes occupied by type on native stack
-class NativeStack : public AllStatic {
-public:
 #ifdef __APPLE__
-  static const int byteSpace        = sizeof(jbyte);
-  static const int shortSpace       = sizeof(jshort);
-  static const int intSpace         = sizeof(jint);
-  static const int longSpace        = wordSize;
-  static const int floatSpace       = intSpace;
-  static const int doubleSpace      = longSpace;
+    const int nativeByteSpace        = sizeof(jbyte);
+    const int nativeShortSpace       = sizeof(jshort);
+    const int nativeIntSpace         = sizeof(jint);
+    const int nativeLongSpace        = wordSize;
+    const int nativeFloatSpace       = nativeIntSpace;
+    const int nativeDoubleSpace      = nativeLongSpace;
 #else
-  static const int byteSpace        = wordSize;
-  static const int shortSpace       = wordSize;
-  static const int intSpace         = wordSize;
-  static const int longSpace        = wordSize;
-  static const int floatSpace       = intSpace;
-  static const int doubleSpace      = longSpace;
+    const int nativeByteSpace        = wordSize;
+    const int nativeShortSpace       = wordSize;
+    const int nativeIntSpace         = wordSize;
+    const int nativeLongSpace        = wordSize;
+    const int nativeFloatSpace       = nativeIntSpace;
+    const int nativeDoubleSpace      = nativeLongSpace;
 #endif
-};
 
 template <typename T>
 static inline void store_and_inc(char* &to, T value, int inc_size) {
@@ -85,88 +82,198 @@ InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 void InterpreterRuntime::SignatureHandlerGenerator::pass_byte() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
-  if (_num_int_args < Argument::n_int_register_parameters_c-1) {
-    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);
-  } else {
+  switch (_num_int_args) {
+  case 0:
+    __ ldr(c_rarg1, src);
+    _num_int_args++;
+    break;
+  case 1:
+    __ ldr(c_rarg2, src);
+    _num_int_args++;
+    break;
+  case 2:
+    __ ldr(c_rarg3, src);
+    _num_int_args++;
+    break;
+  case 3:
+    __ ldr(c_rarg4, src);
+    _num_int_args++;
+    break;
+  case 4:
+    __ ldr(c_rarg5, src);
+    _num_int_args++;
+    break;
+  case 5:
+    __ ldr(c_rarg6, src);
+    _num_int_args++;
+    break;
+  case 6:
+    __ ldr(c_rarg7, src);
+    _num_int_args++;
+    break;
+  default:
     __ ldrb(r0, src);
     __ strb(r0, Address(to(), _stack_offset));
-    _stack_offset += NativeStack::byteSpace;
-  }
+    _stack_offset += nativeByteSpace;
 
-  _num_int_args++;
+    _num_int_args++;
+    break;
+  }
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_short() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
-  if (_num_int_args < Argument::n_int_register_parameters_c-1) {
-    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);
-  } else {
-    _stack_offset = align_up(_stack_offset, NativeStack::shortSpace);
+  switch (_num_int_args) {
+  case 0:
+    __ ldr(c_rarg1, src);
+    _num_int_args++;
+    break;
+  case 1:
+    __ ldr(c_rarg2, src);
+    _num_int_args++;
+    break;
+  case 2:
+    __ ldr(c_rarg3, src);
+    _num_int_args++;
+    break;
+  case 3:
+    __ ldr(c_rarg4, src);
+    _num_int_args++;
+    break;
+  case 4:
+    __ ldr(c_rarg5, src);
+    _num_int_args++;
+    break;
+  case 5:
+    __ ldr(c_rarg6, src);
+    _num_int_args++;
+    break;
+  case 6:
+    __ ldr(c_rarg7, src);
+    _num_int_args++;
+    break;
+  default:
+    _stack_offset = align_up(_stack_offset, nativeShortSpace);
     __ ldrh(r0, src);
     __ strh(r0, Address(to(), _stack_offset));
-    _stack_offset += NativeStack::shortSpace;
-  }
+    _stack_offset += nativeShortSpace;
 
-  _num_int_args++;
+    _num_int_args++;
+    break;
+  }
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
-  if (_num_int_args < Argument::n_int_register_parameters_c-1) {
-    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);
-  } else {
-    _stack_offset = align_up(_stack_offset, NativeStack::intSpace);
-    __ ldrw(r0, src);
-    __ strw(r0, Address(to(), _stack_offset));
-    _stack_offset += NativeStack::intSpace;
+  switch (_num_int_args) {
+  case 0:
+    __ ldr(c_rarg1, src);
+    _num_int_args++;
+    break;
+  case 1:
+    __ ldr(c_rarg2, src);
+    _num_int_args++;
+    break;
+  case 2:
+    __ ldr(c_rarg3, src);
+    _num_int_args++;
+    break;
+  case 3:
+    __ ldr(c_rarg4, src);
+    _num_int_args++;
+    break;
+  case 4:
+    __ ldr(c_rarg5, src);
+    _num_int_args++;
+    break;
+  case 5:
+    __ ldr(c_rarg6, src);
+    _num_int_args++;
+    break;
+  case 6:
+    __ ldr(c_rarg7, src);
+    _num_int_args++;
+    break;
+  default:
+    _stack_offset = align_up(_stack_offset, nativeIntSpace);
+    __ ldr(r0, src);
+    __ str(r0, Address(to(), _stack_offset));
+    _stack_offset += nativeIntSpace;
+    _num_int_args++;
+    break;
   }
-
-  _num_int_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_long() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset() + 1));
 
-  if (_num_int_args < Argument::n_int_register_parameters_c-1) {
-    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);
-  } else {
-    _stack_offset = align_up(_stack_offset, NativeStack::longSpace);
+  switch (_num_int_args) {
+  case 0:
+    __ ldr(c_rarg1, src);
+    _num_int_args++;
+    break;
+  case 1:
+    __ ldr(c_rarg2, src);
+    _num_int_args++;
+    break;
+  case 2:
+    __ ldr(c_rarg3, src);
+    _num_int_args++;
+    break;
+  case 3:
+    __ ldr(c_rarg4, src);
+    _num_int_args++;
+    break;
+  case 4:
+    __ ldr(c_rarg5, src);
+    _num_int_args++;
+    break;
+  case 5:
+    __ ldr(c_rarg6, src);
+    _num_int_args++;
+    break;
+  case 6:
+    __ ldr(c_rarg7, src);
+    _num_int_args++;
+    break;
+  default:
+    _stack_offset = align_up(_stack_offset, nativeLongSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += NativeStack::longSpace;
+    _stack_offset += nativeLongSpace;
+    _num_int_args++;
+    break;
   }
-
-  _num_int_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_float() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
   if (_num_fp_args < Argument::n_float_register_parameters_c) {
-    __ ldrs(as_FloatRegister(_num_fp_args), src);
+    __ ldrs(as_FloatRegister(_num_fp_args++), src);
   } else {
-      _stack_offset = align_up(_stack_offset, NativeStack::floatSpace);
+      _stack_offset = align_up(_stack_offset, nativeFloatSpace);
     __ ldrw(r0, src);
     __ strw(r0, Address(to(), _stack_offset));
-    _stack_offset += NativeStack::floatSpace;
+    _stack_offset += nativeFloatSpace;
+    _num_fp_args++;
   }
-  _num_fp_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_double() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset() + 1));
 
   if (_num_fp_args < Argument::n_float_register_parameters_c) {
-    __ ldrd(as_FloatRegister(_num_fp_args), src);
+    __ ldrd(as_FloatRegister(_num_fp_args++), src);
   } else {
-    _stack_offset = align_up(_stack_offset, NativeStack::doubleSpace);
+    _stack_offset = align_up(_stack_offset, nativeDoubleSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += NativeStack::doubleSpace;
+    _stack_offset += nativeDoubleSpace;
+    _num_fp_args++;
   }
-  _num_fp_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_object() {
@@ -303,10 +410,12 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = from_obj;
+      _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, NativeStack::byteSpace);
+      store_and_inc(_to, from_obj, nativeByteSpace);
+
+      _num_int_args++;
     }
-    _num_int_args++;
   }
 
   virtual void pass_short()
@@ -317,10 +426,12 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = from_obj;
+      _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, NativeStack::shortSpace);
+      store_and_inc(_to, from_obj, nativeShortSpace);
+
+      _num_int_args++;
     }
-    _num_int_args++;
   }
   virtual void pass_int()
   {
@@ -329,10 +440,12 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = from_obj;
+      _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, NativeStack::intSpace);
+      store_and_inc(_to, from_obj, nativeIntSpace);
+
+      _num_int_args++;
     }
-    _num_int_args++;
   }
 
   virtual void pass_long()
@@ -342,10 +455,11 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = from_obj;
+      _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, NativeStack::longSpace);
+      store_and_inc(_to, from_obj, nativeLongSpace);
+      _num_int_args++;
     }
-    _num_int_args++;
   }
 
   virtual void pass_object()
@@ -355,10 +469,11 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = (*from_addr == 0) ? NULL : (intptr_t)from_addr;
+      _num_int_args++;
     } else {
       store_and_inc(_to, (*from_addr == 0) ? (intptr_t)NULL : (intptr_t) from_addr, wordSize);
+      _num_int_args++;
     }
-    _num_int_args++;
   }
 
   virtual void pass_float()
@@ -368,10 +483,12 @@ class SlowSignatureHandler
 
     if (_num_fp_args < Argument::n_float_register_parameters_c) {
       *_fp_args++ = from_obj;
+      _num_fp_args++;
     } else {
-      store_and_inc(_to, from_obj, NativeStack::floatSpace);
+      store_and_inc(_to, from_obj, nativeFloatSpace);
+
+      _num_fp_args++;
     }
-    _num_fp_args++;
   }
 
   virtual void pass_double()
@@ -382,10 +499,11 @@ class SlowSignatureHandler
     if (_num_fp_args < Argument::n_float_register_parameters_c) {
       *_fp_args++ = from_obj;
       *_fp_identifiers |= (1ull << _num_fp_args); // mark as double
+      _num_fp_args++;
     } else {
-      store_and_inc(_to, from_obj, NativeStack::doubleSpace);
+      store_and_inc(_to, from_obj, nativeDoubleSpace);
+      _num_fp_args++;
     }
-    _num_fp_args++;
   }
 
  public:

From cd794baf9c775662530a69cf774fc621c9195a65 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 26 Jan 2021 16:36:13 +0300
Subject: [PATCH 51/94] Partially bring previous commit

---
 .../cpu/aarch64/interpreterRT_aarch64.cpp     | 145 ++++++------------
 1 file changed, 44 insertions(+), 101 deletions(-)

diff --git a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
index 8318393bcb8..f5f7ab74700 100644
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
@@ -39,21 +39,24 @@
 #define __ _masm->
 
 //describe amount of space in bytes occupied by type on native stack
+class NativeStack : public AllStatic {
+public:
 #ifdef __APPLE__
-    const int nativeByteSpace        = sizeof(jbyte);
-    const int nativeShortSpace       = sizeof(jshort);
-    const int nativeIntSpace         = sizeof(jint);
-    const int nativeLongSpace        = wordSize;
-    const int nativeFloatSpace       = nativeIntSpace;
-    const int nativeDoubleSpace      = nativeLongSpace;
+  static const int byteSpace        = sizeof(jbyte);
+  static const int shortSpace       = sizeof(jshort);
+  static const int intSpace         = sizeof(jint);
+  static const int longSpace        = wordSize;
+  static const int floatSpace       = intSpace;
+  static const int doubleSpace      = longSpace;
 #else
-    const int nativeByteSpace        = wordSize;
-    const int nativeShortSpace       = wordSize;
-    const int nativeIntSpace         = wordSize;
-    const int nativeLongSpace        = wordSize;
-    const int nativeFloatSpace       = nativeIntSpace;
-    const int nativeDoubleSpace      = nativeLongSpace;
+  static const int byteSpace        = wordSize;
+  static const int shortSpace       = wordSize;
+  static const int intSpace         = wordSize;
+  static const int longSpace        = wordSize;
+  static const int floatSpace       = intSpace;
+  static const int doubleSpace      = longSpace;
 #endif
+};
 
 template <typename T>
 static inline void store_and_inc(char* &to, T value, int inc_size) {
@@ -82,86 +85,30 @@ InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 void InterpreterRuntime::SignatureHandlerGenerator::pass_byte() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
-  switch (_num_int_args) {
-  case 0:
-    __ ldr(c_rarg1, src);
-    _num_int_args++;
-    break;
-  case 1:
-    __ ldr(c_rarg2, src);
-    _num_int_args++;
-    break;
-  case 2:
-    __ ldr(c_rarg3, src);
-    _num_int_args++;
-    break;
-  case 3:
-    __ ldr(c_rarg4, src);
-    _num_int_args++;
-    break;
-  case 4:
-    __ ldr(c_rarg5, src);
-    _num_int_args++;
-    break;
-  case 5:
-    __ ldr(c_rarg6, src);
-    _num_int_args++;
-    break;
-  case 6:
-    __ ldr(c_rarg7, src);
-    _num_int_args++;
-    break;
-  default:
+  if (_num_int_args < Argument::n_int_register_parameters_c-1) {
+    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);
+  } else {
     __ ldrb(r0, src);
     __ strb(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeByteSpace;
-
-    _num_int_args++;
-    break;
+    _stack_offset += NativeStack::byteSpace;
   }
+
+  _num_int_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_short() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
-  switch (_num_int_args) {
-  case 0:
-    __ ldr(c_rarg1, src);
-    _num_int_args++;
-    break;
-  case 1:
-    __ ldr(c_rarg2, src);
-    _num_int_args++;
-    break;
-  case 2:
-    __ ldr(c_rarg3, src);
-    _num_int_args++;
-    break;
-  case 3:
-    __ ldr(c_rarg4, src);
-    _num_int_args++;
-    break;
-  case 4:
-    __ ldr(c_rarg5, src);
-    _num_int_args++;
-    break;
-  case 5:
-    __ ldr(c_rarg6, src);
-    _num_int_args++;
-    break;
-  case 6:
-    __ ldr(c_rarg7, src);
-    _num_int_args++;
-    break;
-  default:
-    _stack_offset = align_up(_stack_offset, nativeShortSpace);
+  if (_num_int_args < Argument::n_int_register_parameters_c-1) {
+    __ ldr(as_Register(_num_int_args + c_rarg1->encoding()), src);
+  } else {
+    _stack_offset = align_up(_stack_offset, NativeStack::shortSpace);
     __ ldrh(r0, src);
     __ strh(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeShortSpace;
-
-    _num_int_args++;
-    break;
+    _stack_offset += NativeStack::shortSpace;
   }
+
+  _num_int_args++;
 }
 
 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
@@ -197,10 +144,10 @@ void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
     _num_int_args++;
     break;
   default:
-    _stack_offset = align_up(_stack_offset, nativeIntSpace);
+    _stack_offset = align_up(_stack_offset, NativeStack::intSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeIntSpace;
+    _stack_offset += NativeStack::intSpace;
     _num_int_args++;
     break;
   }
@@ -239,10 +186,10 @@ void InterpreterRuntime::SignatureHandlerGenerator::pass_long() {
     _num_int_args++;
     break;
   default:
-    _stack_offset = align_up(_stack_offset, nativeLongSpace);
+    _stack_offset = align_up(_stack_offset, NativeStack::longSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeLongSpace;
+    _stack_offset += NativeStack::longSpace;
     _num_int_args++;
     break;
   }
@@ -254,10 +201,10 @@ void InterpreterRuntime::SignatureHandlerGenerator::pass_float() {
   if (_num_fp_args < Argument::n_float_register_parameters_c) {
     __ ldrs(as_FloatRegister(_num_fp_args++), src);
   } else {
-      _stack_offset = align_up(_stack_offset, nativeFloatSpace);
+      _stack_offset = align_up(_stack_offset, NativeStack::floatSpace);
     __ ldrw(r0, src);
     __ strw(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeFloatSpace;
+    _stack_offset += NativeStack::floatSpace;
     _num_fp_args++;
   }
 }
@@ -268,10 +215,10 @@ void InterpreterRuntime::SignatureHandlerGenerator::pass_double() {
   if (_num_fp_args < Argument::n_float_register_parameters_c) {
     __ ldrd(as_FloatRegister(_num_fp_args++), src);
   } else {
-    _stack_offset = align_up(_stack_offset, nativeDoubleSpace);
+    _stack_offset = align_up(_stack_offset, NativeStack::doubleSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += nativeDoubleSpace;
+    _stack_offset += NativeStack::doubleSpace;
     _num_fp_args++;
   }
 }
@@ -410,12 +357,10 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = from_obj;
-      _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeByteSpace);
-
-      _num_int_args++;
+      store_and_inc(_to, from_obj, NativeStack::byteSpace);
     }
+    _num_int_args++;
   }
 
   virtual void pass_short()
@@ -426,12 +371,10 @@ class SlowSignatureHandler
 
     if (_num_int_args < Argument::n_int_register_parameters_c-1) {
       *_int_args++ = from_obj;
-      _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeShortSpace);
-
-      _num_int_args++;
+      store_and_inc(_to, from_obj, NativeStack::shortSpace);
     }
+    _num_int_args++;
   }
   virtual void pass_int()
   {
@@ -442,7 +385,7 @@ class SlowSignatureHandler
       *_int_args++ = from_obj;
       _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeIntSpace);
+      store_and_inc(_to, from_obj, NativeStack::intSpace);
 
       _num_int_args++;
     }
@@ -457,7 +400,7 @@ class SlowSignatureHandler
       *_int_args++ = from_obj;
       _num_int_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeLongSpace);
+      store_and_inc(_to, from_obj, NativeStack::longSpace);
       _num_int_args++;
     }
   }
@@ -485,7 +428,7 @@ class SlowSignatureHandler
       *_fp_args++ = from_obj;
       _num_fp_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeFloatSpace);
+      store_and_inc(_to, from_obj, NativeStack::floatSpace);
 
       _num_fp_args++;
     }
@@ -501,7 +444,7 @@ class SlowSignatureHandler
       *_fp_identifiers |= (1ull << _num_fp_args); // mark as double
       _num_fp_args++;
     } else {
-      store_and_inc(_to, from_obj, nativeDoubleSpace);
+      store_and_inc(_to, from_obj, NativeStack::doubleSpace);
       _num_fp_args++;
     }
   }

From fef36580d7c5f00d6c1d24bd277d4d0ce87022ff Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 26 Jan 2021 17:28:35 +0300
Subject: [PATCH 52/94] Little adjustement of SlowSignatureHandler

---
 src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
index f5f7ab74700..f63d8506ee3 100644
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
@@ -348,10 +348,9 @@ class SlowSignatureHandler
   unsigned int _num_int_args;
   unsigned int _num_fp_args;
 
-
+#ifdef __APPLE__
   virtual void pass_byte()
   {
-    NOT_MACOS(return pass_int();)
     jbyte from_obj = *(jbyte *)(_from+Interpreter::local_offset_in_bytes(0));
     _from -= Interpreter::stackElementSize;
 
@@ -365,7 +364,6 @@ class SlowSignatureHandler
 
   virtual void pass_short()
   {
-    NOT_MACOS(return pass_int();)
     jshort from_obj = *(jshort *)(_from+Interpreter::local_offset_in_bytes(0));
     _from -= Interpreter::stackElementSize;
 
@@ -376,6 +374,8 @@ class SlowSignatureHandler
     }
     _num_int_args++;
   }
+#endif
+
   virtual void pass_int()
   {
     jint from_obj = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));

From b2b396fca679fbc7ee78fb5bc80191bc79e1c490 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 26 Jan 2021 10:37:13 -0800
Subject: [PATCH 53/94] Revert harfbuzz changes, disable warnings for it

---
 make/modules/java.desktop/lib/Awt2dLibraries.gmk         | 3 ++-
 src/java.desktop/share/native/libharfbuzz/hb-common.h    | 2 +-
 src/java.desktop/share/native/libharfbuzz/hb-coretext.cc | 2 --
 3 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/make/modules/java.desktop/lib/Awt2dLibraries.gmk b/make/modules/java.desktop/lib/Awt2dLibraries.gmk
index a633863dc06..c9153b9cf4b 100644
--- a/make/modules/java.desktop/lib/Awt2dLibraries.gmk
+++ b/make/modules/java.desktop/lib/Awt2dLibraries.gmk
@@ -497,7 +497,8 @@ else
         maybe-uninitialized class-memaccess, \
       DISABLED_WARNINGS_clang := unused-value incompatible-pointer-types \
         tautological-constant-out-of-range-compare int-to-pointer-cast \
-        undef missing-field-initializers range-loop-analysis, \
+        undef missing-field-initializers range-loop-analysis \
+        deprecated-declarations c++11-narrowing, \
       DISABLED_WARNINGS_microsoft := 4267 4244 4090 4146 4334 4819 4101 4068 4805 4138, \
       LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
diff --git a/src/java.desktop/share/native/libharfbuzz/hb-common.h b/src/java.desktop/share/native/libharfbuzz/hb-common.h
index 5b5e998a15f..9614e720b32 100644
--- a/src/java.desktop/share/native/libharfbuzz/hb-common.h
+++ b/src/java.desktop/share/native/libharfbuzz/hb-common.h
@@ -110,7 +110,7 @@ typedef union _hb_var_int_t {
 typedef uint32_t hb_tag_t;
 
 #define HB_TAG(c1,c2,c3,c4) ((hb_tag_t)((((uint32_t)(c1)&0xFF)<<24)|(((uint32_t)(c2)&0xFF)<<16)|(((uint32_t)(c3)&0xFF)<<8)|((uint32_t)(c4)&0xFF)))
-#define HB_UNTAG(tag)   (char)(((tag)>>24)&0xFF), (char)(((tag)>>16)&0xFF), (char)(((tag)>>8)&0xFF), (char)((tag)&0xFF)
+#define HB_UNTAG(tag)   (uint8_t)(((tag)>>24)&0xFF), (uint8_t)(((tag)>>16)&0xFF), (uint8_t)(((tag)>>8)&0xFF), (uint8_t)((tag)&0xFF)
 
 #define HB_TAG_NONE HB_TAG(0,0,0,0)
 #define HB_TAG_MAX HB_TAG(0xff,0xff,0xff,0xff)
diff --git a/src/java.desktop/share/native/libharfbuzz/hb-coretext.cc b/src/java.desktop/share/native/libharfbuzz/hb-coretext.cc
index 6087f28f97a..a382228f20d 100644
--- a/src/java.desktop/share/native/libharfbuzz/hb-coretext.cc
+++ b/src/java.desktop/share/native/libharfbuzz/hb-coretext.cc
@@ -190,7 +190,6 @@ create_ct_font (CGFontRef cg_font, CGFloat font_size)
    * reconfiguring the cascade list causes CoreText crashes. For details, see
    * crbug.com/549610 */
   // 0x00070000 stands for "kCTVersionNumber10_10", see CoreText.h
-#if TARGET_OS_OSX && MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_10
   if (&CTGetCoreTextVersion != nullptr && CTGetCoreTextVersion() < 0x00070000) {
     CFStringRef fontName = CTFontCopyPostScriptName (ct_font);
     bool isEmojiFont = CFStringCompare (fontName, CFSTR("AppleColorEmoji"), 0) == kCFCompareEqualTo;
@@ -198,7 +197,6 @@ create_ct_font (CGFontRef cg_font, CGFloat font_size)
     if (!isEmojiFont)
       return ct_font;
   }
-#endif
 
   CFURLRef original_url = nullptr;
 #if !(defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE) && MAC_OS_X_VERSION_MIN_REQUIRED < 1060

From f1ef62404fd8e64502ad28113163ba02f50a120d Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Wed, 27 Jan 2021 00:50:13 +0300
Subject: [PATCH 54/94] Redo buildsys fix

---
 make/autoconf/build-aux/autoconf-config.guess | 10 ----------
 make/autoconf/build-aux/config.guess          |  8 ++++++++
 2 files changed, 8 insertions(+), 10 deletions(-)

diff --git a/make/autoconf/build-aux/autoconf-config.guess b/make/autoconf/build-aux/autoconf-config.guess
index 2dac331c9fd..15ee4389269 100644
--- a/make/autoconf/build-aux/autoconf-config.guess
+++ b/make/autoconf/build-aux/autoconf-config.guess
@@ -1263,16 +1263,6 @@ EOF
 		      UNAME_PROCESSOR="x86_64"
 		  fi
 		fi ;;
-	    arm)
-		eval $set_cc_for_build
-		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		      grep IS_64BIT_ARCH >/dev/null
-		  then
-		      UNAME_PROCESSOR="aarch64"
-		  fi
-		fi ;;
 	    unknown) UNAME_PROCESSOR=powerpc ;;
 	esac
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
diff --git a/make/autoconf/build-aux/config.guess b/make/autoconf/build-aux/config.guess
index 916a464142b..2da3ce1dc0a 100644
--- a/make/autoconf/build-aux/config.guess
+++ b/make/autoconf/build-aux/config.guess
@@ -101,6 +101,14 @@ if [ "x$OUT" = x ]; then
   fi
 fi
 
+# Test and fix cpu on macos-aarch64, uname -p reports arm, buildsys expects aarch64
+echo $OUT | grep arm-apple-darwin > /dev/null 2> /dev/null
+if test $? = 0; then
+  if [ `uname -m` = arm64 ]; then
+    OUT=aarch64`echo $OUT | sed -e 's/[^-]*//'`
+  fi
+fi
+
 # Test and fix cpu on Macosx when C preprocessor is not on the path
 echo $OUT | grep i386-apple-darwin > /dev/null 2> /dev/null
 if test $? = 0; then

From 3d7ef7bf49114dd004f3d2a483561ca058a34354 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Wed, 27 Jan 2021 17:40:24 +0300
Subject: [PATCH 55/94] Fix inclusing of StubRoutines header

---
 src/hotspot/os/aix/os_aix.cpp                              | 1 -
 src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp | 1 -
 src/hotspot/share/runtime/stubRoutines.inline.hpp          | 4 ++--
 3 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/hotspot/os/aix/os_aix.cpp b/src/hotspot/os/aix/os_aix.cpp
index dbbe97d7a84..66a015b64a0 100644
--- a/src/hotspot/os/aix/os_aix.cpp
+++ b/src/hotspot/os/aix/os_aix.cpp
@@ -66,7 +66,6 @@
 #include "runtime/perfMemory.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/statSampler.hpp"
-#include "runtime/stubRoutines.hpp"
 #include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadCritical.hpp"
diff --git a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
index 034e113e742..16c913cd489 100644
--- a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
+++ b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
@@ -34,7 +34,6 @@
 #include "logging/log.hpp"
 #include "runtime/init.hpp"
 #include "runtime/os.hpp"
-#include "runtime/stubRoutines.hpp"
 #include "runtime/stubRoutines.inline.hpp"
 #include "utilities/align.hpp"
 #include "utilities/debug.hpp"
diff --git a/src/hotspot/share/runtime/stubRoutines.inline.hpp b/src/hotspot/share/runtime/stubRoutines.inline.hpp
index 4ce59480300..8f98f3900a3 100644
--- a/src/hotspot/share/runtime/stubRoutines.inline.hpp
+++ b/src/hotspot/share/runtime/stubRoutines.inline.hpp
@@ -25,8 +25,8 @@
 #ifndef SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
 #define SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
 
-#include <runtime/thread.hpp>
-#include <runtime/stubRoutines.hpp>
+#include "runtime/thread.hpp"
+#include "runtime/stubRoutines.hpp"
 
 // Safefetch allows to load a value from a location that's not known
 // to be valid. If the load causes a fault, the error value is returned.

From 9d8b07c289d32c58af12d5a130f5a35de4ea4a82 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Wed, 27 Jan 2021 17:43:05 +0300
Subject: [PATCH 56/94] Update copyright year for BsdAARCH64ThreadContext.java

---
 .../hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java   | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
index 1e0fcf15bb1..c1effb4598f 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it

From b61e6338637a9ea17dcfc40229e84953ee6034f2 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 29 Jan 2021 07:37:16 -0800
Subject: [PATCH 57/94] Revert w^x in gtests

---
 src/hotspot/share/logging/logStream.hpp       |  3 +-
 .../gc/shared/test_oopStorage_parperf.cpp     |  2 -
 test/hotspot/gtest/logging/test_logStream.cpp | 12 ++----
 test/hotspot/gtest/unittest.hpp               | 41 ++-----------------
 4 files changed, 8 insertions(+), 50 deletions(-)

diff --git a/src/hotspot/share/logging/logStream.hpp b/src/hotspot/share/logging/logStream.hpp
index 9c7535ac52b..b141be65a6a 100644
--- a/src/hotspot/share/logging/logStream.hpp
+++ b/src/hotspot/share/logging/logStream.hpp
@@ -32,7 +32,8 @@
 
 class LogStream : public outputStream {
   // see test/hotspot/gtest/logging/test_logStream.cpp
-  friend class LogStreamTest;
+  friend class LogStreamTest_TestLineBufferAllocation_vm_Test;
+  friend class LogStreamTest_TestLineBufferAllocationCap_vm_Test;
 
   // Helper class, maintains the line buffer. For small line lengths,
   // we avoid malloc and use a fixed sized member char array. If LogStream
diff --git a/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp b/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
index b55822fb26a..dea8fe7903a 100644
--- a/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
+++ b/test/hotspot/gtest/gc/shared/test_oopStorage_parperf.cpp
@@ -96,8 +96,6 @@ OopStorageParIterPerf::OopStorageParIterPerf() :
 }
 
 OopStorageParIterPerf::~OopStorageParIterPerf() {
-  // missing transition to vm state
-  Thread::WXWriteFromExecSetter wx_write;
   _storage.release(_entries, ARRAY_SIZE(_entries));
 }
 
diff --git a/test/hotspot/gtest/logging/test_logStream.cpp b/test/hotspot/gtest/logging/test_logStream.cpp
index fabe1d6953c..e6628dc121d 100644
--- a/test/hotspot/gtest/logging/test_logStream.cpp
+++ b/test/hotspot/gtest/logging/test_logStream.cpp
@@ -31,12 +31,6 @@
 class LogStreamTest : public LogTestFixture {
  protected:
   void verify_stream(outputStream* stream);
-  const char* current_line_buffer(LogStream& ls) {
-    return ls._current_line.buffer();
-  }
-  void current_line_reset(LogStream& ls) {
-    ls._current_line.reset();
-  }
 };
 
 void LogStreamTest::verify_stream(outputStream* stream) {
@@ -86,7 +80,7 @@ TEST_VM_F(LogStreamTest, TestLineBufferAllocation) {
       const int to_write = MIN2(interval, max_line_len - written);
       ls.write(test_string, interval);
       written += interval;
-      const char* const line_buffer = current_line_buffer(ls);
+      const char* const line_buffer = ls._current_line.buffer();
       for (int i = 0; i < written; i++) {
         ASSERT_TRUE(line_buffer[i] == 'A');
       }
@@ -102,10 +96,10 @@ TEST_VM_F(LogStreamTest, TestLineBufferAllocationCap) {
   for (size_t i = 0; i < (1*M + 512); i ++) {
     ls.print_raw("A");
   }
-  const char* const line_buffer = current_line_buffer(ls);
+  const char* const line_buffer = ls._current_line.buffer();
   ASSERT_TRUE(strlen(line_buffer) == 1*M - 1);
   // reset to prevent assert for unflushed content
-  current_line_reset(ls);
+  ls._current_line.reset();
 }
 
 TEST_VM_F(LogStreamTest, autoflush_on_destruction) {
diff --git a/test/hotspot/gtest/unittest.hpp b/test/hotspot/gtest/unittest.hpp
index 9ddb633eeb3..140d14d25f2 100644
--- a/test/hotspot/gtest/unittest.hpp
+++ b/test/hotspot/gtest/unittest.hpp
@@ -27,9 +27,6 @@
 #include <stdlib.h>
 #include <stdio.h>
 
-// For Thread definition
-#include "runtime/thread.hpp"
-
 #define GTEST_DONT_DEFINE_TEST 1
 
 // googlemock has ::testing::internal::Log function, so we need to temporary
@@ -79,46 +76,16 @@
 
 #define TEST(category, name) GTEST_TEST(category, name)
 
-#define TEST_VM(category, name)                                     \
-  class category ## _  ## name ## _vm : public ::testing::Test {    \
-  public:                                                           \
-    static void do_test();                                          \
-  };                                                                \
-                                                                    \
-  GTEST_TEST(category, CONCAT(name, _vm)) {                         \
-    Thread::WXWriteFromExecSetter wx_write;                         \
-    category ## _ ## name ## _vm::do_test();                        \
-  }                                                                 \
-                                                                    \
-  void category ## _ ## name ## _vm::do_test()
+#define TEST_VM(category, name) GTEST_TEST(category, CONCAT(name, _vm))
 
 #define TEST_VM_F(test_fixture, name)                               \
-  class test_fixture ## _  ## name ## _vm_f : public test_fixture { \
-  public:                                                           \
-    void SetUp() {                                                  \
-      Thread::WXWriteFromExecSetter wx_write;                       \
-      test_fixture::SetUp();                                        \
-    }                                                               \
-  protected:                                                        \
-    void do_test();                                                 \
-  };                                                                \
-                                                                    \
-  GTEST_TEST_(test_fixture ## _ ## name,                            \
-      name ## _vm,                                                  \
-      test_fixture ## _ ## name ## _vm_f,                           \
-      ::testing::internal::GetTypeId<                               \
-        test_fixture ## _ ## name ## _vm_f>()) {                    \
-    Thread::WXWriteFromExecSetter wx_write;                         \
-    do_test();                                                      \
-  }                                                                 \
-                                                                    \
-  void test_fixture ## _ ## name ## _vm_f::do_test()
+  GTEST_TEST_(test_fixture, name ## _vm, test_fixture,              \
+              ::testing::internal::GetTypeId<test_fixture>())
 
 #define TEST_OTHER_VM(category, name)                               \
   static void test_  ## category ## _ ## name ## _();               \
                                                                     \
   static void child_ ## category ## _ ## name ## _() {              \
-    Thread::WXWriteFromExecSetter wx_write;                         \
     ::testing::GTEST_FLAG(throw_on_failure) = true;                 \
     test_ ## category ## _ ## name ## _();                          \
     fprintf(stderr, "OKIDOKI");                                     \
@@ -138,7 +105,6 @@
   static void test_  ## category ## _ ## name ## _();               \
                                                                     \
   static void child_ ## category ## _ ## name ## _() {              \
-    Thread::WXWriteFromExecSetter wx_write;                         \
     ::testing::GTEST_FLAG(throw_on_failure) = true;                 \
     test_ ## category ## _ ## name ## _();                          \
     exit(0);                                                        \
@@ -161,7 +127,6 @@
   static void test_  ## category ## _ ## name ## _();               \
                                                                     \
   static void child_ ## category ## _ ## name ## _() {              \
-    Thread::WXWriteFromExecSetter wx_write;                         \
     ::testing::GTEST_FLAG(throw_on_failure) = true;                 \
     test_ ## category ## _ ## name ## _();                          \
     exit(0);                                                        \

From 3c705ae57adfb8ac9eaf54b7c9170e97fff2e9c8 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Tue, 2 Feb 2021 14:53:42 +0300
Subject: [PATCH 58/94] support macos_aarch64 in hsdis

---
 src/utils/hsdis/Makefile | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/src/utils/hsdis/Makefile b/src/utils/hsdis/Makefile
index 9bb936e6515..e585df19a54 100644
--- a/src/utils/hsdis/Makefile
+++ b/src/utils/hsdis/Makefile
@@ -107,13 +107,19 @@ else
 ifeq ($(OS),Darwin)
 CPU             = $(shell uname -m)
 ARCH1=$(CPU:x86_64=amd64)
-ARCH=$(ARCH1:i686=i386)
+ARCH2=$(ARCH1:arm64=aarch64)
+ARCH=$(ARCH2:i686=i386)
+CONFIGURE_ARGS/aarch64= --enable-targets=aarch64-darwin
+CONFIGURE_ARGS = $(CONFIGURE_ARGS/$(ARCH))
 ifdef LP64
 CFLAGS/amd64    += -m64
 else
-ARCH=$(ARCH1:amd64=i386)
+ARCH=$(ARCH2:amd64=i386)
 CFLAGS/i386     += -m32
 endif # LP64
+ifeq ($(CPU), arm64)
+CFLAGS/aarch64  += -m64
+endif # arm64
 CFLAGS          += $(CFLAGS/$(ARCH))
 CFLAGS          += -fPIC
 OS              = macosx

From 3e7b08d455cc9c18acb608e22a9df862a2ae5ade Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Mon, 1 Feb 2021 13:12:01 -0800
Subject: [PATCH 59/94] Do not require known W^X state

---
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.cpp     |  4 +-
 src/hotspot/share/c1/c1_Runtime1.cpp          |  2 +-
 src/hotspot/share/ci/ciUtilities.inline.hpp   |  2 -
 src/hotspot/share/classfile/classLoader.cpp   |  4 -
 src/hotspot/share/classfile/javaClasses.cpp   |  2 -
 src/hotspot/share/classfile/verifier.cpp      |  1 -
 src/hotspot/share/compiler/compileBroker.cpp  |  3 -
 .../share/gc/shared/barrierSetNMethod.cpp     |  3 +-
 .../share/interpreter/interpreterRuntime.cpp  |  2 +
 .../jfr/instrumentation/jfrJvmtiAgent.cpp     |  3 -
 .../share/jvmci/jniAccessMark.inline.hpp      |  3 +-
 .../share/jvmci/jvmciCodeInstaller.cpp        |  1 -
 src/hotspot/share/jvmci/jvmciCompilerToVM.cpp |  2 +-
 src/hotspot/share/jvmci/jvmciRuntime.cpp      |  2 -
 src/hotspot/share/opto/runtime.cpp            |  3 +-
 src/hotspot/share/prims/jni.cpp               |  6 +-
 src/hotspot/share/prims/jniCheck.cpp          |  2 +-
 src/hotspot/share/prims/jvm.cpp               |  1 -
 src/hotspot/share/prims/jvmtiEnter.xsl        |  2 +-
 src/hotspot/share/prims/jvmtiEnv.cpp          |  2 +-
 src/hotspot/share/prims/jvmtiExport.cpp       |  6 +-
 src/hotspot/share/prims/jvmtiImpl.cpp         |  1 -
 src/hotspot/share/prims/jvmtiRawMonitor.cpp   |  2 -
 src/hotspot/share/prims/methodHandles.cpp     |  1 -
 src/hotspot/share/prims/nativeEntryPoint.cpp  |  1 -
 src/hotspot/share/prims/nativeLookup.cpp      |  1 -
 src/hotspot/share/prims/perf.cpp              |  9 --
 .../share/prims/scopedMemoryAccess.cpp        |  1 -
 .../share/prims/universalNativeInvoker.cpp    |  1 -
 src/hotspot/share/prims/unsafe.cpp            |  7 +-
 src/hotspot/share/prims/vectorSupport.cpp     |  1 -
 src/hotspot/share/prims/whitebox.cpp          | 32 -------
 src/hotspot/share/prims/whitebox.inline.hpp   |  3 +-
 src/hotspot/share/runtime/deoptimization.cpp  |  3 +-
 .../share/runtime/interfaceSupport.inline.hpp | 19 ++--
 src/hotspot/share/runtime/javaCalls.cpp       |  4 +-
 src/hotspot/share/runtime/safepoint.cpp       |  3 +-
 src/hotspot/share/runtime/sharedRuntime.cpp   |  3 -
 .../share/runtime/stubRoutines.inline.hpp     |  5 +-
 src/hotspot/share/runtime/thread.cpp          |  5 +-
 src/hotspot/share/runtime/thread.hpp          | 90 +++++--------------
 src/hotspot/share/runtime/threadWXSetters.hpp | 46 ++++++++++
 .../share/services/diagnosticCommand.cpp      |  1 -
 43 files changed, 109 insertions(+), 186 deletions(-)
 create mode 100644 src/hotspot/share/runtime/threadWXSetters.hpp

diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index ba305e480dd..812127920e2 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -210,6 +210,8 @@ NOINLINE frame os::current_frame() {
 bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
                                              ucontext_t* uc, JavaThread* thread) {
 
+  ThreadWXEnable wx_write(WXWrite, thread);
+
 /*
   NOTE: does not seem to work on bsd.
   if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {
@@ -244,7 +246,6 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
 
       // check if fault address is within thread stack
       if (thread->is_in_full_stack(addr)) {
-        Thread::WXWriteFromExecSetter wx_write;
         // stack overflow
         if (os::Posix::handle_stack_overflow(thread, addr, pc, uc, &stub)) {
           return true; // continue
@@ -260,7 +261,6 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
     if (thread->thread_state() == _thread_in_Java && stub == NULL) {
       // Java thread running in Java code => find exception handler if any
       // a fault inside compiled code, the interpreter, or a stub
-      Thread::WXWriteFromExecSetter wx_write;
 
       // Handle signal from NativeJump::patch_verified_entry().
       if ((sig == SIGILL)
diff --git a/src/hotspot/share/c1/c1_Runtime1.cpp b/src/hotspot/share/c1/c1_Runtime1.cpp
index 83914cd55bd..90b91f651fa 100644
--- a/src/hotspot/share/c1/c1_Runtime1.cpp
+++ b/src/hotspot/share/c1/c1_Runtime1.cpp
@@ -1268,7 +1268,7 @@ JRT_END
 void Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id) {
   NOT_PRODUCT(_patch_code_slowcase_cnt++);
 
-  Thread::WXWriteFromExecSetter wx_write;
+  ThreadWXEnable wx_write(WXWrite, thread);
 
   if (TracePatching) {
     tty->print_cr("Deoptimizing because patch is needed");
diff --git a/src/hotspot/share/ci/ciUtilities.inline.hpp b/src/hotspot/share/ci/ciUtilities.inline.hpp
index a1bd5173f76..780efe368c2 100644
--- a/src/hotspot/share/ci/ciUtilities.inline.hpp
+++ b/src/hotspot/share/ci/ciUtilities.inline.hpp
@@ -34,7 +34,6 @@
 #define VM_ENTRY_MARK                       \
   CompilerThread* thread=CompilerThread::current(); \
   ThreadInVMfromNative __tiv(thread);       \
-  Thread::WXWriteVerifier __wx_write;       \
   HandleMarkCleaner __hm(thread);           \
   Thread* THREAD = thread;                  \
   debug_only(VMNativeEntryWrapper __vew;)
@@ -45,7 +44,6 @@
 #define VM_QUICK_ENTRY_MARK                 \
   CompilerThread* thread=CompilerThread::current(); \
   ThreadInVMfromNative __tiv(thread);       \
-  Thread::WXWriteVerifier __wx_write;       \
 /*                                          \
  * [TODO] The NoHandleMark line does nothing but declare a function prototype \
  * The NoHandkeMark constructor is NOT executed. If the ()'s are   \
diff --git a/src/hotspot/share/classfile/classLoader.cpp b/src/hotspot/share/classfile/classLoader.cpp
index 4c7b606d2c6..835b6685c7b 100644
--- a/src/hotspot/share/classfile/classLoader.cpp
+++ b/src/hotspot/share/classfile/classLoader.cpp
@@ -292,7 +292,6 @@ u1* ClassPathZipEntry::open_entry(const char* name, jint* filesize, bool nul_ter
     // enable call to C land
   JavaThread* thread = JavaThread::current();
   ThreadToNativeFromVM ttn(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   // check whether zip archive contains name
   jint name_len;
   jzentry* entry = (*FindEntry)(_zip, name, filesize, &name_len);
@@ -339,7 +338,6 @@ void ClassPathZipEntry::contents_do(void f(const char* name, void* context), voi
   JavaThread* thread = JavaThread::current();
   HandleMark  handle_mark(thread);
   ThreadToNativeFromVM ttn(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   for (int n = 0; ; n++) {
     jzentry * ze = ((*GetNextEntry)(_zip, n));
     if (ze == NULL) break;
@@ -752,7 +750,6 @@ ClassPathEntry* ClassLoader::create_class_path_entry(const char *path, const str
       {
         // enable call to C land
         ThreadToNativeFromVM ttn(thread);
-        Thread::WXExecFromWriteSetter wx_exec;
         HandleMark hm(thread);
         load_zip_library_if_needed();
         zip = (*ZipOpen)(canonical_path, &error_msg);
@@ -803,7 +800,6 @@ ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path, bo
           // enable call to C land
           JavaThread* thread = JavaThread::current();
           ThreadToNativeFromVM ttn(thread);
-          Thread::WXExecFromWriteSetter wx_exec;
           HandleMark hm(thread);
           load_zip_library_if_needed();
           zip = (*ZipOpen)(canonical_path, &error_msg);
diff --git a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
index 6bdcecf43a7..536201f5345 100644
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -414,7 +414,6 @@ Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRA
     JavaThread* thread = THREAD->as_Java_thread();
     HandleMark hm(thread);
     ThreadToNativeFromVM ttn(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     js = (_to_java_string_fn)(thread->jni_environment(), str);
   }
 
@@ -443,7 +442,6 @@ char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
     bool is_copy;
     HandleMark hm(thread);
     ThreadToNativeFromVM ttn(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     JNIEnv *env = thread->jni_environment();
     native_platform_string = (_to_platform_string_fn)(env, js, &is_copy);
     assert(is_copy == JNI_TRUE, "is_copy value changed");
diff --git a/src/hotspot/share/classfile/verifier.cpp b/src/hotspot/share/classfile/verifier.cpp
index 9654103d969..6ea7440291a 100644
--- a/src/hotspot/share/classfile/verifier.cpp
+++ b/src/hotspot/share/classfile/verifier.cpp
@@ -315,7 +315,6 @@ Symbol* Verifier::inference_verify(
   {
     HandleMark hm(thread);
     ThreadToNativeFromVM ttn(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     // ThreadToNativeFromVM takes care of changing thread_state, so safepoint
     // code knows that we have left the VM
     JNIEnv *env = thread->jni_environment();
diff --git a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp
index 213a0effa9d..57a0b165962 100644
--- a/src/hotspot/share/compiler/compileBroker.cpp
+++ b/src/hotspot/share/compiler/compileBroker.cpp
@@ -1795,7 +1795,6 @@ bool CompileBroker::init_compiler_runtime() {
   {
     // Must switch to native to allocate ci_env
     ThreadToNativeFromVM ttn(thread);
-    Thread::WXWriteVerifier wx_write;
     ciEnv ci_env((CompileTask*)NULL);
     // Cache Jvmti state
     ci_env.cache_jvmti_state();
@@ -2091,7 +2090,6 @@ void CompileBroker::maybe_block() {
       tty->print_cr("compiler thread " INTPTR_FORMAT " poll detects block request", p2i(Thread::current()));
 #endif
     ThreadInVMfromNative tivfn(JavaThread::current());
-    Thread::WXWriteVerifier wx_write;
   }
 }
 
@@ -2282,7 +2280,6 @@ void CompileBroker::invoke_compiler_on_method(CompileTask* task) {
   {
     NoHandleMark  nhm;
     ThreadToNativeFromVM ttn(thread);
-    Thread::WXWriteVerifier wx_write;
 
     ciEnv ci_env(task);
     if (should_break) {
diff --git a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
index 425bcdb26ea..f767c42b4c0 100644
--- a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
+++ b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
@@ -29,6 +29,7 @@
 #include "gc/shared/barrierSetNMethod.hpp"
 #include "logging/log.hpp"
 #include "runtime/thread.hpp"
+#include "runtime/threadWXSetters.hpp"
 #include "utilities/debug.hpp"
 
 int BarrierSetNMethod::disarmed_value() const {
@@ -48,7 +49,7 @@ bool BarrierSetNMethod::supports_entry_barrier(nmethod* nm) {
 }
 
 int BarrierSetNMethod::nmethod_stub_entry_barrier(address* return_address_ptr) {
-  Thread::WXWriteFromExecSetter wx_write;
+  ThreadWXEnable wx_write(WXWrite);
 
   address return_address = *return_address_ptr;
   CodeBlob* cb = CodeCache::find_blob(return_address);
diff --git a/src/hotspot/share/interpreter/interpreterRuntime.cpp b/src/hotspot/share/interpreter/interpreterRuntime.cpp
index 7faee67aa96..c6ed34b590f 100644
--- a/src/hotspot/share/interpreter/interpreterRuntime.cpp
+++ b/src/hotspot/share/interpreter/interpreterRuntime.cpp
@@ -970,6 +970,8 @@ JRT_END
 
 
 nmethod* InterpreterRuntime::frequency_counter_overflow(JavaThread* thread, address branch_bcp) {
+  ThreadWXEnable wx_write(WXWrite, thread);
+
   // frequency_counter_overflow_inner can throw async exception.
   nmethod* nm = frequency_counter_overflow_inner(thread, branch_bcp);
   assert(branch_bcp != NULL || nm == NULL, "always returns null for non OSR requests");
diff --git a/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp b/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp
index 2bca6f1ace8..4dc9fba7ae5 100644
--- a/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp
+++ b/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp
@@ -84,7 +84,6 @@ extern "C" void JNICALL jfr_on_class_file_load_hook(jvmtiEnv *jvmti_env,
   }
   JavaThread* jt = JavaThread::thread_from_jni_environment(jni_env);
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));;
-  Thread::WXWriteFromExecSetter wx_write;
   ThreadInVMfromNative tvmfn(jt);
   JfrUpcalls::on_retransform(JfrTraceId::load_raw(class_being_redefined),
                              class_being_redefined,
@@ -232,7 +231,6 @@ JfrJvmtiAgent::~JfrJvmtiAgent() {
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
   if (jfr_jvmti_env != NULL) {
     ThreadToNativeFromVM transition(jt);
-    Thread::WXExecFromWriteSetter wx_exec;
     update_class_file_load_hook_event(JVMTI_DISABLE);
     unregister_callbacks(jt);
     jfr_jvmti_env->DisposeEnvironment();
@@ -244,7 +242,6 @@ static bool initialize(JavaThread* jt) {
   assert(jt != NULL, "invariant");
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
   ThreadToNativeFromVM transition(jt);
-  Thread::WXExecFromWriteSetter wx_exec;
   if (create_jvmti_env(jt) != JNI_OK) {
     assert(jfr_jvmti_env == NULL, "invariant");
     return false;
diff --git a/src/hotspot/share/jvmci/jniAccessMark.inline.hpp b/src/hotspot/share/jvmci/jniAccessMark.inline.hpp
index f9b8e8960e0..9e691313c99 100644
--- a/src/hotspot/share/jvmci/jniAccessMark.inline.hpp
+++ b/src/hotspot/share/jvmci/jniAccessMark.inline.hpp
@@ -36,12 +36,11 @@
 class JNIAccessMark : public StackObj {
  private:
   ThreadToNativeFromVM _ttnfv;
-  Thread::WXExecFromWriteSetter _wx_exec;
   HandleMark _hm;
   JNIEnv* _env;
  public:
   inline JNIAccessMark(JVMCIEnv* jvmci_env, JavaThread* thread=JavaThread::current()) :
-    _ttnfv(thread), _wx_exec(), _hm(thread) {
+    _ttnfv(thread), _hm(thread) {
     _env = jvmci_env->_env;
   }
   JNIEnv* env() const { return _env; }
diff --git a/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp b/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
index 03749bda420..a08da908705 100644
--- a/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
+++ b/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
@@ -931,7 +931,6 @@ JVMCI::CodeInstallResult CodeInstaller::initialize_buffer(CodeBuffer& buffer, bo
     if (SafepointMechanism::should_process(thread)) {
       // this is a hacky way to force a safepoint check but nothing else was jumping out at me.
       ThreadToNativeFromVM ttnfv(thread);
-      Thread::WXWriteVerifier wx_write;
     }
   }
 
diff --git a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
index 0189d4fe6f7..1b121dce4b4 100644
--- a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
+++ b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
@@ -125,7 +125,7 @@ Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 
 // Bring the JVMCI compiler thread into the VM state.
 #define JVMCI_VM_ENTRY_MARK                   \
-  Thread::WXWriteFromExecSetter __wx_write;   \
+  ThreadWXEnable __wx_write(WXWrite, thread); \
   ThreadInVMfromNative __tiv(thread);         \
   HandleMarkCleaner __hm(thread);             \
   Thread* THREAD = thread;                    \
diff --git a/src/hotspot/share/jvmci/jvmciRuntime.cpp b/src/hotspot/share/jvmci/jvmciRuntime.cpp
index 2d792c4165b..44998115255 100644
--- a/src/hotspot/share/jvmci/jvmciRuntime.cpp
+++ b/src/hotspot/share/jvmci/jvmciRuntime.cpp
@@ -867,7 +867,6 @@ void JVMCIRuntime::init_JavaVM_info(jlongArray info, JVMCI_TRAPS) {
 #define JAVAVM_CALL_BLOCK                                             \
   guarantee(thread != NULL && _shared_library_javavm != NULL, "npe"); \
   ThreadToNativeFromVM ttnfv(thread);                                 \
-  Thread::WXExecFromWriteSetter wx_exec;                              \
   JavaVM* javavm = (JavaVM*) _shared_library_javavm;
 
 jint JVMCIRuntime::AttachCurrentThread(JavaThread* thread, void **penv, void *args) {
@@ -1028,7 +1027,6 @@ JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
     ResourceMark rm(thread);
     HandleMark hm(thread);
     ThreadToNativeFromVM trans(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
 
     // Ensure _non_oop_bits is initialized
     Universe::non_oop_word();
diff --git a/src/hotspot/share/opto/runtime.cpp b/src/hotspot/share/opto/runtime.cpp
index d293590d147..f164450610c 100644
--- a/src/hotspot/share/opto/runtime.cpp
+++ b/src/hotspot/share/opto/runtime.cpp
@@ -71,6 +71,7 @@
 #include "runtime/signature.hpp"
 #include "runtime/stackWatermarkSet.hpp"
 #include "runtime/threadCritical.hpp"
+#include "runtime/threadWXSetters.hpp"
 #include "runtime/vframe.hpp"
 #include "runtime/vframeArray.hpp"
 #include "runtime/vframe_hp.hpp"
@@ -1426,7 +1427,7 @@ address OptoRuntime::rethrow_C(oopDesc* exception, JavaThread* thread, address r
   }
 #endif
 
-  Thread::WXWriteFromExecSetter wx_write;
+  ThreadWXEnable wx_write(WXWrite, thread);
 
   thread->set_vm_result(exception);
   // Frame not compiled (handles deoptimization blob)
diff --git a/src/hotspot/share/prims/jni.cpp b/src/hotspot/share/prims/jni.cpp
index 7ffc589168e..bca8aaf1f15 100644
--- a/src/hotspot/share/prims/jni.cpp
+++ b/src/hotspot/share/prims/jni.cpp
@@ -3640,7 +3640,7 @@ static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
 
     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
-    Thread::enable_wx_from_write(WXExec);
+    thread->enable_wx(WXExec);
   } else {
     // If create_vm exits because of a pending exception, exit with that
     // exception.  In the future when we figure out how to reclaim memory,
@@ -3732,7 +3732,6 @@ static jint JNICALL jni_DestroyJavaVM_inner(JavaVM *vm) {
   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
   JavaThread* thread = JavaThread::current();
   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
-  Thread::enable_wx_from_exec(WXWrite);
   if (Threads::destroy_vm()) {
     // Should not change thread state, VM is gone
     vm_created = 0;
@@ -3867,7 +3866,7 @@ static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool dae
   // needed.
 
   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
-  Thread::enable_wx_from_write(WXExec);
+  thread->enable_wx(WXExec);
 
   // Perform any platform dependent FPU setup
   os::setup_fpu();
@@ -3922,7 +3921,6 @@ jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
   // Safepoint support. Have to do call-back to safepoint code, if in the
   // middle of a safepoint operation
   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
-  Thread::enable_wx_from_exec(WXWrite);
 
   // XXX: Note that JavaThread::exit() call below removes the guards on the
   // stack pages set up via enable_stack_{red,yellow}_zone() calls
diff --git a/src/hotspot/share/prims/jniCheck.cpp b/src/hotspot/share/prims/jniCheck.cpp
index 8d22491ca87..403dab2d445 100644
--- a/src/hotspot/share/prims/jniCheck.cpp
+++ b/src/hotspot/share/prims/jniCheck.cpp
@@ -65,7 +65,6 @@
 
 #define IN_VM(source_code)   {                                         \
     {                                                                  \
-      Thread::WXWriteFromExecSetter __wx_write;                        \
       ThreadInVMfromNative __tiv(thr);                                 \
       source_code                                                      \
     }                                                                  \
@@ -105,6 +104,7 @@ extern "C" {                                                             \
     if (env != xenv) {                                                   \
       NativeReportJNIFatalError(thr, warn_wrong_jnienv);                 \
     }                                                                    \
+    ThreadWXEnable __wx_write(WXWrite, thr);                             \
     VM_ENTRY_BASE(result_type, header, thr)
 
 
diff --git a/src/hotspot/share/prims/jvm.cpp b/src/hotspot/share/prims/jvm.cpp
index 1110995ae43..ac3b3e983e8 100644
--- a/src/hotspot/share/prims/jvm.cpp
+++ b/src/hotspot/share/prims/jvm.cpp
@@ -3427,7 +3427,6 @@ JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
   void *load_result;
   {
     ThreadToNativeFromVM ttnfvm(thread);
-    Thread::WXWriteVerifier wx_write;
     load_result = os::dll_load(name, ebuf, sizeof ebuf);
   }
   if (load_result == NULL) {
diff --git a/src/hotspot/share/prims/jvmtiEnter.xsl b/src/hotspot/share/prims/jvmtiEnter.xsl
index ef279af72c4..b5730d74397 100644
--- a/src/hotspot/share/prims/jvmtiEnter.xsl
+++ b/src/hotspot/share/prims/jvmtiEnter.xsl
@@ -433,7 +433,7 @@ struct jvmtiInterface_1_ jvmti</xsl:text>
   <xsl:if test="count(@impl)=0 or not(contains(@impl,'innative'))">
     <xsl:text>JavaThread* current_thread = this_thread->as_Java_thread();</xsl:text>
     <xsl:value-of select="$space"/>
-    <xsl:text>Thread::WXWriteFromExecSetter __wx_write;</xsl:text>
+    <xsl:text>ThreadWXEnable __wx_write(WXWrite, current_thread);</xsl:text>
     <xsl:value-of select="$space"/>
     <xsl:text>ThreadInVMfromNative __tiv(current_thread);</xsl:text>
     <xsl:value-of select="$space"/>
diff --git a/src/hotspot/share/prims/jvmtiEnv.cpp b/src/hotspot/share/prims/jvmtiEnv.cpp
index 9f7d4c86429..cb1d94f11b1 100644
--- a/src/hotspot/share/prims/jvmtiEnv.cpp
+++ b/src/hotspot/share/prims/jvmtiEnv.cpp
@@ -176,8 +176,8 @@ JvmtiEnv::GetThreadLocalStorage(jthread thread, void** data_ptr) {
     // other than the current thread is required we need to transition
     // from native so as to resolve the jthread.
 
+    ThreadWXEnable __wx_write(WXWrite, current_thread);
     ThreadInVMfromNative __tiv(current_thread);
-    Thread::WXExecVerifier __wx_exec;
     VM_ENTRY_BASE(jvmtiError, JvmtiEnv::GetThreadLocalStorage , current_thread)
     debug_only(VMNativeEntryWrapper __vew;)
 
diff --git a/src/hotspot/share/prims/jvmtiExport.cpp b/src/hotspot/share/prims/jvmtiExport.cpp
index f0f09fe41fa..1098f877e5a 100644
--- a/src/hotspot/share/prims/jvmtiExport.cpp
+++ b/src/hotspot/share/prims/jvmtiExport.cpp
@@ -90,14 +90,12 @@ class JvmtiJavaThreadEventTransition : StackObj {
 private:
   ResourceMark _rm;
   ThreadToNativeFromVM _transition;
-  Thread::WXExecFromWriteSetter _wx_exec;
   HandleMark _hm;
 
 public:
   JvmtiJavaThreadEventTransition(JavaThread *thread) :
     _rm(),
     _transition(thread),
-    _wx_exec(),
     _hm(thread)  {};
 };
 
@@ -107,12 +105,11 @@ class JvmtiThreadEventTransition : StackObj {
 private:
   ResourceMark _rm;
   HandleMark _hm;
-  Thread::WXExecFromWriteSetter _wx_exec;
   JavaThreadState _saved_state;
   JavaThread *_jthread;
 
 public:
-  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm(thread), _wx_exec() {
+  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm(thread) {
     if (thread->is_Java_thread()) {
        _jthread = thread->as_Java_thread();
        _saved_state = _jthread->thread_state();
@@ -402,7 +399,6 @@ JvmtiExport::get_jvmti_interface(JavaVM *jvm, void **penv, jint version) {
     JavaThread* current_thread = JavaThread::current();
     // transition code: native to VM
     ThreadInVMfromNative __tiv(current_thread);
-    Thread::WXExecVerifier __wx_exec;
     VM_ENTRY_BASE(jvmtiEnv*, JvmtiExport::get_jvmti_interface, current_thread)
     debug_only(VMNativeEntryWrapper __vew;)
 
diff --git a/src/hotspot/share/prims/jvmtiImpl.cpp b/src/hotspot/share/prims/jvmtiImpl.cpp
index c235687f429..d7b31721f3f 100644
--- a/src/hotspot/share/prims/jvmtiImpl.cpp
+++ b/src/hotspot/share/prims/jvmtiImpl.cpp
@@ -84,7 +84,6 @@ JvmtiAgentThread::start_function_wrapper(JavaThread *thread, TRAPS) {
 void
 JvmtiAgentThread::call_start_function() {
     ThreadToNativeFromVM transition(this);
-    Thread::WXExecFromWriteSetter wx_exec;
     _start_fn(_env->jvmti_external(), jni_environment(), (void*)_start_arg);
 }
 
diff --git a/src/hotspot/share/prims/jvmtiRawMonitor.cpp b/src/hotspot/share/prims/jvmtiRawMonitor.cpp
index f5992080a50..06efea26c5f 100644
--- a/src/hotspot/share/prims/jvmtiRawMonitor.cpp
+++ b/src/hotspot/share/prims/jvmtiRawMonitor.cpp
@@ -237,7 +237,6 @@ int JvmtiRawMonitor::simple_wait(Thread* self, jlong millis) {
     JavaThread* jt = self->as_Java_thread();
     // Transition to VM so we can check interrupt state
     ThreadInVMfromNative tivm(jt);
-    Thread::WXExecVerifier wx_exec;
     if (jt->is_interrupted(true)) {
         ret = M_INTERRUPTED;
     } else {
@@ -425,7 +424,6 @@ int JvmtiRawMonitor::raw_wait(jlong millis, Thread* self) {
         simple_exit(jt);
         {
           ThreadInVMfromNative tivm(jt);
-          Thread::WXExecVerifier wx_exec;
           {
             ThreadBlockInVM tbivm(jt);
             jt->java_suspend_self();
diff --git a/src/hotspot/share/prims/methodHandles.cpp b/src/hotspot/share/prims/methodHandles.cpp
index e75daec7144..5a8bdd9ba0c 100644
--- a/src/hotspot/share/prims/methodHandles.cpp
+++ b/src/hotspot/share/prims/methodHandles.cpp
@@ -1577,7 +1577,6 @@ JVM_ENTRY(void, JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass MHN_class))
 
   {
     ThreadToNativeFromVM ttnfv(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
 
     int status = env->RegisterNatives(MHN_class, MHN_methods, sizeof(MHN_methods)/sizeof(JNINativeMethod));
     guarantee(status == JNI_OK && !env->ExceptionOccurred(),
diff --git a/src/hotspot/share/prims/nativeEntryPoint.cpp b/src/hotspot/share/prims/nativeEntryPoint.cpp
index bf4dfe40e6a..4ec84bed355 100644
--- a/src/hotspot/share/prims/nativeEntryPoint.cpp
+++ b/src/hotspot/share/prims/nativeEntryPoint.cpp
@@ -38,7 +38,6 @@ static JNINativeMethod NEP_methods[] = {
 };
 
 JNI_LEAF(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class))
-  Thread::WXExecFromWriteSetter wx_exec;
   int status = env->RegisterNatives(NEP_class, NEP_methods, sizeof(NEP_methods)/sizeof(JNINativeMethod));
   guarantee(status == JNI_OK && !env->ExceptionOccurred(),
             "register jdk.internal.invoke.NativeEntryPoint natives");
diff --git a/src/hotspot/share/prims/nativeLookup.cpp b/src/hotspot/share/prims/nativeLookup.cpp
index 5663d58f774..9641d9242d1 100644
--- a/src/hotspot/share/prims/nativeLookup.cpp
+++ b/src/hotspot/share/prims/nativeLookup.cpp
@@ -412,7 +412,6 @@ address NativeLookup::lookup_critical_entry(const methodHandle& method) {
 
   // dll handling requires I/O. Don't do that while in _thread_in_vm (safepoint may get requested).
   ThreadToNativeFromVM thread_in_native(JavaThread::current());
-  Thread::WXWriteVerifier wx_write;
 
   void* dll = dll_load(method);
   address entry = NULL;
diff --git a/src/hotspot/share/prims/perf.cpp b/src/hotspot/share/prims/perf.cpp
index 84517a8a06c..895c45200cd 100644
--- a/src/hotspot/share/prims/perf.cpp
+++ b/src/hotspot/share/prims/perf.cpp
@@ -54,8 +54,6 @@ static char* jstr_to_utf(JNIEnv *env, jstring str, TRAPS) {
     //throw_new(env,"NullPointerException");
   }
 
-  Thread::WXExecFromWriteSetter wx_exec;
-
   int len = env->GetStringUTFLength(str);
   int unicode_len = env->GetStringLength(str);
 
@@ -93,7 +91,6 @@ PERF_ENTRY(jobject, Perf_Attach(JNIEnv *env, jobject unused, jstring user, int v
 
   {
     ThreadToNativeFromVM ttnfv(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     return env->NewDirectByteBuffer(address, (jlong)capacity);
   }
 
@@ -114,7 +111,6 @@ PERF_ENTRY(void, Perf_Detach(JNIEnv *env, jobject unused, jobject buffer))
   // get buffer address and capacity
   {
    ThreadToNativeFromVM ttnfv(thread);
-   Thread::WXExecFromWriteSetter wx_exec;
    address = env->GetDirectBufferAddress(buffer);
    capacity = env->GetDirectBufferCapacity(buffer);
   }
@@ -179,7 +175,6 @@ PERF_ENTRY(jobject, Perf_CreateLong(JNIEnv *env, jobject perf, jstring name,
 
   {
     ThreadToNativeFromVM ttnfv(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     return env->NewDirectByteBuffer(lp, sizeof(jlong));
   }
 
@@ -222,8 +217,6 @@ PERF_ENTRY(jobject, Perf_CreateByteArray(JNIEnv *env, jobject perf,
 
     name_utf = jstr_to_utf(env, name, CHECK_NULL);
 
-    Thread::WXExecFromWriteSetter wx_exec;
-
     value_length = env->GetArrayLength(value);
 
     value_local = NEW_RESOURCE_ARRAY(jbyte, value_length + 1);
@@ -265,7 +258,6 @@ PERF_ENTRY(jobject, Perf_CreateByteArray(JNIEnv *env, jobject perf,
 
   {
     ThreadToNativeFromVM ttnfv(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     return env->NewDirectByteBuffer(cp, maxlength+1);
   }
 
@@ -328,7 +320,6 @@ JVM_ENTRY(void, JVM_RegisterPerfMethods(JNIEnv *env, jclass perfclass))
   PerfWrapper("JVM_RegisterPerfMethods");
   {
     ThreadToNativeFromVM ttnfv(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     int ok = env->RegisterNatives(perfclass, perfmethods, sizeof(perfmethods)/sizeof(JNINativeMethod));
     guarantee(ok == 0, "register perf natives");
   }
diff --git a/src/hotspot/share/prims/scopedMemoryAccess.cpp b/src/hotspot/share/prims/scopedMemoryAccess.cpp
index 93208df303a..3f03a25fc67 100644
--- a/src/hotspot/share/prims/scopedMemoryAccess.cpp
+++ b/src/hotspot/share/prims/scopedMemoryAccess.cpp
@@ -180,7 +180,6 @@ static JNINativeMethod jdk_internal_misc_ScopedMemoryAccess_methods[] = {
 
 JVM_ENTRY(void, JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods(JNIEnv *env, jclass scopedMemoryAccessClass))
   ThreadToNativeFromVM ttnfv(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
 
   int ok = env->RegisterNatives(scopedMemoryAccessClass, jdk_internal_misc_ScopedMemoryAccess_methods, sizeof(jdk_internal_misc_ScopedMemoryAccess_methods)/sizeof(JNINativeMethod));
   guarantee(ok == 0, "register jdk.internal.misc.ScopedMemoryAccess natives");
diff --git a/src/hotspot/share/prims/universalNativeInvoker.cpp b/src/hotspot/share/prims/universalNativeInvoker.cpp
index 09c44dcfe64..bb1bbcd4eca 100644
--- a/src/hotspot/share/prims/universalNativeInvoker.cpp
+++ b/src/hotspot/share/prims/universalNativeInvoker.cpp
@@ -56,7 +56,6 @@ static JNINativeMethod PI_methods[] = {
 };
 
 JNI_LEAF(void, JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass PI_class))
-  Thread::WXWriteFromExecSetter wx_write;
   int status = env->RegisterNatives(PI_class, PI_methods, sizeof(PI_methods)/sizeof(JNINativeMethod));
   guarantee(status == JNI_OK && !env->ExceptionOccurred(),
             "register jdk.internal.foreign.abi.programmable.ProgrammableInvoker natives");
diff --git a/src/hotspot/share/prims/unsafe.cpp b/src/hotspot/share/prims/unsafe.cpp
index b866e9da77a..00d55892b59 100644
--- a/src/hotspot/share/prims/unsafe.cpp
+++ b/src/hotspot/share/prims/unsafe.cpp
@@ -404,8 +404,8 @@ UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcOb
   void* dst = index_oop_from_field_offset_long(dstp, dstOffset);
   {
     GuardUnsafeAccess guard(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     if (StubRoutines::unsafe_arraycopy() != NULL) {
+      ThreadWXEnable wx_exec(WXExec, thread);
       StubRoutines::UnsafeArrayCopy_stub()(src, dst, sz);
     } else {
       Copy::conjoint_memory_atomic(src, dst, sz);
@@ -457,12 +457,14 @@ UNSAFE_LEAF (void, Unsafe_WriteBack0(JNIEnv *env, jobject unsafe, jlong line)) {
   }
 #endif
 
+  ThreadWXEnable wx_exec(WXExec);
   assert(StubRoutines::data_cache_writeback() != NULL, "sanity");
   (StubRoutines::DataCacheWriteback_stub())(addr_from_java(line));
 } UNSAFE_END
 
 static void doWriteBackSync0(bool is_pre)
 {
+  ThreadWXEnable wx_exec(WXExec);
   assert(StubRoutines::data_cache_writeback_sync() != NULL, "sanity");
   (StubRoutines::DataCacheWritebackSync_stub())(is_pre);
 }
@@ -718,7 +720,6 @@ static jclass Unsafe_DefineClass_impl(JNIEnv *env, jstring name, jbyteArray data
 
 UNSAFE_ENTRY(jclass, Unsafe_DefineClass0(JNIEnv *env, jobject unsafe, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd)) {
   ThreadToNativeFromVM ttnfv(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
 
   return Unsafe_DefineClass_impl(env, name, data, offset, length, loader, pd);
 } UNSAFE_END
@@ -904,7 +905,6 @@ UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, j
 
 UNSAFE_ENTRY(void, Unsafe_ThrowException(JNIEnv *env, jobject unsafe, jthrowable thr)) {
   ThreadToNativeFromVM ttnfv(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   env->Throw(thr);
 } UNSAFE_END
 
@@ -1160,7 +1160,6 @@ static JNINativeMethod jdk_internal_misc_Unsafe_methods[] = {
 
 JVM_ENTRY(void, JVM_RegisterJDKInternalMiscUnsafeMethods(JNIEnv *env, jclass unsafeclass)) {
   ThreadToNativeFromVM ttnfv(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
 
   int ok = env->RegisterNatives(unsafeclass, jdk_internal_misc_Unsafe_methods, sizeof(jdk_internal_misc_Unsafe_methods)/sizeof(JNINativeMethod));
   guarantee(ok == 0, "register jdk.internal.misc.Unsafe natives");
diff --git a/src/hotspot/share/prims/vectorSupport.cpp b/src/hotspot/share/prims/vectorSupport.cpp
index 505df9251d2..be3bb27177e 100644
--- a/src/hotspot/share/prims/vectorSupport.cpp
+++ b/src/hotspot/share/prims/vectorSupport.cpp
@@ -393,7 +393,6 @@ static JNINativeMethod jdk_internal_vm_vector_VectorSupport_methods[] = {
 
 JVM_ENTRY(void, JVM_RegisterVectorSupportMethods(JNIEnv* env, jclass vsclass)) {
   ThreadToNativeFromVM ttnfv(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
 
   int ok = env->RegisterNatives(vsclass, jdk_internal_vm_vector_VectorSupport_methods, sizeof(jdk_internal_vm_vector_VectorSupport_methods)/sizeof(JNINativeMethod));
   guarantee(ok == 0, "register jdk.internal.vm.vector.VectorSupport natives");
diff --git a/src/hotspot/share/prims/whitebox.cpp b/src/hotspot/share/prims/whitebox.cpp
index 3165be57106..535875d8a21 100644
--- a/src/hotspot/share/prims/whitebox.cpp
+++ b/src/hotspot/share/prims/whitebox.cpp
@@ -758,7 +758,6 @@ WB_END
 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
   assert(method != NULL, "method should not be null");
   ThreadToNativeFromVM ttn(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   return env->FromReflectedMethod(method);
 }
 
@@ -1147,7 +1146,6 @@ static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value) {
     return false;
   }
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, false);
   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);
@@ -1162,7 +1160,6 @@ static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value) {
     return false;
   }
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, false);
   JVMFlag* flag = JVMFlag::find_flag(flag_name);
@@ -1203,7 +1200,6 @@ static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
 
 static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, NULL);
   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);
@@ -1225,7 +1221,6 @@ WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
   bool result;
   if (GetVMFlag <JVM_FLAG_TYPE(bool)> (thread, env, name, &result)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-    Thread::WXExecFromWriteSetter wx_exec;
     return booleanBox(thread, env, result);
   }
   return NULL;
@@ -1235,7 +1230,6 @@ WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
   int result;
   if (GetVMFlag <JVM_FLAG_TYPE(int)> (thread, env, name, &result)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1245,7 +1239,6 @@ WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
   uint result;
   if (GetVMFlag <JVM_FLAG_TYPE(uint)> (thread, env, name, &result)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1255,7 +1248,6 @@ WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
   intx result;
   if (GetVMFlag <JVM_FLAG_TYPE(intx)> (thread, env, name, &result)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1265,7 +1257,6 @@ WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
   uintx result;
   if (GetVMFlag <JVM_FLAG_TYPE(uintx)> (thread, env, name, &result)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1275,7 +1266,6 @@ WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
   uint64_t result;
   if (GetVMFlag <JVM_FLAG_TYPE(uint64_t)> (thread, env, name, &result)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1285,7 +1275,6 @@ WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
   size_t result;
   if (GetVMFlag <JVM_FLAG_TYPE(size_t)> (thread, env, name, &result)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1295,7 +1284,6 @@ WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
   double result;
   if (GetVMFlag <JVM_FLAG_TYPE(double)> (thread, env, name, &result)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-    Thread::WXExecFromWriteSetter wx_exec;
     return doubleBox(thread, env, result);
   }
   return NULL;
@@ -1305,7 +1293,6 @@ WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
   ccstr ccstrResult;
   if (GetVMFlag <JVM_FLAG_TYPE(ccstr)> (thread, env, name, &ccstrResult)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-    Thread::WXExecFromWriteSetter wx_exec;
     jstring result = env->NewStringUTF(ccstrResult);
     CHECK_JNI_EXCEPTION_(env, NULL);
     return result;
@@ -1355,7 +1342,6 @@ WB_END
 
 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
-  Thread::WXExecFromWriteSetter wx_exec;
   const char* ccstrValue;
   if (value == NULL) {
     ccstrValue = NULL;
@@ -1367,7 +1353,6 @@ WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring
   ccstr ccstrResult = ccstrValue;
   bool needFree;
   {
-    Thread::WXWriteFromExecSetter wx_write;
     ThreadInVMfromNative ttvfn(thread); // back to VM
     needFree = SetVMFlag <JVM_FLAG_TYPE(ccstr)> (thread, env, name, &ccstrResult);
   }
@@ -1433,7 +1418,6 @@ WB_END
 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
   const char* features = VM_Version::features_string();
   ThreadToNativeFromVM ttn(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   jstring features_string = env->NewStringUTF(features);
 
   CHECK_JNI_EXCEPTION_(env, NULL);
@@ -1506,7 +1490,6 @@ WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jbo
   int insts_size = comp_level == CompLevel_aot ? code->code_end() - code->code_begin() : code->insts_size();
 
   ThreadToNativeFromVM ttn(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   jclass clazz = env->FindClass(vmSymbols::java_lang_Object()->as_C_string());
   CHECK_JNI_EXCEPTION_(env, NULL);
   result = env->NewObjectArray(5, clazz, NULL);
@@ -1590,7 +1573,6 @@ WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_t
     }
   }
   ThreadToNativeFromVM ttn(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   jobjectArray result = NULL;
   jclass clazz = env->FindClass(vmSymbols::java_lang_Object()->as_C_string());
   CHECK_JNI_EXCEPTION_(env, NULL);
@@ -1621,7 +1603,6 @@ WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
       "WB_GetCodeBlob: addr is null");
   }
   ThreadToNativeFromVM ttn(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   CodeBlobStub stub((CodeBlob*) addr);
   return codeBlob2objectArray(thread, env, &stub);
 WB_END
@@ -1842,7 +1823,6 @@ static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jst
   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
   // can't be in VM when we call JNI
   ThreadToNativeFromVM ttnfv(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, false);
   enum CompileCommand option = CompilerOracle::string_to_option(flag_name);
@@ -1861,7 +1841,6 @@ WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject me
   if (GetMethodOption<bool> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     return booleanBox(thread, env, result);
   }
   return NULL;
@@ -1872,7 +1851,6 @@ WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method
   if (GetMethodOption <intx> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1883,7 +1861,6 @@ WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject metho
   if (GetMethodOption <uintx> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1894,7 +1871,6 @@ WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject meth
   if (GetMethodOption <double> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     return doubleBox(thread, env, result);
   }
   return NULL;
@@ -1905,7 +1881,6 @@ WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject meth
   if (GetMethodOption <ccstr> (thread, env, method, name, &ccstrResult)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
-    Thread::WXExecFromWriteSetter wx_exec;
     jstring result = env->NewStringUTF(ccstrResult);
     CHECK_JNI_EXCEPTION_(env, NULL);
     return result;
@@ -1916,7 +1891,6 @@ WB_END
 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
   const char* p = Arguments::get_default_shared_archive_path();
   ThreadToNativeFromVM ttn(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   jstring path_string = env->NewStringUTF(p);
 
   CHECK_JNI_EXCEPTION_(env, NULL);
@@ -2129,7 +2103,6 @@ bool WhiteBox::lookup_bool(const char* field_name, oop object) {
 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
   ResourceMark rm;
   ThreadToNativeFromVM ttnfv(thread); // can't be in VM when we call JNI
-  Thread::WXExecFromWriteSetter wx_exec;
 
   //  one by one registration natives for exception catching
   jclass no_such_method_error_klass = env->FindClass(vmSymbols::java_lang_NoSuchMethodError()->as_C_string());
@@ -2161,13 +2134,11 @@ void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread,
 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
   // can't be in VM when we call JNI
   ThreadToNativeFromVM ttnfv(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   const char* dir = env->GetStringUTFChars(compDirect, NULL);
   CHECK_JNI_EXCEPTION_(env, 0);
   int ret;
   {
     ThreadInVMfromNative ttvfn(thread); // back to VM
-    Thread::WXExecVerifier wx_exec;
     ret = DirectivesParser::parse_string(dir, tty);
   }
   env->ReleaseStringUTFChars(compDirect, dir);
@@ -2188,7 +2159,6 @@ WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstri
 #ifdef LINUX
   // Can't be in VM when we call JNI.
   ThreadToNativeFromVM ttnfv(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   const char* lf = env->GetStringUTFChars(libfile, NULL);
   CHECK_JNI_EXCEPTION_(env, 0);
   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
@@ -2210,7 +2180,6 @@ WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,
   jint ret = 0;
 #ifdef LINUX
   ThreadToNativeFromVM ttnfv(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   const char* p_cgroups = env->GetStringUTFChars(proc_cgroups, NULL);
   CHECK_JNI_EXCEPTION_(env, 0);
   const char* p_s_cgroup = env->GetStringUTFChars(proc_self_cgroup, NULL);
@@ -2344,7 +2313,6 @@ WB_END
 
 WB_ENTRY(jstring, WB_GetLibcName(JNIEnv* env, jobject o))
   ThreadToNativeFromVM ttn(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   jstring info_string = env->NewStringUTF(XSTR(LIBC));
   CHECK_JNI_EXCEPTION_(env, NULL);
   return info_string;
diff --git a/src/hotspot/share/prims/whitebox.inline.hpp b/src/hotspot/share/prims/whitebox.inline.hpp
index 83d75c7f919..511ef760286 100644
--- a/src/hotspot/share/prims/whitebox.inline.hpp
+++ b/src/hotspot/share/prims/whitebox.inline.hpp
@@ -31,7 +31,8 @@
 // Entry macro to transition from JNI to VM state.
 
 #define WB_ENTRY(result_type, header) JNI_ENTRY(result_type, header) \
-  ClearPendingJniExcCheck _clearCheck(env);
+  ClearPendingJniExcCheck _clearCheck(env); \
+  ThreadWXEnable wx_write(WXWrite, thread);
 
 #define WB_END JNI_END
 
diff --git a/src/hotspot/share/runtime/deoptimization.cpp b/src/hotspot/share/runtime/deoptimization.cpp
index 7e30838da21..33b0d6361ac 100644
--- a/src/hotspot/share/runtime/deoptimization.cpp
+++ b/src/hotspot/share/runtime/deoptimization.cpp
@@ -72,6 +72,7 @@
 #include "runtime/stubRoutines.hpp"
 #include "runtime/thread.hpp"
 #include "runtime/threadSMR.hpp"
+#include "runtime/threadWXSetters.hpp"
 #include "runtime/vframe.hpp"
 #include "runtime/vframeArray.hpp"
 #include "runtime/vframe_hp.hpp"
@@ -2462,7 +2463,7 @@ Deoptimization::UnrollBlock* Deoptimization::uncommon_trap(JavaThread* thread, j
     // This enters VM and may safepoint
     uncommon_trap_inner(thread, trap_request);
   }
-  Thread::WXWriteFromExecSetter wx_write;
+  ThreadWXEnable wx_write(WXWrite, thread);
   return fetch_unroll_info_helper(thread, exec_mode);
 }
 
diff --git a/src/hotspot/share/runtime/interfaceSupport.inline.hpp b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
index b25e5759a3f..9ba8fa65b9a 100644
--- a/src/hotspot/share/runtime/interfaceSupport.inline.hpp
+++ b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
@@ -33,6 +33,7 @@
 #include "runtime/safepointMechanism.inline.hpp"
 #include "runtime/safepointVerifiers.hpp"
 #include "runtime/thread.hpp"
+#include "runtime/threadWXSetters.hpp"
 #include "runtime/vmOperations.hpp"
 #include "utilities/globalDefinitions.hpp"
 #include "utilities/macros.hpp"
@@ -289,9 +290,8 @@ class ThreadBlockInVMWithDeadlockCheck : public ThreadStateTransition {
 // from being installed on vm exit in situations where we can't tolerate them.
 // See bugs: 4324348, 4854693, 4998314, 5040492, 5050705.
 class ThreadInVMfromJavaNoAsyncException : public ThreadStateTransition {
-  Thread::WXWriteVerifier _wx_write;
  public:
-  ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread), _wx_write() {
+  ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread) {
     trans_from_java(_thread_in_vm);
   }
   ~ThreadInVMfromJavaNoAsyncException()  {
@@ -336,6 +336,7 @@ class VMNativeEntryWrapper {
 
 #define VM_LEAF_BASE(result_type, header)                            \
   debug_only(NoHandleMark __hm;)                                     \
+  ThreadWXEnable __wx_write(WXWrite);                                \
   os::verify_stack_alignment();                                      \
   /* begin of body */
 
@@ -358,7 +359,7 @@ class VMNativeEntryWrapper {
 
 #define JRT_ENTRY(result_type, header)                               \
   result_type header {                                               \
-    Thread::WXWriteFromExecSetter __wx_write;                        \
+    ThreadWXEnable __wx_write(WXWrite, thread);                      \
     ThreadInVMfromJava __tiv(thread);                                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -385,7 +386,7 @@ class VMNativeEntryWrapper {
 
 #define JRT_ENTRY_NO_ASYNC(result_type, header)                      \
   result_type header {                                               \
-    Thread::WXWriteFromExecSetter __wx_write;                        \
+    ThreadWXEnable __wx_write(WXWrite, thread);                      \
     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -394,7 +395,7 @@ class VMNativeEntryWrapper {
 // to get back into Java from the VM
 #define JRT_BLOCK_ENTRY(result_type, header)                         \
   result_type header {                                               \
-    Thread::WXWriteFromExecSetter __wx_write;                        \
+    ThreadWXEnable __wx_write(WXWrite, thread);                      \
     HandleMarkCleaner __hm(thread);
 
 #define JRT_BLOCK                                                    \
@@ -424,7 +425,7 @@ extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
     assert( !VerifyJNIEnvThread || (thread == Thread::current()), "JNIEnv is only valid in same thread"); \
-    Thread::WXWriteFromExecSetter __wx_write;                        \
+    ThreadWXEnable __wx_write(WXWrite, thread);                      \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -435,7 +436,6 @@ extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
     assert( !VerifyJNIEnvThread || (thread == Thread::current()), "JNIEnv is only valid in same thread"); \
-    Thread::WXWriteFromExecSetter __wx_write;                        \
     VM_LEAF_BASE(result_type, header)
 
 
@@ -450,7 +450,7 @@ extern "C" {                                                         \
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
-    Thread::WXWriteFromExecSetter __wx_write;                        \
+    ThreadWXEnable __wx_write(WXWrite, thread);                      \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -460,7 +460,7 @@ extern "C" {                                                         \
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread = JavaThread::current();                      \
-    Thread::WXWriteFromExecSetter __wx_write;                        \
+    ThreadWXEnable __wx_write(WXWrite, thread);                      \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -470,7 +470,6 @@ extern "C" {                                                         \
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     VM_Exit::block_if_vm_exited();                                   \
-    Thread::WXWriteFromExecSetter __wx_write;                        \
     VM_LEAF_BASE(result_type, header)
 
 
diff --git a/src/hotspot/share/runtime/javaCalls.cpp b/src/hotspot/share/runtime/javaCalls.cpp
index a634a659e8a..51f0b3cf27a 100644
--- a/src/hotspot/share/runtime/javaCalls.cpp
+++ b/src/hotspot/share/runtime/javaCalls.cpp
@@ -109,14 +109,14 @@ JavaCallWrapper::JavaCallWrapper(const methodHandle& callee_method, Handle recei
     _thread->clear_pending_exception();
   }
 
-  Thread::enable_wx_from_write(WXExec);
+  _thread->enable_wx(WXExec);
 }
 
 
 JavaCallWrapper::~JavaCallWrapper() {
   assert(_thread == JavaThread::current(), "must still be the same thread");
 
-  Thread::enable_wx_from_exec(WXWrite);
+  _thread->enable_wx(WXWrite);
 
   // restore previous handle block & Java frame linkage
   JNIHandleBlock *_old_handles = _thread->active_handles();
diff --git a/src/hotspot/share/runtime/safepoint.cpp b/src/hotspot/share/runtime/safepoint.cpp
index 53e1d814cbc..d7a01697006 100644
--- a/src/hotspot/share/runtime/safepoint.cpp
+++ b/src/hotspot/share/runtime/safepoint.cpp
@@ -65,6 +65,7 @@
 #include "runtime/synchronizer.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
+#include "runtime/threadWXSetters.hpp"
 #include "runtime/timerTrace.hpp"
 #include "services/runtimeService.hpp"
 #include "utilities/events.hpp"
@@ -758,7 +759,7 @@ void SafepointSynchronize::block(JavaThread *thread) {
 void SafepointSynchronize::handle_polling_page_exception(JavaThread *thread) {
   assert(thread->thread_state() == _thread_in_Java, "should come from Java code");
 
-  Thread::WXWriteFromExecSetter wx_write;
+  ThreadWXEnable wx_write(WXWrite, thread);
 
   if (log_is_enabled(Info, safepoint, stats)) {
     Atomic::inc(&_nof_threads_hit_polling_page);
diff --git a/src/hotspot/share/runtime/sharedRuntime.cpp b/src/hotspot/share/runtime/sharedRuntime.cpp
index dd18d56e01e..c3b5a27a1f3 100644
--- a/src/hotspot/share/runtime/sharedRuntime.cpp
+++ b/src/hotspot/share/runtime/sharedRuntime.cpp
@@ -535,7 +535,6 @@ address SharedRuntime::raw_exception_handler_for_return_address(JavaThread* thre
 
 
 JRT_LEAF(address, SharedRuntime::exception_handler_for_return_address(JavaThread* thread, address return_address))
-  Thread::WXWriteFromExecSetter wx_write;
   return raw_exception_handler_for_return_address(thread, return_address);
 JRT_END
 
@@ -1946,8 +1945,6 @@ bool SharedRuntime::should_fixup_call_destination(address destination, address e
 JRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))
   Method* moop(method);
 
-  Thread::WXWriteFromExecSetter wx_write;
-
   address entry_point = moop->from_compiled_entry_no_trampoline();
 
   // It's possible that deoptimization can occur at a call site which hasn't
diff --git a/src/hotspot/share/runtime/stubRoutines.inline.hpp b/src/hotspot/share/runtime/stubRoutines.inline.hpp
index 4ce59480300..e3773ddea56 100644
--- a/src/hotspot/share/runtime/stubRoutines.inline.hpp
+++ b/src/hotspot/share/runtime/stubRoutines.inline.hpp
@@ -26,18 +26,19 @@
 #define SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
 
 #include <runtime/thread.hpp>
+#include <runtime/threadWXSetters.hpp>
 #include <runtime/stubRoutines.hpp>
 
 // Safefetch allows to load a value from a location that's not known
 // to be valid. If the load causes a fault, the error value is returned.
 inline int SafeFetch32(int* adr, int errValue) {
   assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
-  Thread::WXExecFromWriteSetter wx_exec;
+  ThreadWXEnable wx(WXExec);
   return StubRoutines::SafeFetch32_stub()(adr, errValue);
 }
 inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
   assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
-  Thread::WXExecFromWriteSetter wx_exec;
+  ThreadWXEnable wx(WXExec);
   return StubRoutines::SafeFetchN_stub()(adr, errValue);
 }
 
diff --git a/src/hotspot/share/runtime/thread.cpp b/src/hotspot/share/runtime/thread.cpp
index 698141951d7..b20ac1f4130 100644
--- a/src/hotspot/share/runtime/thread.cpp
+++ b/src/hotspot/share/runtime/thread.cpp
@@ -106,6 +106,7 @@
 #include "runtime/threadCritical.hpp"
 #include "runtime/threadSMR.inline.hpp"
 #include "runtime/threadStatisticalInfo.hpp"
+#include "runtime/threadWXSetters.hpp"
 #include "runtime/timer.hpp"
 #include "runtime/timerTrace.hpp"
 #include "runtime/vframe.inline.hpp"
@@ -2511,7 +2512,7 @@ void JavaThread::check_safepoint_and_suspend_for_native_trans(JavaThread *thread
 // Note only the native==>VM/Java barriers can call this function and when
 // thread state is _thread_in_native_trans.
 void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {
-  Thread::WXWriteFromExecSetter wx_write;
+  ThreadWXEnable wx_write(WXWrite, thread);
 
   check_safepoint_and_suspend_for_native_trans(thread);
 
@@ -3989,7 +3990,6 @@ void Threads::shutdown_vm_agents() {
     if (unload_entry != NULL) {
       JavaThread* thread = JavaThread::current();
       ThreadToNativeFromVM ttn(thread);
-      Thread::WXExecFromWriteSetter wx_exec;
       HandleMark hm(thread);
       (*unload_entry)(&main_vm);
     }
@@ -4009,7 +4009,6 @@ void Threads::create_vm_init_libraries() {
       // Invoke the JVM_OnLoad function
       JavaThread* thread = JavaThread::current();
       ThreadToNativeFromVM ttn(thread);
-      Thread::WXExecFromWriteSetter wx_exec;
       HandleMark hm(thread);
       jint err = (*on_load_entry)(&main_vm, agent->options(), NULL);
       if (err != JNI_OK) {
diff --git a/src/hotspot/share/runtime/thread.hpp b/src/hotspot/share/runtime/thread.hpp
index 9159e7db2f2..50fc536f011 100644
--- a/src/hotspot/share/runtime/thread.hpp
+++ b/src/hotspot/share/runtime/thread.hpp
@@ -839,80 +839,32 @@ class Thread: public ThreadShadow {
   static void SpinAcquire(volatile int * Lock, const char * Name);
   static void SpinRelease(volatile int * Lock);
 
+#if defined(__APPLE__) && defined(AARCH64)
 private:
-#ifdef ASSERT
-  bool _wx_init;
+  DEBUG_ONLY(bool _wx_init);
   WXMode _wx_state;
-  static inline void verify_wx_init(WXMode state) {
-    Thread* current = Thread::current();
-    assert(!current->_wx_init, "second init");
-    current->_wx_init = true;
-    current->_wx_state = state;
-  }
-  static inline void verify_wx_transition(WXMode from, WXMode to) {
-    Thread* current = Thread::current();
-    assert(current->_wx_init, "no init");
-    assert(current->_wx_state == from, "wrong state");
-    current->_wx_init = true;
-    current->_wx_state = to;
-  }
-  static inline void verify_wx_state(WXMode now) {
-    Thread* current = Thread::current();
-    assert(current->_wx_init, "no init");
-    assert(current->_wx_state == now, "wrong state");
-  }
-#else
-  static inline void verify_wx_init(WXMode state) { }
-  static inline void verify_wx_transition(WXMode from, WXMode to) { }
-  static inline void verify_wx_state(WXMode now) { }
-#endif // ASSERT
 public:
   void init_wx() {
-    WXMode init_mode = WXWrite;
-    verify_wx_init(init_mode);
-    os::current_thread_enable_wx(init_mode);
-  }
-  static inline void enable_wx_from_write(WXMode to) {
-    verify_wx_transition(WXWrite, to);
-    os::current_thread_enable_wx(to);
-  }
-  static inline void enable_wx_from_exec(WXMode to) {
-    verify_wx_transition(WXExec, to);
-    os::current_thread_enable_wx(to);
-  }
-
-  class WXWriteFromExecSetter {
-  public:
-    WXWriteFromExecSetter() {
-      enable_wx_from_exec(WXWrite);
-    }
-    ~WXWriteFromExecSetter() {
-      enable_wx_from_write(WXExec);
-    }
-  };
-
-  class WXExecFromWriteSetter {
-  public:
-    WXExecFromWriteSetter() {
-      enable_wx_from_write(WXExec);
-    }
-    ~WXExecFromWriteSetter() {
-      enable_wx_from_exec(WXWrite);
+    assert(this == Thread::current(), "should only be called for current thread");
+    assert(!_wx_init, "second init");
+    _wx_state = WXWrite;
+    os::current_thread_enable_wx(_wx_state);
+    DEBUG_ONLY(_wx_init = true);
+  }
+  WXMode enable_wx(WXMode new_state) {
+    assert(this == Thread::current(), "should only be called for current thread");
+    assert(_wx_init, "should be inited");
+    WXMode old = _wx_state;
+    if (_wx_state != new_state) {
+      _wx_state = new_state;
+      os::current_thread_enable_wx(new_state);
     }
-  };
-
-  class WXWriteVerifier {
-  public:
-    WXWriteVerifier() {
-      verify_wx_state(WXWrite);
-    }
-  };
-  class WXExecVerifier {
-  public:
-    WXExecVerifier() {
-      verify_wx_state(WXExec);
-    }
-  };
+    return old;
+  }
+#else
+  void init_wx() { }
+  void enable_wx(WXMode new_state) { }
+#endif
 };
 
 // Inline implementation of Thread::current()
diff --git a/src/hotspot/share/runtime/threadWXSetters.hpp b/src/hotspot/share/runtime/threadWXSetters.hpp
new file mode 100644
index 00000000000..8eb64f6fb99
--- /dev/null
+++ b/src/hotspot/share/runtime/threadWXSetters.hpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_RUNTIME_THREADWXSETTERS_HPP
+#define SHARE_RUNTIME_THREADWXSETTERS_HPP
+
+#include "runtime/thread.hpp"
+
+class ThreadWXEnable  {
+  Thread* _thread;
+  WXMode _old_mode;
+
+public:
+  ThreadWXEnable(WXMode new_mode, Thread* thread = NULL) :
+    _thread(thread ? thread : Thread::current()),
+    _old_mode(_thread->enable_wx(new_mode))
+  { }
+
+  ~ThreadWXEnable() {
+    _thread->enable_wx(_old_mode);
+  }
+};
+
+#endif // SHARE_RUNTIME_THREADWXSETTERS_HPP
+
diff --git a/src/hotspot/share/services/diagnosticCommand.cpp b/src/hotspot/share/services/diagnosticCommand.cpp
index e99d108e9d8..e68ea46b806 100644
--- a/src/hotspot/share/services/diagnosticCommand.cpp
+++ b/src/hotspot/share/services/diagnosticCommand.cpp
@@ -1089,7 +1089,6 @@ void DebugOnCmdStartDCmd::execute(DCmdSource source, TRAPS) {
   JavaThread* thread = THREAD->as_Java_thread();
   jthread jt = JNIHandles::make_local(thread->threadObj());
   ThreadToNativeFromVM ttn(thread);
-  Thread::WXExecFromWriteSetter wx_exec;
   const char *error = "Could not find jdwp agent.";
 
   if (!dvc_start_ptr) {

From 741d0701f36fa8b04fdff435f1a2d3b5042307c2 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 2 Feb 2021 07:19:18 -0800
Subject: [PATCH 60/94] Add W^X to tests

---
 test/hotspot/gtest/gtestMain.cpp | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/test/hotspot/gtest/gtestMain.cpp b/test/hotspot/gtest/gtestMain.cpp
index c52e64ac107..ab9c1b0921b 100644
--- a/test/hotspot/gtest/gtestMain.cpp
+++ b/test/hotspot/gtest/gtestMain.cpp
@@ -38,6 +38,8 @@
 #include "jni.h"
 #include "unittest.hpp"
 
+#include "runtime/thread.hpp"
+
 // Default value for -new-thread option: true on AIX because we run into
 // problems when attempting to initialize the JVM on the primordial thread.
 #ifdef _AIX
@@ -91,7 +93,14 @@ static int init_jvm(int argc, char **argv, bool disable_error_handling) {
   JavaVM* jvm;
   JNIEnv* env;
 
-  return JNI_CreateJavaVM(&jvm, (void**)&env, &args);
+  int ret = JNI_CreateJavaVM(&jvm, (void**)&env, &args);
+  if (ret == JNI_OK) {
+    // CreateJavaVM leaves WXExec context, while gtests
+    // calls internal functions assuming running in WXWwrite.
+    // Switch to WXWrite once for all test cases.
+    Thread::current()->enable_wx(WXWrite);
+  }
+  return ret;
 }
 
 static bool is_same_vm_test(const char* name) {

From e218beb54f136c0151bd83467a2c8f0f46fd0f9f Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Wed, 3 Feb 2021 04:49:37 -0800
Subject: [PATCH 61/94] Use macro conditionals instead of empty functions

---
 src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp     |  6 ----
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.cpp     |  2 +-
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.hpp     |  6 ----
 src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp     |  6 ----
 src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp   |  6 ----
 .../os_cpu/linux_aarch64/os_linux_aarch64.hpp |  6 ----
 src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp |  6 ----
 src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp |  6 ----
 .../os_cpu/linux_s390/os_linux_s390.hpp       |  6 ----
 src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp |  6 ----
 .../os_cpu/linux_zero/os_linux_zero.hpp       |  6 ----
 .../windows_aarch64/os_windows_aarch64.hpp    |  6 ----
 .../os_cpu/windows_x86/os_windows_x86.hpp     |  6 ----
 src/hotspot/share/c1/c1_Runtime1.cpp          |  2 +-
 .../share/gc/shared/barrierSetNMethod.cpp     |  2 +-
 .../share/interpreter/interpreterRuntime.cpp  |  2 +-
 src/hotspot/share/jvmci/jvmciCompilerToVM.cpp | 10 +++----
 src/hotspot/share/opto/runtime.cpp            |  2 +-
 src/hotspot/share/prims/jni.cpp               |  8 +++---
 src/hotspot/share/prims/jniCheck.cpp          |  2 +-
 src/hotspot/share/prims/jvmtiEnter.xsl        |  2 +-
 src/hotspot/share/prims/jvmtiEnv.cpp          |  2 +-
 src/hotspot/share/prims/unsafe.cpp            |  6 ++--
 src/hotspot/share/prims/whitebox.inline.hpp   |  2 +-
 src/hotspot/share/runtime/deoptimization.cpp  |  2 +-
 .../share/runtime/interfaceSupport.inline.hpp | 14 +++++-----
 src/hotspot/share/runtime/javaCalls.cpp       |  4 +--
 src/hotspot/share/runtime/os.hpp              |  9 +++---
 src/hotspot/share/runtime/safepoint.cpp       |  2 +-
 src/hotspot/share/runtime/stubRoutines.cpp    |  4 +--
 .../share/runtime/stubRoutines.inline.hpp     |  4 +--
 src/hotspot/share/runtime/thread.cpp          | 10 +++----
 src/hotspot/share/runtime/thread.hpp          | 28 ++++---------------
 src/hotspot/share/runtime/thread.inline.hpp   | 21 ++++++++++++++
 src/hotspot/share/runtime/threadWXSetters.hpp |  6 ++--
 src/hotspot/share/utilities/macros.hpp        |  2 ++
 test/hotspot/gtest/gtestMain.cpp              |  4 +--
 37 files changed, 78 insertions(+), 146 deletions(-)

diff --git a/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp b/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp
index e8b16b4ad59..a3d89699135 100644
--- a/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp
+++ b/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp
@@ -36,10 +36,4 @@
 static bool platform_print_native_stack(outputStream* st, void* context,
                                         char *buf, int buf_size);
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-public:
-
 #endif // OS_CPU_AIX_PPC_OS_AIX_PPC_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index 812127920e2..9bae00a356c 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -661,7 +661,7 @@ int os::extra_bang_size_in_bytes() {
   return 0;
 }
 
-void os::current_thread_enable_wx_impl(WXMode mode) {
+void os::current_thread_enable_wx(WXMode mode) {
   pthread_jit_write_protect_np(mode == WXExec);
 }
 
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
index 821728697e6..56bb1f4e70c 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
@@ -34,12 +34,6 @@
   // Note: Currently only used in 64 bit Windows implementations
   static bool register_code_area(char *low, char *high) { return true; }
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode);
-
-public:
-
   // Atomically copy 64 bits of data
   static void atomic_copy64(const volatile void *src, volatile void *dst) {
     *(jlong *) dst = *(const jlong *) src;
diff --git a/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp b/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp
index 19a62da5585..bd7ad6344f9 100644
--- a/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp
+++ b/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp
@@ -37,10 +37,4 @@
   // Note: Currently only used in 64 bit Windows implementations
   static bool register_code_area(char *low, char *high) { return true; }
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-public:
-
 #endif // OS_CPU_BSD_X86_OS_BSD_X86_HPP
diff --git a/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp b/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp
index 9914eb031a0..511400ae0d2 100644
--- a/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp
+++ b/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp
@@ -53,10 +53,4 @@
 #endif
   }
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-public:
-
 #endif // OS_CPU_BSD_ZERO_OS_BSD_ZERO_HPP
diff --git a/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp b/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp
index a3e935da386..c341be21185 100644
--- a/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp
+++ b/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp
@@ -39,10 +39,4 @@
     *(jlong *) dst = *(const jlong *) src;
   }
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-public:
-
 #endif // OS_CPU_LINUX_AARCH64_OS_LINUX_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp b/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp
index 95087836868..9c5d629b095 100644
--- a/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp
+++ b/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp
@@ -70,10 +70,4 @@
                                            int32_t exchange_value,
                                            volatile int32_t *dest);
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-public:
-
 #endif // OS_CPU_LINUX_ARM_OS_LINUX_ARM_HPP
diff --git a/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp b/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp
index 6644e727a0b..1c108de12a0 100644
--- a/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp
+++ b/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp
@@ -32,10 +32,4 @@
   // Note: Currently only used in 64 bit Windows implementations
   static bool register_code_area(char *low, char *high) { return true; }
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-public:
-
 #endif // OS_CPU_LINUX_PPC_OS_LINUX_PPC_HPP
diff --git a/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp b/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp
index 2417f7b17ff..35618f4e8f4 100644
--- a/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp
+++ b/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp
@@ -31,10 +31,4 @@
   // Used to register dynamic code cache area with the OS.
   static bool register_code_area(char *low, char *high) { return true; }
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-public:
-
 #endif // OS_CPU_LINUX_S390_OS_LINUX_S390_HPP
diff --git a/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp b/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp
index 6a8525c7301..a60394f9a73 100644
--- a/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp
+++ b/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp
@@ -50,10 +50,4 @@
    */
   static void workaround_expand_exec_shield_cs_limit();
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-public:
-
 #endif // OS_CPU_LINUX_X86_OS_LINUX_X86_HPP
diff --git a/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp b/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp
index 3d170f55cdc..9d4e0808551 100644
--- a/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp
+++ b/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp
@@ -90,10 +90,4 @@
 #endif
   }
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-private:
-
 #endif // OS_CPU_LINUX_ZERO_OS_LINUX_ZERO_HPP
diff --git a/src/hotspot/os_cpu/windows_aarch64/os_windows_aarch64.hpp b/src/hotspot/os_cpu/windows_aarch64/os_windows_aarch64.hpp
index 7088a1797d6..fedf5848f9e 100644
--- a/src/hotspot/os_cpu/windows_aarch64/os_windows_aarch64.hpp
+++ b/src/hotspot/os_cpu/windows_aarch64/os_windows_aarch64.hpp
@@ -33,10 +33,4 @@
     return true;
   }
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-public:
-
 #endif // OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp b/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp
index 867ddb23099..7fdd068219c 100644
--- a/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp
+++ b/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp
@@ -43,10 +43,4 @@ static bool platform_print_native_stack(outputStream* st, const void* context,
                                         char *buf, int buf_size);
 #endif
 
-private:
-
-  static void current_thread_enable_wx_impl(WXMode mode) { }
-
-public:
-
 #endif // OS_CPU_WINDOWS_X86_OS_WINDOWS_X86_HPP
diff --git a/src/hotspot/share/c1/c1_Runtime1.cpp b/src/hotspot/share/c1/c1_Runtime1.cpp
index 90b91f651fa..fd2a3d14a1c 100644
--- a/src/hotspot/share/c1/c1_Runtime1.cpp
+++ b/src/hotspot/share/c1/c1_Runtime1.cpp
@@ -1268,7 +1268,7 @@ JRT_END
 void Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id) {
   NOT_PRODUCT(_patch_code_slowcase_cnt++);
 
-  ThreadWXEnable wx_write(WXWrite, thread);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
 
   if (TracePatching) {
     tty->print_cr("Deoptimizing because patch is needed");
diff --git a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
index f767c42b4c0..2dc2cdb32b6 100644
--- a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
+++ b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
@@ -49,7 +49,7 @@ bool BarrierSetNMethod::supports_entry_barrier(nmethod* nm) {
 }
 
 int BarrierSetNMethod::nmethod_stub_entry_barrier(address* return_address_ptr) {
-  ThreadWXEnable wx_write(WXWrite);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite));
 
   address return_address = *return_address_ptr;
   CodeBlob* cb = CodeCache::find_blob(return_address);
diff --git a/src/hotspot/share/interpreter/interpreterRuntime.cpp b/src/hotspot/share/interpreter/interpreterRuntime.cpp
index c6ed34b590f..af26d1f3617 100644
--- a/src/hotspot/share/interpreter/interpreterRuntime.cpp
+++ b/src/hotspot/share/interpreter/interpreterRuntime.cpp
@@ -970,7 +970,7 @@ JRT_END
 
 
 nmethod* InterpreterRuntime::frequency_counter_overflow(JavaThread* thread, address branch_bcp) {
-  ThreadWXEnable wx_write(WXWrite, thread);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
 
   // frequency_counter_overflow_inner can throw async exception.
   nmethod* nm = frequency_counter_overflow_inner(thread, branch_bcp);
diff --git a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
index 1b121dce4b4..adcb1a3074e 100644
--- a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
+++ b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
@@ -124,11 +124,11 @@ Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 }
 
 // Bring the JVMCI compiler thread into the VM state.
-#define JVMCI_VM_ENTRY_MARK                   \
-  ThreadWXEnable __wx_write(WXWrite, thread); \
-  ThreadInVMfromNative __tiv(thread);         \
-  HandleMarkCleaner __hm(thread);             \
-  Thread* THREAD = thread;                    \
+#define JVMCI_VM_ENTRY_MARK                                       \
+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread)); \
+  ThreadInVMfromNative __tiv(thread);                             \
+  HandleMarkCleaner __hm(thread);                                 \
+  Thread* THREAD = thread;                                        \
   debug_only(VMNativeEntryWrapper __vew;)
 
 // Native method block that transitions current thread to '_thread_in_vm'.
diff --git a/src/hotspot/share/opto/runtime.cpp b/src/hotspot/share/opto/runtime.cpp
index f164450610c..7bd3b43f54a 100644
--- a/src/hotspot/share/opto/runtime.cpp
+++ b/src/hotspot/share/opto/runtime.cpp
@@ -1427,7 +1427,7 @@ address OptoRuntime::rethrow_C(oopDesc* exception, JavaThread* thread, address r
   }
 #endif
 
-  ThreadWXEnable wx_write(WXWrite, thread);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
 
   thread->set_vm_result(exception);
   // Frame not compiled (handles deoptimization blob)
diff --git a/src/hotspot/share/prims/jni.cpp b/src/hotspot/share/prims/jni.cpp
index bca8aaf1f15..deb2661530f 100644
--- a/src/hotspot/share/prims/jni.cpp
+++ b/src/hotspot/share/prims/jni.cpp
@@ -3640,7 +3640,7 @@ static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
 
     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
-    thread->enable_wx(WXExec);
+    MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));
   } else {
     // If create_vm exits because of a pending exception, exit with that
     // exception.  In the future when we figure out how to reclaim memory,
@@ -3792,7 +3792,7 @@ static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool dae
   thread->record_stack_base_and_size();
   thread->register_thread_stack_with_NMT();
   thread->initialize_thread_current();
-  thread->init_wx();
+  MACOS_AARCH64_ONLY(thread->init_wx());
 
   if (!os::create_attached_thread(thread)) {
     thread->smr_delete();
@@ -3866,7 +3866,7 @@ static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool dae
   // needed.
 
   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
-  thread->enable_wx(WXExec);
+  MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));
 
   // Perform any platform dependent FPU setup
   os::setup_fpu();
@@ -3936,7 +3936,7 @@ jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
 
   // Go to the execute mode, the initial state of the thread on creation.
   // Use os interface as the thread is not a java one anymore.
-  os::current_thread_enable_wx(WXExec);
+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));
 
   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
   return JNI_OK;
diff --git a/src/hotspot/share/prims/jniCheck.cpp b/src/hotspot/share/prims/jniCheck.cpp
index 403dab2d445..573224f37c2 100644
--- a/src/hotspot/share/prims/jniCheck.cpp
+++ b/src/hotspot/share/prims/jniCheck.cpp
@@ -104,7 +104,7 @@ extern "C" {                                                             \
     if (env != xenv) {                                                   \
       NativeReportJNIFatalError(thr, warn_wrong_jnienv);                 \
     }                                                                    \
-    ThreadWXEnable __wx_write(WXWrite, thr);                             \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thr));         \
     VM_ENTRY_BASE(result_type, header, thr)
 
 
diff --git a/src/hotspot/share/prims/jvmtiEnter.xsl b/src/hotspot/share/prims/jvmtiEnter.xsl
index b5730d74397..f41a69cae57 100644
--- a/src/hotspot/share/prims/jvmtiEnter.xsl
+++ b/src/hotspot/share/prims/jvmtiEnter.xsl
@@ -433,7 +433,7 @@ struct jvmtiInterface_1_ jvmti</xsl:text>
   <xsl:if test="count(@impl)=0 or not(contains(@impl,'innative'))">
     <xsl:text>JavaThread* current_thread = this_thread->as_Java_thread();</xsl:text>
     <xsl:value-of select="$space"/>
-    <xsl:text>ThreadWXEnable __wx_write(WXWrite, current_thread);</xsl:text>
+    <xsl:text>MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, current_thread));</xsl:text>
     <xsl:value-of select="$space"/>
     <xsl:text>ThreadInVMfromNative __tiv(current_thread);</xsl:text>
     <xsl:value-of select="$space"/>
diff --git a/src/hotspot/share/prims/jvmtiEnv.cpp b/src/hotspot/share/prims/jvmtiEnv.cpp
index cb1d94f11b1..d4a8065c20c 100644
--- a/src/hotspot/share/prims/jvmtiEnv.cpp
+++ b/src/hotspot/share/prims/jvmtiEnv.cpp
@@ -176,7 +176,7 @@ JvmtiEnv::GetThreadLocalStorage(jthread thread, void** data_ptr) {
     // other than the current thread is required we need to transition
     // from native so as to resolve the jthread.
 
-    ThreadWXEnable __wx_write(WXWrite, current_thread);
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, current_thread));
     ThreadInVMfromNative __tiv(current_thread);
     VM_ENTRY_BASE(jvmtiError, JvmtiEnv::GetThreadLocalStorage , current_thread)
     debug_only(VMNativeEntryWrapper __vew;)
diff --git a/src/hotspot/share/prims/unsafe.cpp b/src/hotspot/share/prims/unsafe.cpp
index 00d55892b59..06c226920dc 100644
--- a/src/hotspot/share/prims/unsafe.cpp
+++ b/src/hotspot/share/prims/unsafe.cpp
@@ -405,7 +405,7 @@ UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcOb
   {
     GuardUnsafeAccess guard(thread);
     if (StubRoutines::unsafe_arraycopy() != NULL) {
-      ThreadWXEnable wx_exec(WXExec, thread);
+      MACOS_AARCH64_ONLY(ThreadWXEnable wx_exec(WXExec, thread));
       StubRoutines::UnsafeArrayCopy_stub()(src, dst, sz);
     } else {
       Copy::conjoint_memory_atomic(src, dst, sz);
@@ -457,14 +457,14 @@ UNSAFE_LEAF (void, Unsafe_WriteBack0(JNIEnv *env, jobject unsafe, jlong line)) {
   }
 #endif
 
-  ThreadWXEnable wx_exec(WXExec);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx_exec(WXExec));
   assert(StubRoutines::data_cache_writeback() != NULL, "sanity");
   (StubRoutines::DataCacheWriteback_stub())(addr_from_java(line));
 } UNSAFE_END
 
 static void doWriteBackSync0(bool is_pre)
 {
-  ThreadWXEnable wx_exec(WXExec);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx_exec(WXExec));
   assert(StubRoutines::data_cache_writeback_sync() != NULL, "sanity");
   (StubRoutines::DataCacheWritebackSync_stub())(is_pre);
 }
diff --git a/src/hotspot/share/prims/whitebox.inline.hpp b/src/hotspot/share/prims/whitebox.inline.hpp
index 511ef760286..cde38853dc3 100644
--- a/src/hotspot/share/prims/whitebox.inline.hpp
+++ b/src/hotspot/share/prims/whitebox.inline.hpp
@@ -32,7 +32,7 @@
 
 #define WB_ENTRY(result_type, header) JNI_ENTRY(result_type, header) \
   ClearPendingJniExcCheck _clearCheck(env); \
-  ThreadWXEnable wx_write(WXWrite, thread);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
 
 #define WB_END JNI_END
 
diff --git a/src/hotspot/share/runtime/deoptimization.cpp b/src/hotspot/share/runtime/deoptimization.cpp
index 33b0d6361ac..fb71494917f 100644
--- a/src/hotspot/share/runtime/deoptimization.cpp
+++ b/src/hotspot/share/runtime/deoptimization.cpp
@@ -2463,7 +2463,7 @@ Deoptimization::UnrollBlock* Deoptimization::uncommon_trap(JavaThread* thread, j
     // This enters VM and may safepoint
     uncommon_trap_inner(thread, trap_request);
   }
-  ThreadWXEnable wx_write(WXWrite, thread);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
   return fetch_unroll_info_helper(thread, exec_mode);
 }
 
diff --git a/src/hotspot/share/runtime/interfaceSupport.inline.hpp b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
index 9ba8fa65b9a..3af5796359c 100644
--- a/src/hotspot/share/runtime/interfaceSupport.inline.hpp
+++ b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
@@ -336,7 +336,7 @@ class VMNativeEntryWrapper {
 
 #define VM_LEAF_BASE(result_type, header)                            \
   debug_only(NoHandleMark __hm;)                                     \
-  ThreadWXEnable __wx_write(WXWrite);                                \
+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite));            \
   os::verify_stack_alignment();                                      \
   /* begin of body */
 
@@ -359,7 +359,7 @@ class VMNativeEntryWrapper {
 
 #define JRT_ENTRY(result_type, header)                               \
   result_type header {                                               \
-    ThreadWXEnable __wx_write(WXWrite, thread);                      \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
     ThreadInVMfromJava __tiv(thread);                                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -386,7 +386,7 @@ class VMNativeEntryWrapper {
 
 #define JRT_ENTRY_NO_ASYNC(result_type, header)                      \
   result_type header {                                               \
-    ThreadWXEnable __wx_write(WXWrite, thread);                      \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -395,7 +395,7 @@ class VMNativeEntryWrapper {
 // to get back into Java from the VM
 #define JRT_BLOCK_ENTRY(result_type, header)                         \
   result_type header {                                               \
-    ThreadWXEnable __wx_write(WXWrite, thread);                      \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
     HandleMarkCleaner __hm(thread);
 
 #define JRT_BLOCK                                                    \
@@ -425,7 +425,7 @@ extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
     assert( !VerifyJNIEnvThread || (thread == Thread::current()), "JNIEnv is only valid in same thread"); \
-    ThreadWXEnable __wx_write(WXWrite, thread);                      \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -450,7 +450,7 @@ extern "C" {                                                         \
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
-    ThreadWXEnable __wx_write(WXWrite, thread);                      \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -460,7 +460,7 @@ extern "C" {                                                         \
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread = JavaThread::current();                      \
-    ThreadWXEnable __wx_write(WXWrite, thread);                      \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
diff --git a/src/hotspot/share/runtime/javaCalls.cpp b/src/hotspot/share/runtime/javaCalls.cpp
index 51f0b3cf27a..d86b3780327 100644
--- a/src/hotspot/share/runtime/javaCalls.cpp
+++ b/src/hotspot/share/runtime/javaCalls.cpp
@@ -109,14 +109,14 @@ JavaCallWrapper::JavaCallWrapper(const methodHandle& callee_method, Handle recei
     _thread->clear_pending_exception();
   }
 
-  _thread->enable_wx(WXExec);
+  MACOS_AARCH64_ONLY(_thread->enable_wx(WXExec));
 }
 
 
 JavaCallWrapper::~JavaCallWrapper() {
   assert(_thread == JavaThread::current(), "must still be the same thread");
 
-  _thread->enable_wx(WXWrite);
+  MACOS_AARCH64_ONLY(_thread->enable_wx(WXWrite));
 
   // restore previous handle block & Java frame linkage
   JNIHandleBlock *_old_handles = _thread->active_handles();
diff --git a/src/hotspot/share/runtime/os.hpp b/src/hotspot/share/runtime/os.hpp
index 7b33f9aec12..8722524c4e7 100644
--- a/src/hotspot/share/runtime/os.hpp
+++ b/src/hotspot/share/runtime/os.hpp
@@ -932,11 +932,10 @@ class os: AllStatic {
     bool _done;
   };
 
-  // If the JVM is running in W^X mode, enable write or execute access to
-  // writeable and executable pages. No-op otherwise.
-  static inline void current_thread_enable_wx(WXMode mode) {
-    current_thread_enable_wx_impl(mode);
-  }
+#if defined(__APPLE__) && defined(AARCH64)
+  // Enables write or execute access to writeable and executable pages.
+  static void current_thread_enable_wx(WXMode mode);
+#endif // __APPLE__ && AARCH64
 
 #ifndef _WINDOWS
   // Suspend/resume support
diff --git a/src/hotspot/share/runtime/safepoint.cpp b/src/hotspot/share/runtime/safepoint.cpp
index d7a01697006..334c0231e90 100644
--- a/src/hotspot/share/runtime/safepoint.cpp
+++ b/src/hotspot/share/runtime/safepoint.cpp
@@ -759,7 +759,7 @@ void SafepointSynchronize::block(JavaThread *thread) {
 void SafepointSynchronize::handle_polling_page_exception(JavaThread *thread) {
   assert(thread->thread_state() == _thread_in_Java, "should come from Java code");
 
-  ThreadWXEnable wx_write(WXWrite, thread);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
 
   if (log_is_enabled(Info, safepoint, stats)) {
     Atomic::inc(&_nof_threads_hit_polling_page);
diff --git a/src/hotspot/share/runtime/stubRoutines.cpp b/src/hotspot/share/runtime/stubRoutines.cpp
index c415f062e03..58a834d72bb 100644
--- a/src/hotspot/share/runtime/stubRoutines.cpp
+++ b/src/hotspot/share/runtime/stubRoutines.cpp
@@ -286,7 +286,7 @@ void StubRoutines::initialize2() {
 
 #ifdef ASSERT
 
-  os::current_thread_enable_wx(WXExec);
+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));
 
 #define TEST_ARRAYCOPY(type)                                                    \
   test_arraycopy_func(          type##_arraycopy(),          sizeof(type));     \
@@ -361,7 +361,7 @@ void StubRoutines::initialize2() {
   test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::aligned_conjoint_words), sizeof(jlong));
   test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::aligned_disjoint_words), sizeof(jlong));
 
-  os::current_thread_enable_wx(WXWrite);
+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));
 
 #endif
 }
diff --git a/src/hotspot/share/runtime/stubRoutines.inline.hpp b/src/hotspot/share/runtime/stubRoutines.inline.hpp
index e3773ddea56..b501a130039 100644
--- a/src/hotspot/share/runtime/stubRoutines.inline.hpp
+++ b/src/hotspot/share/runtime/stubRoutines.inline.hpp
@@ -33,12 +33,12 @@
 // to be valid. If the load causes a fault, the error value is returned.
 inline int SafeFetch32(int* adr, int errValue) {
   assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
-  ThreadWXEnable wx(WXExec);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
   return StubRoutines::SafeFetch32_stub()(adr, errValue);
 }
 inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
   assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
-  ThreadWXEnable wx(WXExec);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
   return StubRoutines::SafeFetchN_stub()(adr, errValue);
 }
 
diff --git a/src/hotspot/share/runtime/thread.cpp b/src/hotspot/share/runtime/thread.cpp
index b20ac1f4130..08005fd6f0f 100644
--- a/src/hotspot/share/runtime/thread.cpp
+++ b/src/hotspot/share/runtime/thread.cpp
@@ -326,7 +326,7 @@ Thread::Thread() {
     assert(Thread::current_or_null() == NULL, "creating thread before barrier set");
   }
 
-  DEBUG_ONLY(_wx_init = false);
+  MACOS_AARCH64_ONLY(DEBUG_ONLY(_wx_init = false));
 }
 
 void Thread::initialize_tlab() {
@@ -390,7 +390,7 @@ void Thread::call_run() {
 
   register_thread_stack_with_NMT();
 
-  this->init_wx();
+  MACOS_AARCH64_ONLY(this->init_wx());
 
   JFR_ONLY(Jfr::on_thread_start(this);)
 
@@ -2512,7 +2512,7 @@ void JavaThread::check_safepoint_and_suspend_for_native_trans(JavaThread *thread
 // Note only the native==>VM/Java barriers can call this function and when
 // thread state is _thread_in_native_trans.
 void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {
-  ThreadWXEnable wx_write(WXWrite, thread);
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
 
   check_safepoint_and_suspend_for_native_trans(thread);
 
@@ -3450,7 +3450,7 @@ jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) {
   // Initialize the os module
   os::init();
 
-  os::current_thread_enable_wx(WXWrite);
+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));
 
   // Record VM creation timing statistics
   TraceVmCreationTime create_vm_timer;
@@ -3555,7 +3555,7 @@ jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) {
   main_thread->record_stack_base_and_size();
   main_thread->register_thread_stack_with_NMT();
   main_thread->set_active_handles(JNIHandleBlock::allocate_block());
-  main_thread->init_wx();
+  MACOS_AARCH64_ONLY(main_thread->init_wx());
 
   if (!main_thread->set_as_starting_thread()) {
     vm_shutdown_during_initialization(
diff --git a/src/hotspot/share/runtime/thread.hpp b/src/hotspot/share/runtime/thread.hpp
index 50fc536f011..580737a0221 100644
--- a/src/hotspot/share/runtime/thread.hpp
+++ b/src/hotspot/share/runtime/thread.hpp
@@ -840,31 +840,13 @@ class Thread: public ThreadShadow {
   static void SpinRelease(volatile int * Lock);
 
 #if defined(__APPLE__) && defined(AARCH64)
-private:
+ private:
   DEBUG_ONLY(bool _wx_init);
   WXMode _wx_state;
-public:
-  void init_wx() {
-    assert(this == Thread::current(), "should only be called for current thread");
-    assert(!_wx_init, "second init");
-    _wx_state = WXWrite;
-    os::current_thread_enable_wx(_wx_state);
-    DEBUG_ONLY(_wx_init = true);
-  }
-  WXMode enable_wx(WXMode new_state) {
-    assert(this == Thread::current(), "should only be called for current thread");
-    assert(_wx_init, "should be inited");
-    WXMode old = _wx_state;
-    if (_wx_state != new_state) {
-      _wx_state = new_state;
-      os::current_thread_enable_wx(new_state);
-    }
-    return old;
-  }
-#else
-  void init_wx() { }
-  void enable_wx(WXMode new_state) { }
-#endif
+ public:
+  void init_wx();
+  WXMode enable_wx(WXMode new_state);
+#endif // __APPLE__ && AARCH64
 };
 
 // Inline implementation of Thread::current()
diff --git a/src/hotspot/share/runtime/thread.inline.hpp b/src/hotspot/share/runtime/thread.inline.hpp
index e072ce90d5a..658f67dd735 100644
--- a/src/hotspot/share/runtime/thread.inline.hpp
+++ b/src/hotspot/share/runtime/thread.inline.hpp
@@ -94,6 +94,27 @@ inline void Thread::set_threads_hazard_ptr(ThreadsList* new_list) {
   Atomic::release_store_fence(&_threads_hazard_ptr, new_list);
 }
 
+#if defined(__APPLE__) && defined(AARCH64)
+inline void Thread::init_wx() {
+  assert(this == Thread::current(), "should only be called for current thread");
+  assert(!_wx_init, "second init");
+  _wx_state = WXWrite;
+  os::current_thread_enable_wx(_wx_state);
+  DEBUG_ONLY(_wx_init = true);
+}
+
+inline WXMode Thread::enable_wx(WXMode new_state) {
+  assert(this == Thread::current(), "should only be called for current thread");
+  assert(_wx_init, "should be inited");
+  WXMode old = _wx_state;
+  if (_wx_state != new_state) {
+    _wx_state = new_state;
+    os::current_thread_enable_wx(new_state);
+  }
+  return old;
+}
+#endif // __APPLE__ && AARCH64
+
 inline void JavaThread::set_ext_suspended() {
   set_suspend_flag (_ext_suspended);
 }
diff --git a/src/hotspot/share/runtime/threadWXSetters.hpp b/src/hotspot/share/runtime/threadWXSetters.hpp
index 8eb64f6fb99..e4d78b52762 100644
--- a/src/hotspot/share/runtime/threadWXSetters.hpp
+++ b/src/hotspot/share/runtime/threadWXSetters.hpp
@@ -25,22 +25,22 @@
 #ifndef SHARE_RUNTIME_THREADWXSETTERS_HPP
 #define SHARE_RUNTIME_THREADWXSETTERS_HPP
 
-#include "runtime/thread.hpp"
+#include "runtime/thread.inline.hpp"
 
+#if defined(__APPLE__) && defined(AARCH64)
 class ThreadWXEnable  {
   Thread* _thread;
   WXMode _old_mode;
-
 public:
   ThreadWXEnable(WXMode new_mode, Thread* thread = NULL) :
     _thread(thread ? thread : Thread::current()),
     _old_mode(_thread->enable_wx(new_mode))
   { }
-
   ~ThreadWXEnable() {
     _thread->enable_wx(_old_mode);
   }
 };
+#endif // __APPLE__ && AARCH64
 
 #endif // SHARE_RUNTIME_THREADWXSETTERS_HPP
 
diff --git a/src/hotspot/share/utilities/macros.hpp b/src/hotspot/share/utilities/macros.hpp
index 5feb91e1c41..3bcc0493b36 100644
--- a/src/hotspot/share/utilities/macros.hpp
+++ b/src/hotspot/share/utilities/macros.hpp
@@ -562,6 +562,8 @@
 #define NOT_AARCH64(code) code
 #endif
 
+#define MACOS_AARCH64_ONLY(x) MACOS_ONLY(AARCH64_ONLY(x))
+
 #ifdef VM_LITTLE_ENDIAN
 #define LITTLE_ENDIAN_ONLY(code) code
 #define BIG_ENDIAN_ONLY(code)
diff --git a/test/hotspot/gtest/gtestMain.cpp b/test/hotspot/gtest/gtestMain.cpp
index ab9c1b0921b..33ae9077222 100644
--- a/test/hotspot/gtest/gtestMain.cpp
+++ b/test/hotspot/gtest/gtestMain.cpp
@@ -38,7 +38,7 @@
 #include "jni.h"
 #include "unittest.hpp"
 
-#include "runtime/thread.hpp"
+#include "runtime/thread.inline.hpp"
 
 // Default value for -new-thread option: true on AIX because we run into
 // problems when attempting to initialize the JVM on the primordial thread.
@@ -98,7 +98,7 @@ static int init_jvm(int argc, char **argv, bool disable_error_handling) {
     // CreateJavaVM leaves WXExec context, while gtests
     // calls internal functions assuming running in WXWwrite.
     // Switch to WXWrite once for all test cases.
-    Thread::current()->enable_wx(WXWrite);
+    MACOS_AARCH64_ONLY(Thread::current()->enable_wx(WXWrite));
   }
   return ret;
 }

From 7e4d85d2d9d533270a481e9ef7a63c6c25a1c518 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Wed, 3 Feb 2021 06:11:31 -0800
Subject: [PATCH 62/94] Add comments to WX transitions

+ minor change of placements
---
 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp  |  5 +++--
 src/hotspot/share/c1/c1_Runtime1.cpp               |  4 +++-
 src/hotspot/share/gc/shared/barrierSetNMethod.cpp  |  4 +++-
 .../share/interpreter/interpreterRuntime.cpp       |  3 ++-
 src/hotspot/share/jvmci/jvmciCompilerToVM.cpp      |  2 +-
 src/hotspot/share/opto/runtime.cpp                 |  6 ++++--
 src/hotspot/share/prims/jniCheck.cpp               |  2 +-
 src/hotspot/share/prims/jvmtiEnter.xsl             |  2 +-
 src/hotspot/share/prims/jvmtiEnv.cpp               |  2 +-
 src/hotspot/share/prims/unsafe.cpp                 |  6 +++---
 src/hotspot/share/prims/whitebox.inline.hpp        |  2 +-
 src/hotspot/share/runtime/deoptimization.cpp       |  4 +++-
 .../share/runtime/interfaceSupport.inline.hpp      | 14 +++++++-------
 src/hotspot/share/runtime/safepoint.cpp            |  3 ++-
 src/hotspot/share/runtime/thread.cpp               |  3 ++-
 15 files changed, 37 insertions(+), 25 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index 9bae00a356c..56022a0c441 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -209,8 +209,9 @@ NOINLINE frame os::current_frame() {
 
 bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
                                              ucontext_t* uc, JavaThread* thread) {
-
-  ThreadWXEnable wx_write(WXWrite, thread);
+  // Enable WXWrite: this function is called by the signal handler at arbitrary
+  // point of execution.
+  ThreadWXEnable wx(WXWrite, thread);
 
 /*
   NOTE: does not seem to work on bsd.
diff --git a/src/hotspot/share/c1/c1_Runtime1.cpp b/src/hotspot/share/c1/c1_Runtime1.cpp
index fd2a3d14a1c..f2b5aff1882 100644
--- a/src/hotspot/share/c1/c1_Runtime1.cpp
+++ b/src/hotspot/share/c1/c1_Runtime1.cpp
@@ -1268,7 +1268,9 @@ JRT_END
 void Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id) {
   NOT_PRODUCT(_patch_code_slowcase_cnt++);
 
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
+  // Enable WXWrite: the function is called by c1 stub as a runtime function
+  // (see another implementation above).
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));
 
   if (TracePatching) {
     tty->print_cr("Deoptimizing because patch is needed");
diff --git a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
index 2dc2cdb32b6..cb844e7b4c2 100644
--- a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
+++ b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
@@ -49,7 +49,9 @@ bool BarrierSetNMethod::supports_entry_barrier(nmethod* nm) {
 }
 
 int BarrierSetNMethod::nmethod_stub_entry_barrier(address* return_address_ptr) {
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite));
+  // Enable WXWrite: the function is called direclty from nmethod_entry_barrier
+  // stub.
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite));
 
   address return_address = *return_address_ptr;
   CodeBlob* cb = CodeCache::find_blob(return_address);
diff --git a/src/hotspot/share/interpreter/interpreterRuntime.cpp b/src/hotspot/share/interpreter/interpreterRuntime.cpp
index af26d1f3617..a839ba6b548 100644
--- a/src/hotspot/share/interpreter/interpreterRuntime.cpp
+++ b/src/hotspot/share/interpreter/interpreterRuntime.cpp
@@ -970,7 +970,8 @@ JRT_END
 
 
 nmethod* InterpreterRuntime::frequency_counter_overflow(JavaThread* thread, address branch_bcp) {
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
+  // Enable WXWrite: the function is called directly by interpreter.
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));
 
   // frequency_counter_overflow_inner can throw async exception.
   nmethod* nm = frequency_counter_overflow_inner(thread, branch_bcp);
diff --git a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
index adcb1a3074e..07246c9dec6 100644
--- a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
+++ b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
@@ -125,7 +125,7 @@ Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 
 // Bring the JVMCI compiler thread into the VM state.
 #define JVMCI_VM_ENTRY_MARK                                       \
-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread)); \
+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));       \
   ThreadInVMfromNative __tiv(thread);                             \
   HandleMarkCleaner __hm(thread);                                 \
   Thread* THREAD = thread;                                        \
diff --git a/src/hotspot/share/opto/runtime.cpp b/src/hotspot/share/opto/runtime.cpp
index 7bd3b43f54a..7d79a1f8e50 100644
--- a/src/hotspot/share/opto/runtime.cpp
+++ b/src/hotspot/share/opto/runtime.cpp
@@ -1411,6 +1411,10 @@ address OptoRuntime::handle_exception_C(JavaThread* thread) {
 // *THIS IS NOT RECOMMENDED PROGRAMMING STYLE*
 //
 address OptoRuntime::rethrow_C(oopDesc* exception, JavaThread* thread, address ret_pc) {
+
+  // Enable WXWrite: the function called directly by compiled code.
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));
+
   // The frame we rethrow the exception to might not have been processed by the GC yet.
   // The stack watermark barrier takes care of detecting that and ensuring the frame
   // has updated oops.
@@ -1427,8 +1431,6 @@ address OptoRuntime::rethrow_C(oopDesc* exception, JavaThread* thread, address r
   }
 #endif
 
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
-
   thread->set_vm_result(exception);
   // Frame not compiled (handles deoptimization blob)
   return SharedRuntime::raw_exception_handler_for_return_address(thread, ret_pc);
diff --git a/src/hotspot/share/prims/jniCheck.cpp b/src/hotspot/share/prims/jniCheck.cpp
index 573224f37c2..eca844cfb4d 100644
--- a/src/hotspot/share/prims/jniCheck.cpp
+++ b/src/hotspot/share/prims/jniCheck.cpp
@@ -104,7 +104,7 @@ extern "C" {                                                             \
     if (env != xenv) {                                                   \
       NativeReportJNIFatalError(thr, warn_wrong_jnienv);                 \
     }                                                                    \
-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thr));         \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thr));         \
     VM_ENTRY_BASE(result_type, header, thr)
 
 
diff --git a/src/hotspot/share/prims/jvmtiEnter.xsl b/src/hotspot/share/prims/jvmtiEnter.xsl
index f41a69cae57..80f771926a6 100644
--- a/src/hotspot/share/prims/jvmtiEnter.xsl
+++ b/src/hotspot/share/prims/jvmtiEnter.xsl
@@ -433,7 +433,7 @@ struct jvmtiInterface_1_ jvmti</xsl:text>
   <xsl:if test="count(@impl)=0 or not(contains(@impl,'innative'))">
     <xsl:text>JavaThread* current_thread = this_thread->as_Java_thread();</xsl:text>
     <xsl:value-of select="$space"/>
-    <xsl:text>MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, current_thread));</xsl:text>
+    <xsl:text>MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));</xsl:text>
     <xsl:value-of select="$space"/>
     <xsl:text>ThreadInVMfromNative __tiv(current_thread);</xsl:text>
     <xsl:value-of select="$space"/>
diff --git a/src/hotspot/share/prims/jvmtiEnv.cpp b/src/hotspot/share/prims/jvmtiEnv.cpp
index d4a8065c20c..09cd2250072 100644
--- a/src/hotspot/share/prims/jvmtiEnv.cpp
+++ b/src/hotspot/share/prims/jvmtiEnv.cpp
@@ -176,7 +176,7 @@ JvmtiEnv::GetThreadLocalStorage(jthread thread, void** data_ptr) {
     // other than the current thread is required we need to transition
     // from native so as to resolve the jthread.
 
-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, current_thread));
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));
     ThreadInVMfromNative __tiv(current_thread);
     VM_ENTRY_BASE(jvmtiError, JvmtiEnv::GetThreadLocalStorage , current_thread)
     debug_only(VMNativeEntryWrapper __vew;)
diff --git a/src/hotspot/share/prims/unsafe.cpp b/src/hotspot/share/prims/unsafe.cpp
index 06c226920dc..5501a5691f1 100644
--- a/src/hotspot/share/prims/unsafe.cpp
+++ b/src/hotspot/share/prims/unsafe.cpp
@@ -405,7 +405,7 @@ UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcOb
   {
     GuardUnsafeAccess guard(thread);
     if (StubRoutines::unsafe_arraycopy() != NULL) {
-      MACOS_AARCH64_ONLY(ThreadWXEnable wx_exec(WXExec, thread));
+      MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));
       StubRoutines::UnsafeArrayCopy_stub()(src, dst, sz);
     } else {
       Copy::conjoint_memory_atomic(src, dst, sz);
@@ -457,14 +457,14 @@ UNSAFE_LEAF (void, Unsafe_WriteBack0(JNIEnv *env, jobject unsafe, jlong line)) {
   }
 #endif
 
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx_exec(WXExec));
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
   assert(StubRoutines::data_cache_writeback() != NULL, "sanity");
   (StubRoutines::DataCacheWriteback_stub())(addr_from_java(line));
 } UNSAFE_END
 
 static void doWriteBackSync0(bool is_pre)
 {
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx_exec(WXExec));
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
   assert(StubRoutines::data_cache_writeback_sync() != NULL, "sanity");
   (StubRoutines::DataCacheWritebackSync_stub())(is_pre);
 }
diff --git a/src/hotspot/share/prims/whitebox.inline.hpp b/src/hotspot/share/prims/whitebox.inline.hpp
index cde38853dc3..515cad65779 100644
--- a/src/hotspot/share/prims/whitebox.inline.hpp
+++ b/src/hotspot/share/prims/whitebox.inline.hpp
@@ -32,7 +32,7 @@
 
 #define WB_ENTRY(result_type, header) JNI_ENTRY(result_type, header) \
   ClearPendingJniExcCheck _clearCheck(env); \
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
+  MACOS_AARCH64_ONLY(ThreadWXEnable _wx(WXWrite, thread));
 
 #define WB_END JNI_END
 
diff --git a/src/hotspot/share/runtime/deoptimization.cpp b/src/hotspot/share/runtime/deoptimization.cpp
index fb71494917f..18c4fcc95ec 100644
--- a/src/hotspot/share/runtime/deoptimization.cpp
+++ b/src/hotspot/share/runtime/deoptimization.cpp
@@ -2455,6 +2455,9 @@ Deoptimization::update_method_data_from_interpreter(MethodData* trap_mdo, int tr
 }
 
 Deoptimization::UnrollBlock* Deoptimization::uncommon_trap(JavaThread* thread, jint trap_request, jint exec_mode) {
+  // Enable WXWrite: current function is called from methods compiled by C2 directly
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));
+
   if (TraceDeoptimization) {
     tty->print("Uncommon trap ");
   }
@@ -2463,7 +2466,6 @@ Deoptimization::UnrollBlock* Deoptimization::uncommon_trap(JavaThread* thread, j
     // This enters VM and may safepoint
     uncommon_trap_inner(thread, trap_request);
   }
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
   return fetch_unroll_info_helper(thread, exec_mode);
 }
 
diff --git a/src/hotspot/share/runtime/interfaceSupport.inline.hpp b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
index 3af5796359c..d39cd1466c2 100644
--- a/src/hotspot/share/runtime/interfaceSupport.inline.hpp
+++ b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
@@ -336,7 +336,7 @@ class VMNativeEntryWrapper {
 
 #define VM_LEAF_BASE(result_type, header)                            \
   debug_only(NoHandleMark __hm;)                                     \
-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite));            \
+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite));                  \
   os::verify_stack_alignment();                                      \
   /* begin of body */
 
@@ -359,7 +359,7 @@ class VMNativeEntryWrapper {
 
 #define JRT_ENTRY(result_type, header)                               \
   result_type header {                                               \
-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \
     ThreadInVMfromJava __tiv(thread);                                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -386,7 +386,7 @@ class VMNativeEntryWrapper {
 
 #define JRT_ENTRY_NO_ASYNC(result_type, header)                      \
   result_type header {                                               \
-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \
     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -395,7 +395,7 @@ class VMNativeEntryWrapper {
 // to get back into Java from the VM
 #define JRT_BLOCK_ENTRY(result_type, header)                         \
   result_type header {                                               \
-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \
     HandleMarkCleaner __hm(thread);
 
 #define JRT_BLOCK                                                    \
@@ -425,7 +425,7 @@ extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
     assert( !VerifyJNIEnvThread || (thread == Thread::current()), "JNIEnv is only valid in same thread"); \
-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -450,7 +450,7 @@ extern "C" {                                                         \
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -460,7 +460,7 @@ extern "C" {                                                         \
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread = JavaThread::current();                      \
-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx_write(WXWrite, thread));  \
+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
diff --git a/src/hotspot/share/runtime/safepoint.cpp b/src/hotspot/share/runtime/safepoint.cpp
index 334c0231e90..7e115cde987 100644
--- a/src/hotspot/share/runtime/safepoint.cpp
+++ b/src/hotspot/share/runtime/safepoint.cpp
@@ -759,7 +759,8 @@ void SafepointSynchronize::block(JavaThread *thread) {
 void SafepointSynchronize::handle_polling_page_exception(JavaThread *thread) {
   assert(thread->thread_state() == _thread_in_Java, "should come from Java code");
 
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
+  // Enable WXWrite: the function is called implicitly from java code.
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));
 
   if (log_is_enabled(Info, safepoint, stats)) {
     Atomic::inc(&_nof_threads_hit_polling_page);
diff --git a/src/hotspot/share/runtime/thread.cpp b/src/hotspot/share/runtime/thread.cpp
index 08005fd6f0f..148ea9dfdc0 100644
--- a/src/hotspot/share/runtime/thread.cpp
+++ b/src/hotspot/share/runtime/thread.cpp
@@ -2512,7 +2512,8 @@ void JavaThread::check_safepoint_and_suspend_for_native_trans(JavaThread *thread
 // Note only the native==>VM/Java barriers can call this function and when
 // thread state is _thread_in_native_trans.
 void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx_write(WXWrite, thread));
+  // Enable WXWrite: called directly from interpreter native wrapper.
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));
 
   check_safepoint_and_suspend_for_native_trans(thread);
 

From 8652d21deddee3a113027a66c398961e033350f3 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 5 Feb 2021 04:39:07 -0800
Subject: [PATCH 63/94] Cleanup SA changes

---
 .../macosx/native/libsaproc/MacosxDebuggerLocal.m     | 11 +++--------
 1 file changed, 3 insertions(+), 8 deletions(-)

diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
index b971974c902..755eb50a29a 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
@@ -503,10 +503,13 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
   }
 
 #undef NPRGREG
+#undef REG_INDEX
 #if defined(amd64)
 #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
+#define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
 #elif defined(aarch64)
 #define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG
+#define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
 #else
 #error UNSUPPORTED_ARCH
 #endif
@@ -515,10 +518,7 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
   CHECK_EXCEPTION_(0);
   regs = (*env)->GetLongArrayElements(env, array, &isCopy);
 
-#undef REG_INDEX
-
 #if defined(amd64)
-#define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
 
   regs[REG_INDEX(R15)] = gregs.r_r15;
   regs[REG_INDEX(R14)] = gregs.r_r14;
@@ -549,7 +549,6 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
   regs[REG_INDEX(RFL)]    = gregs.r_rflags;
 
 #elif defined(aarch64)
-#define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
 
   regs[REG_INDEX(R0)] = gregs.r_r0;
   regs[REG_INDEX(R1)] = gregs.r_r1;
@@ -699,10 +698,7 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
   CHECK_EXCEPTION_(0);
   primitiveArray = (*env)->GetLongArrayElements(env, registerArray, NULL);
 
-#undef REG_INDEX
-
 #if defined(amd64)
-#define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
 
   primitiveArray[REG_INDEX(R15)] = state.__r15;
   primitiveArray[REG_INDEX(R14)] = state.__r14;
@@ -734,7 +730,6 @@ jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, lo
   primitiveArray[REG_INDEX(GSBASE)] = 0;
 
 #elif defined(aarch64)
-#define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
 
   primitiveArray[REG_INDEX(R0)] = state.__x[0];
   primitiveArray[REG_INDEX(R1)] = state.__x[1];

From b873c25f31dd21349d140b790713cc9ccb5f2dc0 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 5 Feb 2021 17:36:24 +0300
Subject: [PATCH 64/94] Extract SafeFetch32/N to stubRoutines.inline.hpp

---
 src/hotspot/os/aix/os_aix.cpp                 |  2 +-
 .../gc/z/zPhysicalMemoryBacking_linux.cpp     |  2 +-
 src/hotspot/os/windows/os_windows.cpp         |  2 +-
 src/hotspot/share/gc/shared/oopStorage.cpp    |  2 +-
 src/hotspot/share/runtime/objectMonitor.cpp   |  2 +-
 src/hotspot/share/runtime/os.cpp              |  2 +-
 src/hotspot/share/runtime/stubRoutines.cpp    |  2 +-
 src/hotspot/share/runtime/stubRoutines.hpp    | 20 -------
 .../share/runtime/stubRoutines.inline.hpp     | 52 +++++++++++++++++++
 src/hotspot/share/utilities/vmError.cpp       |  1 +
 test/hotspot/gtest/runtime/test_safefetch.cpp |  2 +-
 11 files changed, 61 insertions(+), 28 deletions(-)
 create mode 100644 src/hotspot/share/runtime/stubRoutines.inline.hpp

diff --git a/src/hotspot/os/aix/os_aix.cpp b/src/hotspot/os/aix/os_aix.cpp
index a976e4f6b94..9efd635acbe 100644
--- a/src/hotspot/os/aix/os_aix.cpp
+++ b/src/hotspot/os/aix/os_aix.cpp
@@ -65,7 +65,7 @@
 #include "runtime/perfMemory.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/statSampler.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadCritical.hpp"
 #include "runtime/timer.hpp"
diff --git a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
index 2cd3b95a72b..16c913cd489 100644
--- a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
+++ b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
@@ -34,7 +34,7 @@
 #include "logging/log.hpp"
 #include "runtime/init.hpp"
 #include "runtime/os.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "utilities/align.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/growableArray.hpp"
diff --git a/src/hotspot/os/windows/os_windows.cpp b/src/hotspot/os/windows/os_windows.cpp
index 53dd2d99f15..4126b6dede3 100644
--- a/src/hotspot/os/windows/os_windows.cpp
+++ b/src/hotspot/os/windows/os_windows.cpp
@@ -61,7 +61,7 @@
 #include "runtime/safepointMechanism.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/statSampler.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadCritical.hpp"
 #include "runtime/timer.hpp"
diff --git a/src/hotspot/share/gc/shared/oopStorage.cpp b/src/hotspot/share/gc/shared/oopStorage.cpp
index 4248c9d91b8..221b870a4ce 100644
--- a/src/hotspot/share/gc/shared/oopStorage.cpp
+++ b/src/hotspot/share/gc/shared/oopStorage.cpp
@@ -37,7 +37,7 @@
 #include "runtime/orderAccess.hpp"
 #include "runtime/os.hpp"
 #include "runtime/safepoint.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.hpp"
 #include "services/memTracker.hpp"
 #include "utilities/align.hpp"
diff --git a/src/hotspot/share/runtime/objectMonitor.cpp b/src/hotspot/share/runtime/objectMonitor.cpp
index f7afa9fdba9..907fbf13e07 100644
--- a/src/hotspot/share/runtime/objectMonitor.cpp
+++ b/src/hotspot/share/runtime/objectMonitor.cpp
@@ -49,7 +49,7 @@
 #include "runtime/perfData.hpp"
 #include "runtime/safepointMechanism.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "services/threadService.hpp"
 #include "utilities/dtrace.hpp"
diff --git a/src/hotspot/share/runtime/os.cpp b/src/hotspot/share/runtime/os.cpp
index 798d36f0981..8b9bd434da7 100644
--- a/src/hotspot/share/runtime/os.cpp
+++ b/src/hotspot/share/runtime/os.cpp
@@ -57,7 +57,7 @@
 #include "runtime/os.inline.hpp"
 #include "runtime/osThread.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 #include "runtime/vm_version.hpp"
diff --git a/src/hotspot/share/runtime/stubRoutines.cpp b/src/hotspot/share/runtime/stubRoutines.cpp
index 8a4afc0fc6f..b04cbc9c6bb 100644
--- a/src/hotspot/share/runtime/stubRoutines.cpp
+++ b/src/hotspot/share/runtime/stubRoutines.cpp
@@ -31,7 +31,7 @@
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/timerTrace.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "utilities/align.hpp"
 #include "utilities/copy.hpp"
 #ifdef COMPILER2
diff --git a/src/hotspot/share/runtime/stubRoutines.hpp b/src/hotspot/share/runtime/stubRoutines.hpp
index 9b6ae56963a..befdf2b65b1 100644
--- a/src/hotspot/share/runtime/stubRoutines.hpp
+++ b/src/hotspot/share/runtime/stubRoutines.hpp
@@ -488,24 +488,4 @@ class StubRoutines: AllStatic {
   static void arrayof_oop_copy_uninit(HeapWord* src, HeapWord* dest, size_t count);
 };
 
-// Safefetch allows to load a value from a location that's not known
-// to be valid. If the load causes a fault, the error value is returned.
-inline int SafeFetch32(int* adr, int errValue) {
-  assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
-  return StubRoutines::SafeFetch32_stub()(adr, errValue);
-}
-inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
-  assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
-  return StubRoutines::SafeFetchN_stub()(adr, errValue);
-}
-
-
-// returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)
-inline bool CanUseSafeFetch32() {
-  return StubRoutines::SafeFetch32_stub() ? true : false;
-}
-
-inline bool CanUseSafeFetchN() {
-  return StubRoutines::SafeFetchN_stub() ? true : false;
-}
 #endif // SHARE_RUNTIME_STUBROUTINES_HPP
diff --git a/src/hotspot/share/runtime/stubRoutines.inline.hpp b/src/hotspot/share/runtime/stubRoutines.inline.hpp
new file mode 100644
index 00000000000..bfba43dedea
--- /dev/null
+++ b/src/hotspot/share/runtime/stubRoutines.inline.hpp
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
+#define SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
+
+#include "runtime/thread.hpp"
+#include "runtime/stubRoutines.hpp"
+
+// Safefetch allows to load a value from a location that's not known
+// to be valid. If the load causes a fault, the error value is returned.
+inline int SafeFetch32(int* adr, int errValue) {
+  assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
+  return StubRoutines::SafeFetch32_stub()(adr, errValue);
+}
+
+inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
+  assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
+  return StubRoutines::SafeFetchN_stub()(adr, errValue);
+}
+
+// returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)
+inline bool CanUseSafeFetch32() {
+  return StubRoutines::SafeFetch32_stub() ? true : false;
+}
+
+inline bool CanUseSafeFetchN() {
+  return StubRoutines::SafeFetchN_stub() ? true : false;
+}
+
+#endif // SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
diff --git a/src/hotspot/share/utilities/vmError.cpp b/src/hotspot/share/utilities/vmError.cpp
index 1f8ab5b3537..4094139b6e2 100644
--- a/src/hotspot/share/utilities/vmError.cpp
+++ b/src/hotspot/share/utilities/vmError.cpp
@@ -44,6 +44,7 @@
 #include "runtime/os.hpp"
 #include "runtime/osThread.hpp"
 #include "runtime/safepointMechanism.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 #include "runtime/vmThread.hpp"
diff --git a/test/hotspot/gtest/runtime/test_safefetch.cpp b/test/hotspot/gtest/runtime/test_safefetch.cpp
index 25d5fb092ec..14e79a3160e 100644
--- a/test/hotspot/gtest/runtime/test_safefetch.cpp
+++ b/test/hotspot/gtest/runtime/test_safefetch.cpp
@@ -24,7 +24,7 @@
 
 #include "precompiled.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/vmOperations.hpp"
 #include "runtime/vmThread.hpp"
 #include "utilities/globalDefinitions.hpp"

From 0d0e9baf0580f6fb0b4750e5fc709ac214acc488 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 5 Feb 2021 08:01:57 -0800
Subject: [PATCH 65/94] Update signal handler part for debugger

---
 src/hotspot/os/posix/signals_posix.cpp | 19 ++++++++-----------
 1 file changed, 8 insertions(+), 11 deletions(-)

diff --git a/src/hotspot/os/posix/signals_posix.cpp b/src/hotspot/os/posix/signals_posix.cpp
index 0b245a6ad53..15632533564 100644
--- a/src/hotspot/os/posix/signals_posix.cpp
+++ b/src/hotspot/os/posix/signals_posix.cpp
@@ -1281,20 +1281,17 @@ void install_signal_handlers() {
   set_signal_handler(SIGXFSZ);
 
 #if defined(__APPLE__)
-  // In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including
-  // signals caught and handled by the JVM. To work around this, we reset the mach task
-  // signal handler that's placed on our process by CrashReporter. This disables
-  // CrashReporter-based reporting.
-  //
-  // This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes
-  // on caught fatal signals.
-  //
-  // Additionally, gdb installs both standard BSD signal handlers, and mach exception
-  // handlers. By replacing the existing task exception handler, we disable gdb's mach
+  // lldb (gdb) installs both standard BSD signal handlers, and mach exception
+  // handlers. By replacing the existing task exception handler, we disable lldb's mach
   // exception handling, while leaving the standard BSD signal handlers functional.
+  //
+  // EXC_MASK_BAD_ACCESS needed by all architectures for NULL ptr checking
+  // EXC_MASK_ARITHMETIC needed by all architectures for div by 0 checking
+  // EXC_MASK_BAD_INSTRUCTION needed by aarch64 to initiate deoptimization
   kern_return_t kr;
   kr = task_set_exception_ports(mach_task_self(),
-                                EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC,
+                                EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC
+                                  AARCH64_ONLY(| EXC_MASK_BAD_INSTRUCTION),
                                 MACH_PORT_NULL,
                                 EXCEPTION_STATE_IDENTITY,
                                 MACHINE_THREAD_STATE);

From a00d906415acf55e6bd06f213fe02f90b2ef9ac0 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Thu, 11 Feb 2021 22:40:19 +0300
Subject: [PATCH 66/94] Update copyrights

---
 src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp | 2 +-
 src/hotspot/share/gc/shared/oopStorage.cpp                 | 2 +-
 src/hotspot/share/runtime/stubRoutines.cpp                 | 2 +-
 src/hotspot/share/runtime/stubRoutines.hpp                 | 2 +-
 src/hotspot/share/runtime/stubRoutines.inline.hpp          | 2 +-
 test/hotspot/gtest/runtime/test_safefetch.cpp              | 2 +-
 6 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
index 16c913cd489..d5ddc5456ec 100644
--- a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
+++ b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/gc/shared/oopStorage.cpp b/src/hotspot/share/gc/shared/oopStorage.cpp
index 221b870a4ce..996a1bd0a3d 100644
--- a/src/hotspot/share/gc/shared/oopStorage.cpp
+++ b/src/hotspot/share/gc/shared/oopStorage.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/runtime/stubRoutines.cpp b/src/hotspot/share/runtime/stubRoutines.cpp
index b04cbc9c6bb..55199d07846 100644
--- a/src/hotspot/share/runtime/stubRoutines.cpp
+++ b/src/hotspot/share/runtime/stubRoutines.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/runtime/stubRoutines.hpp b/src/hotspot/share/runtime/stubRoutines.hpp
index befdf2b65b1..d3e001ebdfe 100644
--- a/src/hotspot/share/runtime/stubRoutines.hpp
+++ b/src/hotspot/share/runtime/stubRoutines.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/runtime/stubRoutines.inline.hpp b/src/hotspot/share/runtime/stubRoutines.inline.hpp
index bfba43dedea..f51c45350fd 100644
--- a/src/hotspot/share/runtime/stubRoutines.inline.hpp
+++ b/src/hotspot/share/runtime/stubRoutines.inline.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/test/hotspot/gtest/runtime/test_safefetch.cpp b/test/hotspot/gtest/runtime/test_safefetch.cpp
index 14e79a3160e..bad963dd41b 100644
--- a/test/hotspot/gtest/runtime/test_safefetch.cpp
+++ b/test/hotspot/gtest/runtime/test_safefetch.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2020 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *

From ad4e4c65e929edc4da14932c969669d85816440d Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 12 Feb 2021 03:45:40 -0800
Subject: [PATCH 67/94] JDK-8257882: oops, fixed
 7fe50a996b6f436932452d220b351c73153ed945

---
 src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
index 9242a8a5990..94e3cd9d01c 100644
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
@@ -320,7 +320,7 @@ void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
   // Always clear the pc because it could have been set by make_walkable()
   str(zr, Address(rthread, JavaThread::last_Java_pc_offset()));
 
-  str(zr, Address(rthread, JavaFrameAnchor::saved_fp_address_offset()));
+  str(zr, Address(rthread, JavaThread::saved_fp_address_offset()));
 }
 
 // Calls to C land

From a9452a4c014a5c17a74654cb03ad2863687403ce Mon Sep 17 00:00:00 2001
From: VladimirKempik <69576004+VladimirKempik@users.noreply.github.com>
Date: Mon, 15 Feb 2021 20:41:34 +0300
Subject: [PATCH 68/94] Pull/2200 (#5)

* bsd_aarch64 cleanup

* remove the actual attribute too

* Refactor bailing out on nativeWrapper generation

* rename c_call_conv_priv function
---
 .../cpu/aarch64/sharedRuntime_aarch64.cpp     | 14 +++++-
 .../os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp |  3 +-
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.cpp     | 48 +------------------
 3 files changed, 15 insertions(+), 50 deletions(-)

diff --git a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
index 9427d26be9e..2f9d20a0f54 100644
--- a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
@@ -782,7 +782,7 @@ AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm
   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);
 }
 
-int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
+static int c_calling_convention_priv(const BasicType *sig_bt,
                                          VMRegPair *regs,
                                          VMRegPair *regs2,
                                          int total_args_passed) {
@@ -871,6 +871,16 @@ int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
   return stk_args;
 }
 
+int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
+                                         VMRegPair *regs,
+                                         VMRegPair *regs2,
+                                         int total_args_passed)
+{
+  int result = c_calling_convention_priv(sig_bt, regs, regs2, total_args_passed);
+  guarantee(result >= 0, "Unsupported arguments configuration");
+  return result;
+}
+
 // On 64 bit we will store integer like items to the stack as
 // 64 bits items (Aarch64 abi) even though java would only store
 // 32bits for a parameter. On 32bit it will simply be 32 bits
@@ -1376,7 +1386,7 @@ nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
   // Now figure out where the args must be stored and how much stack space
   // they require.
   int out_arg_slots;
-  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
+  out_arg_slots = c_calling_convention_priv(out_sig_bt, out_regs, NULL, total_c_args);
 
   if (out_arg_slots < 0) {
     return NULL;
diff --git a/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
index a64d9f3f36f..eed1dd0c9e6 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
@@ -56,10 +56,9 @@ inline T Atomic::PlatformXchg<byte_size>::operator()(T volatile* dest,
   return res;
 }
 
-// __attribute__((unused)) on dest is to get rid of spurious GCC warnings.
 template<size_t byte_size>
 template<typename T>
-inline T Atomic::PlatformCmpxchg<byte_size>::operator()(T volatile* dest __attribute__((unused)),
+inline T Atomic::PlatformCmpxchg<byte_size>::operator()(T volatile* dest,
                                                         T compare_value,
                                                         T exchange_value,
                                                         atomic_memory_order order) const {
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index 56022a0c441..7aac361a5b6 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -66,7 +66,6 @@
 # include <stdio.h>
 # include <unistd.h>
 # include <sys/resource.h>
-# include <pthread.h>
 # include <sys/stat.h>
 # include <sys/time.h>
 # include <sys/utsname.h>
@@ -82,27 +81,14 @@
 # include <pthread_np.h>
 #endif
 
-// needed by current_stack_region() workaround for Mavericks
-#if defined(__APPLE__)
-# include <errno.h>
-# include <sys/types.h>
-# include <sys/sysctl.h>
-# define DEFAULT_MAIN_THREAD_STACK_PAGES 2048
-# define OS_X_10_9_0_KERNEL_MAJOR_VERSION 13
-#endif
-
 #define SPELL_REG_SP "sp"
 #define SPELL_REG_FP "fp"
 
 #ifdef __APPLE__
 // see darwin-xnu/osfmk/mach/arm/_structs.h
 
-# if __DARWIN_UNIX03 && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
-  // 10.5 UNIX03 member name prefixes
-  #define DU3_PREFIX(s, m) __ ## s.__ ## m
-# else
-  #define DU3_PREFIX(s, m) s ## . ## m
-# endif
+// 10.5 UNIX03 member name prefixes
+#define DU3_PREFIX(s, m) __ ## s.__ ## m
 #endif
 
 #define context_x    uc_mcontext->DU3_PREFIX(ss,x)
@@ -213,15 +199,6 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
   // point of execution.
   ThreadWXEnable wx(WXWrite, thread);
 
-/*
-  NOTE: does not seem to work on bsd.
-  if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {
-    // can't decode this kind of signal
-    info = NULL;
-  } else {
-    assert(sig == info->si_signo, "bad siginfo");
-  }
-*/
   // decide if this trap can be handled by a stub
   address stub = NULL;
 
@@ -465,27 +442,6 @@ static void current_stack_region(address * bottom, size_t * size) {
   pthread_t self = pthread_self();
   void *stacktop = pthread_get_stackaddr_np(self);
   *size = pthread_get_stacksize_np(self);
-  // workaround for OS X 10.9.0 (Mavericks)
-  // pthread_get_stacksize_np returns 128 pages even though the actual size is 2048 pages
-  if (pthread_main_np() == 1) {
-    // At least on Mac OS 10.12 we have observed stack sizes not aligned
-    // to pages boundaries. This can be provoked by e.g. setrlimit() (ulimit -s xxxx in the
-    // shell). Apparently Mac OS actually rounds upwards to next multiple of page size,
-    // however, we round downwards here to be on the safe side.
-    *size = align_down(*size, getpagesize());
-
-    if ((*size) < (DEFAULT_MAIN_THREAD_STACK_PAGES * (size_t)getpagesize())) {
-      char kern_osrelease[256];
-      size_t kern_osrelease_size = sizeof(kern_osrelease);
-      int ret = sysctlbyname("kern.osrelease", kern_osrelease, &kern_osrelease_size, NULL, 0);
-      if (ret == 0) {
-        // get the major number, atoi will ignore the minor amd micro portions of the version string
-        if (atoi(kern_osrelease) >= OS_X_10_9_0_KERNEL_MAJOR_VERSION) {
-          *size = (DEFAULT_MAIN_THREAD_STACK_PAGES*getpagesize());
-        }
-      }
-    }
-  }
   *bottom = (address) stacktop - *size;
 #elif defined(__OpenBSD__)
   stack_t ss;

From f4426e78ed1b99f63e88b3f845b64bccfc6846c4 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Mon, 15 Feb 2021 21:04:46 +0300
Subject: [PATCH 69/94] Fix typo in comments

---
 src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
index 70a846a4875..5203740baf3 100644
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
@@ -59,7 +59,7 @@ FloatRegister InterpreterRuntime::SignatureHandlerGenerator::next_fpr() {
 
 // On macos/aarch64 native stack is packed, int/float are using only 4 bytes
 // on stack. Natural alignment for types are still in place,
-// for example double/long should be 8 bytes alligned
+// for example double/long should be 8 bytes aligned.
 
 int InterpreterRuntime::SignatureHandlerGenerator::next_stack_offset(unsigned elem_size) {
   MACOS_ONLY(_stack_offset = align_up(_stack_offset, elem_size));

From daf35f0c8fbeefb73e5d5a1d23cbd580a50cd0da Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Mon, 15 Feb 2021 21:18:32 +0300
Subject: [PATCH 70/94] Removed unused variables

---
 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index 7aac361a5b6..710ae3281ea 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -272,11 +272,6 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
           stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
         }
       } else if (sig == SIGILL && nativeInstruction_at(pc)->is_stop()) {
-        // Pull a pointer to the error message out of the instruction
-        // stream.
-        const uint64_t *detail_msg_ptr
-          = (uint64_t*)(pc + NativeInstruction::instruction_size);
-        const char *detail_msg = (const char *)*detail_msg_ptr;
         const char *msg = "stop";
         if (TraceTraps) {
           tty->print_cr("trap: %s: (SIGILL)", msg);

From d2957b9861ff2746a87643d50c5f60a2cb4d4e2f Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Mon, 15 Feb 2021 18:49:39 +0300
Subject: [PATCH 71/94] stubRoutines.inline.hpp -> safefetch.hpp

---
 src/hotspot/os/aix/os_aix.cpp                              | 2 +-
 src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp | 2 +-
 src/hotspot/os/windows/os_windows.cpp                      | 2 +-
 src/hotspot/share/gc/shared/oopStorage.cpp                 | 2 +-
 src/hotspot/share/runtime/objectMonitor.cpp                | 2 +-
 src/hotspot/share/runtime/os.cpp                           | 2 +-
 .../runtime/{stubRoutines.inline.hpp => safefetch.hpp}     | 7 +++----
 src/hotspot/share/runtime/stubRoutines.cpp                 | 2 +-
 src/hotspot/share/utilities/vmError.cpp                    | 2 +-
 test/hotspot/gtest/runtime/test_safefetch.cpp              | 2 +-
 10 files changed, 12 insertions(+), 13 deletions(-)
 rename src/hotspot/share/runtime/{stubRoutines.inline.hpp => safefetch.hpp} (91%)

diff --git a/src/hotspot/os/aix/os_aix.cpp b/src/hotspot/os/aix/os_aix.cpp
index 9efd635acbe..4c755950378 100644
--- a/src/hotspot/os/aix/os_aix.cpp
+++ b/src/hotspot/os/aix/os_aix.cpp
@@ -63,9 +63,9 @@
 #include "runtime/os.hpp"
 #include "runtime/osThread.hpp"
 #include "runtime/perfMemory.hpp"
+#include "runtime/safefetch.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/statSampler.hpp"
-#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadCritical.hpp"
 #include "runtime/timer.hpp"
diff --git a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
index d5ddc5456ec..e9122eff841 100644
--- a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
+++ b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
@@ -34,7 +34,7 @@
 #include "logging/log.hpp"
 #include "runtime/init.hpp"
 #include "runtime/os.hpp"
-#include "runtime/stubRoutines.inline.hpp"
+#include "runtime/safefetch.hpp"
 #include "utilities/align.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/growableArray.hpp"
diff --git a/src/hotspot/os/windows/os_windows.cpp b/src/hotspot/os/windows/os_windows.cpp
index 4126b6dede3..64f2dd170fb 100644
--- a/src/hotspot/os/windows/os_windows.cpp
+++ b/src/hotspot/os/windows/os_windows.cpp
@@ -58,10 +58,10 @@
 #include "runtime/orderAccess.hpp"
 #include "runtime/osThread.hpp"
 #include "runtime/perfMemory.hpp"
+#include "runtime/safefetch.hpp"
 #include "runtime/safepointMechanism.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/statSampler.hpp"
-#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadCritical.hpp"
 #include "runtime/timer.hpp"
diff --git a/src/hotspot/share/gc/shared/oopStorage.cpp b/src/hotspot/share/gc/shared/oopStorage.cpp
index 996a1bd0a3d..9e4c7c827a0 100644
--- a/src/hotspot/share/gc/shared/oopStorage.cpp
+++ b/src/hotspot/share/gc/shared/oopStorage.cpp
@@ -36,8 +36,8 @@
 #include "runtime/mutexLocker.hpp"
 #include "runtime/orderAccess.hpp"
 #include "runtime/os.hpp"
+#include "runtime/safefetch.hpp"
 #include "runtime/safepoint.hpp"
-#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.hpp"
 #include "services/memTracker.hpp"
 #include "utilities/align.hpp"
diff --git a/src/hotspot/share/runtime/objectMonitor.cpp b/src/hotspot/share/runtime/objectMonitor.cpp
index 907fbf13e07..a2994046e8b 100644
--- a/src/hotspot/share/runtime/objectMonitor.cpp
+++ b/src/hotspot/share/runtime/objectMonitor.cpp
@@ -47,9 +47,9 @@
 #include "runtime/orderAccess.hpp"
 #include "runtime/osThread.hpp"
 #include "runtime/perfData.hpp"
+#include "runtime/safefetch.hpp"
 #include "runtime/safepointMechanism.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "services/threadService.hpp"
 #include "utilities/dtrace.hpp"
diff --git a/src/hotspot/share/runtime/os.cpp b/src/hotspot/share/runtime/os.cpp
index 8b9bd434da7..0f2ba59b711 100644
--- a/src/hotspot/share/runtime/os.cpp
+++ b/src/hotspot/share/runtime/os.cpp
@@ -56,8 +56,8 @@
 #include "runtime/mutexLocker.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/osThread.hpp"
+#include "runtime/safefetch.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 #include "runtime/vm_version.hpp"
diff --git a/src/hotspot/share/runtime/stubRoutines.inline.hpp b/src/hotspot/share/runtime/safefetch.hpp
similarity index 91%
rename from src/hotspot/share/runtime/stubRoutines.inline.hpp
rename to src/hotspot/share/runtime/safefetch.hpp
index f51c45350fd..d03394787ea 100644
--- a/src/hotspot/share/runtime/stubRoutines.inline.hpp
+++ b/src/hotspot/share/runtime/safefetch.hpp
@@ -22,10 +22,9 @@
  *
  */
 
-#ifndef SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
-#define SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
+#ifndef SHARE_RUNTIME_SAFEFETCH_HPP
+#define SHARE_RUNTIME_SAFEFETCH_HPP
 
-#include "runtime/thread.hpp"
 #include "runtime/stubRoutines.hpp"
 
 // Safefetch allows to load a value from a location that's not known
@@ -49,4 +48,4 @@ inline bool CanUseSafeFetchN() {
   return StubRoutines::SafeFetchN_stub() ? true : false;
 }
 
-#endif // SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
+#endif // SHARE_RUNTIME_SAFEFETCH_HPP
diff --git a/src/hotspot/share/runtime/stubRoutines.cpp b/src/hotspot/share/runtime/stubRoutines.cpp
index 55199d07846..2e2a2ddda03 100644
--- a/src/hotspot/share/runtime/stubRoutines.cpp
+++ b/src/hotspot/share/runtime/stubRoutines.cpp
@@ -30,8 +30,8 @@
 #include "oops/oop.inline.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/timerTrace.hpp"
+#include "runtime/safefetch.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.inline.hpp"
 #include "utilities/align.hpp"
 #include "utilities/copy.hpp"
 #ifdef COMPILER2
diff --git a/src/hotspot/share/utilities/vmError.cpp b/src/hotspot/share/utilities/vmError.cpp
index 4094139b6e2..455549b1599 100644
--- a/src/hotspot/share/utilities/vmError.cpp
+++ b/src/hotspot/share/utilities/vmError.cpp
@@ -43,8 +43,8 @@
 #include "runtime/init.hpp"
 #include "runtime/os.hpp"
 #include "runtime/osThread.hpp"
+#include "runtime/safefetch.hpp"
 #include "runtime/safepointMechanism.hpp"
-#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 #include "runtime/vmThread.hpp"
diff --git a/test/hotspot/gtest/runtime/test_safefetch.cpp b/test/hotspot/gtest/runtime/test_safefetch.cpp
index bad963dd41b..e99e08626c2 100644
--- a/test/hotspot/gtest/runtime/test_safefetch.cpp
+++ b/test/hotspot/gtest/runtime/test_safefetch.cpp
@@ -24,7 +24,7 @@
 
 #include "precompiled.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
-#include "runtime/stubRoutines.inline.hpp"
+#include "runtime/safefetch.hpp"
 #include "runtime/vmOperations.hpp"
 #include "runtime/vmThread.hpp"
 #include "utilities/globalDefinitions.hpp"

From 4f1f43eba956f09150789579759a47594219e40c Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 16 Feb 2021 08:18:00 -0800
Subject: [PATCH 72/94] Revert "Extract SafeFetch32/N to
 stubRoutines.inline.hpp"

This reverts commit b873c25f31dd21349d140b790713cc9ccb5f2dc0.
---
 src/hotspot/os/aix/os_aix.cpp                 |  2 +-
 .../gc/z/zPhysicalMemoryBacking_linux.cpp     |  2 +-
 src/hotspot/os/windows/os_windows.cpp         |  2 +-
 src/hotspot/share/gc/shared/oopStorage.cpp    |  2 +-
 src/hotspot/share/runtime/objectMonitor.cpp   |  2 +-
 src/hotspot/share/runtime/os.cpp              |  2 +-
 src/hotspot/share/runtime/stubRoutines.cpp    |  2 +-
 src/hotspot/share/runtime/stubRoutines.hpp    | 20 +++++++
 .../share/runtime/stubRoutines.inline.hpp     | 55 -------------------
 src/hotspot/share/utilities/vmError.cpp       |  1 -
 test/hotspot/gtest/runtime/test_safefetch.cpp |  2 +-
 11 files changed, 28 insertions(+), 64 deletions(-)
 delete mode 100644 src/hotspot/share/runtime/stubRoutines.inline.hpp

diff --git a/src/hotspot/os/aix/os_aix.cpp b/src/hotspot/os/aix/os_aix.cpp
index 0d82cdc8097..92ab7dae99b 100644
--- a/src/hotspot/os/aix/os_aix.cpp
+++ b/src/hotspot/os/aix/os_aix.cpp
@@ -64,7 +64,7 @@
 #include "runtime/perfMemory.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/statSampler.hpp"
-#include "runtime/stubRoutines.inline.hpp"
+#include "runtime/stubRoutines.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadCritical.hpp"
 #include "runtime/timer.hpp"
diff --git a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
index 16c913cd489..2cd3b95a72b 100644
--- a/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
+++ b/src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp
@@ -34,7 +34,7 @@
 #include "logging/log.hpp"
 #include "runtime/init.hpp"
 #include "runtime/os.hpp"
-#include "runtime/stubRoutines.inline.hpp"
+#include "runtime/stubRoutines.hpp"
 #include "utilities/align.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/growableArray.hpp"
diff --git a/src/hotspot/os/windows/os_windows.cpp b/src/hotspot/os/windows/os_windows.cpp
index a775a04d0fc..15ce223bd37 100644
--- a/src/hotspot/os/windows/os_windows.cpp
+++ b/src/hotspot/os/windows/os_windows.cpp
@@ -60,7 +60,7 @@
 #include "runtime/safepointMechanism.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/statSampler.hpp"
-#include "runtime/stubRoutines.inline.hpp"
+#include "runtime/stubRoutines.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadCritical.hpp"
 #include "runtime/timer.hpp"
diff --git a/src/hotspot/share/gc/shared/oopStorage.cpp b/src/hotspot/share/gc/shared/oopStorage.cpp
index 221b870a4ce..4248c9d91b8 100644
--- a/src/hotspot/share/gc/shared/oopStorage.cpp
+++ b/src/hotspot/share/gc/shared/oopStorage.cpp
@@ -37,7 +37,7 @@
 #include "runtime/orderAccess.hpp"
 #include "runtime/os.hpp"
 #include "runtime/safepoint.hpp"
-#include "runtime/stubRoutines.inline.hpp"
+#include "runtime/stubRoutines.hpp"
 #include "runtime/thread.hpp"
 #include "services/memTracker.hpp"
 #include "utilities/align.hpp"
diff --git a/src/hotspot/share/runtime/objectMonitor.cpp b/src/hotspot/share/runtime/objectMonitor.cpp
index 907fbf13e07..f7afa9fdba9 100644
--- a/src/hotspot/share/runtime/objectMonitor.cpp
+++ b/src/hotspot/share/runtime/objectMonitor.cpp
@@ -49,7 +49,7 @@
 #include "runtime/perfData.hpp"
 #include "runtime/safepointMechanism.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.inline.hpp"
+#include "runtime/stubRoutines.hpp"
 #include "runtime/thread.inline.hpp"
 #include "services/threadService.hpp"
 #include "utilities/dtrace.hpp"
diff --git a/src/hotspot/share/runtime/os.cpp b/src/hotspot/share/runtime/os.cpp
index 8ec31f87a4b..44c7cb14b2b 100644
--- a/src/hotspot/share/runtime/os.cpp
+++ b/src/hotspot/share/runtime/os.cpp
@@ -56,7 +56,7 @@
 #include "runtime/os.inline.hpp"
 #include "runtime/osThread.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.inline.hpp"
+#include "runtime/stubRoutines.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 #include "runtime/vm_version.hpp"
diff --git a/src/hotspot/share/runtime/stubRoutines.cpp b/src/hotspot/share/runtime/stubRoutines.cpp
index 5f03b4a5a76..5552e16fe0a 100644
--- a/src/hotspot/share/runtime/stubRoutines.cpp
+++ b/src/hotspot/share/runtime/stubRoutines.cpp
@@ -31,7 +31,7 @@
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/timerTrace.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.inline.hpp"
+#include "runtime/stubRoutines.hpp"
 #include "utilities/align.hpp"
 #include "utilities/copy.hpp"
 #ifdef COMPILER2
diff --git a/src/hotspot/share/runtime/stubRoutines.hpp b/src/hotspot/share/runtime/stubRoutines.hpp
index befdf2b65b1..9b6ae56963a 100644
--- a/src/hotspot/share/runtime/stubRoutines.hpp
+++ b/src/hotspot/share/runtime/stubRoutines.hpp
@@ -488,4 +488,24 @@ class StubRoutines: AllStatic {
   static void arrayof_oop_copy_uninit(HeapWord* src, HeapWord* dest, size_t count);
 };
 
+// Safefetch allows to load a value from a location that's not known
+// to be valid. If the load causes a fault, the error value is returned.
+inline int SafeFetch32(int* adr, int errValue) {
+  assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
+  return StubRoutines::SafeFetch32_stub()(adr, errValue);
+}
+inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
+  assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
+  return StubRoutines::SafeFetchN_stub()(adr, errValue);
+}
+
+
+// returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)
+inline bool CanUseSafeFetch32() {
+  return StubRoutines::SafeFetch32_stub() ? true : false;
+}
+
+inline bool CanUseSafeFetchN() {
+  return StubRoutines::SafeFetchN_stub() ? true : false;
+}
 #endif // SHARE_RUNTIME_STUBROUTINES_HPP
diff --git a/src/hotspot/share/runtime/stubRoutines.inline.hpp b/src/hotspot/share/runtime/stubRoutines.inline.hpp
deleted file mode 100644
index 9af224cd66a..00000000000
--- a/src/hotspot/share/runtime/stubRoutines.inline.hpp
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-
-#ifndef SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
-#define SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
-
-#include "runtime/thread.hpp"
-#include "runtime/threadWXSetters.hpp"
-#include "runtime/stubRoutines.hpp"
-
-// Safefetch allows to load a value from a location that's not known
-// to be valid. If the load causes a fault, the error value is returned.
-inline int SafeFetch32(int* adr, int errValue) {
-  assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
-  return StubRoutines::SafeFetch32_stub()(adr, errValue);
-}
-inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
-  assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
-  return StubRoutines::SafeFetchN_stub()(adr, errValue);
-}
-
-
-// returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)
-inline bool CanUseSafeFetch32() {
-  return StubRoutines::SafeFetch32_stub() ? true : false;
-}
-
-inline bool CanUseSafeFetchN() {
-  return StubRoutines::SafeFetchN_stub() ? true : false;
-}
-
-#endif // SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
diff --git a/src/hotspot/share/utilities/vmError.cpp b/src/hotspot/share/utilities/vmError.cpp
index 4094139b6e2..1f8ab5b3537 100644
--- a/src/hotspot/share/utilities/vmError.cpp
+++ b/src/hotspot/share/utilities/vmError.cpp
@@ -44,7 +44,6 @@
 #include "runtime/os.hpp"
 #include "runtime/osThread.hpp"
 #include "runtime/safepointMechanism.hpp"
-#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 #include "runtime/vmThread.hpp"
diff --git a/test/hotspot/gtest/runtime/test_safefetch.cpp b/test/hotspot/gtest/runtime/test_safefetch.cpp
index 14e79a3160e..25d5fb092ec 100644
--- a/test/hotspot/gtest/runtime/test_safefetch.cpp
+++ b/test/hotspot/gtest/runtime/test_safefetch.cpp
@@ -24,7 +24,7 @@
 
 #include "precompiled.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
-#include "runtime/stubRoutines.inline.hpp"
+#include "runtime/stubRoutines.hpp"
 #include "runtime/vmOperations.hpp"
 #include "runtime/vmThread.hpp"
 #include "utilities/globalDefinitions.hpp"

From 07a499c57f2ddb5e03e3bb6bd5e238adf68b107e Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Wed, 17 Feb 2021 00:17:25 -0800
Subject: [PATCH 73/94] Re-do safefetch.hpp

---
 src/hotspot/share/runtime/safefetch.hpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/hotspot/share/runtime/safefetch.hpp b/src/hotspot/share/runtime/safefetch.hpp
index d03394787ea..757df3e23ad 100644
--- a/src/hotspot/share/runtime/safefetch.hpp
+++ b/src/hotspot/share/runtime/safefetch.hpp
@@ -25,17 +25,20 @@
 #ifndef SHARE_RUNTIME_SAFEFETCH_HPP
 #define SHARE_RUNTIME_SAFEFETCH_HPP
 
+#include "runtime/threadWXSetters.hpp"
 #include "runtime/stubRoutines.hpp"
 
 // Safefetch allows to load a value from a location that's not known
 // to be valid. If the load causes a fault, the error value is returned.
 inline int SafeFetch32(int* adr, int errValue) {
   assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
   return StubRoutines::SafeFetch32_stub()(adr, errValue);
 }
 
 inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
   assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
   return StubRoutines::SafeFetchN_stub()(adr, errValue);
 }
 

From 5bf2d825657ddf93961bb55b8a0c33af5041ad52 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Fri, 26 Feb 2021 15:43:03 +0300
Subject: [PATCH 74/94] Fix build after merge with master

---
 src/hotspot/share/utilities/nativeCallStack.cpp | 13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)

diff --git a/src/hotspot/share/utilities/nativeCallStack.cpp b/src/hotspot/share/utilities/nativeCallStack.cpp
index 9c2cc2a7508..2dff574bfe7 100644
--- a/src/hotspot/share/utilities/nativeCallStack.cpp
+++ b/src/hotspot/share/utilities/nativeCallStack.cpp
@@ -32,14 +32,13 @@ const NativeCallStack NativeCallStack::_empty_stack; // Uses default ctor
 
 NativeCallStack::NativeCallStack(int toSkip) {
 
-  if (fillStack) {
-    // We need to skip the NativeCallStack::NativeCallStack frame if a tail call is NOT used
-    // to call os::get_native_stack. A tail call is used if _NMT_NOINLINE_ is not defined
-    // (which means this is not a slowdebug build), and we are on 64-bit (except Windows).
-    // This is not necessarily a rule, but what has been obvserved to date.
+  // We need to skip the NativeCallStack::NativeCallStack frame if a tail call is NOT used
+  // to call os::get_native_stack. A tail call is used if _NMT_NOINLINE_ is not defined
+  // (which means this is not a slowdebug build), and we are on 64-bit (except Windows).
+  // This is not necessarily a rule, but what has been obvserved to date.
 #if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64) || defined(PPC64) || (defined(BSD) && defined (__aarch64__)))
-    // Not a tail call.
-    toSkip++;
+  // Not a tail call.
+  toSkip++;
 #if (defined(_NMT_NOINLINE_) && defined(BSD) && defined(_LP64))
   // Mac OS X slowdebug builds have this odd behavior where NativeCallStack::NativeCallStack
   // appears as two frames, so we need to skip an extra frame.

From 56416b5c89f98f02137130a5027d0b379fad0435 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 26 Feb 2021 08:28:40 -0800
Subject: [PATCH 75/94] Minor fixes

---
 .../cpu/aarch64/sharedRuntime_aarch64.cpp     |  4 +-
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.cpp     | 80 -------------------
 src/hotspot/share/prims/jni.cpp               |  2 +-
 src/hotspot/share/prims/nativeEntryPoint.cpp  |  2 +-
 src/hotspot/share/runtime/globals.hpp         |  2 +-
 5 files changed, 5 insertions(+), 85 deletions(-)

diff --git a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
index 2f9d20a0f54..199448873c8 100644
--- a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
@@ -815,7 +815,7 @@ static int c_calling_convention_priv(const BasicType *sig_bt,
         } else {
 #ifdef __APPLE__
           // Less-than word types are stored one after another.
-          // The code unable to handle this, bailout.
+          // The code is unable to handle this so bailout.
           return -1;
 #endif
           regs[i].set1(VMRegImpl::stack2reg(stk_args));
@@ -842,7 +842,7 @@ static int c_calling_convention_priv(const BasicType *sig_bt,
         } else {
 #ifdef __APPLE__
           // Less-than word types are stored one after another.
-          // The code unable to handle this, bailout.
+          // The code is unable to handle this so bailout.
           return -1;
 #endif
           regs[i].set1(VMRegImpl::stack2reg(stk_args));
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index 710ae3281ea..e4389362d10 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -174,8 +174,6 @@ frame os::fetch_compiled_frame_from_context(const void* ucVoid) {
   return frame(sp, fp, pc);
 }
 
-// By default, gcc always saves frame pointer rfp on this stack. This
-// may get turned off by -fomit-frame-pointer.
 frame os::get_sender_for_C_frame(frame* fr) {
   return frame(fr->link(), fr->link(), fr->sender_pc());
 }
@@ -320,50 +318,6 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
     }
   }
 
-#if defined(ASSERT) && defined(__APPLE__)
-  // Execution protection violation
-  //
-  // This should be kept as the last step in the triage.  We don't
-  // have a dedicated trap number for a no-execute fault, so be
-  // conservative and allow other handlers the first shot.
-  if (UnguardOnExecutionViolation > 0 &&
-      (sig == SIGBUS)) {
-    static __thread address last_addr = (address) -1;
-
-    address addr = (address) info->si_addr;
-    address pc = os::Posix::ucontext_get_pc(uc);
-
-    if (pc != addr && uc->context_esr == 0x9200004F) { //TODO: figure out what this value means
-      // We are faulting trying to write a R-X page
-      pthread_jit_write_protect_np(false);
-
-      log_debug(os)("Writing protection violation "
-                    "at " INTPTR_FORMAT
-                    ", unprotecting", p2i(addr));
-
-      stub = pc;
-
-      last_addr = (address) -1;
-    } else if (pc == addr && uc->context_esr == 0x8200000f) { //TODO: figure out what this value means
-      // We are faulting trying to execute a RW- page
-
-      if (addr != last_addr) {
-        pthread_jit_write_protect_np(true);
-
-        log_debug(os)("Execution protection violation "
-                      "at " INTPTR_FORMAT
-                      ", protecting", p2i(addr));
-
-        stub = pc;
-
-        // Set last_addr so if we fault again at the same address, we don't end
-        // up in an endless loop.
-        last_addr = addr;
-      }
-    }
-  }
-#endif
-
   if (stub != NULL) {
     // save all thread context in case we need to restore it
     if (thread != NULL) thread->set_saved_exception_pc(pc);
@@ -398,40 +352,6 @@ size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
   return s;
 }
 
-
-// Java thread:
-//
-//   Low memory addresses
-//    +------------------------+
-//    |                        |\  Java thread created by VM does not have glibc
-//    |    glibc guard page    | - guard, attached Java thread usually has
-//    |                        |/  1 glibc guard page.
-// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
-//    |                        |\
-//    |  HotSpot Guard Pages   | - red, yellow and reserved pages
-//    |                        |/
-//    +------------------------+ JavaThread::stack_reserved_zone_base()
-//    |                        |\
-//    |      Normal Stack      | -
-//    |                        |/
-// P2 +------------------------+ Thread::stack_base()
-//
-// Non-Java thread:
-//
-//   Low memory addresses
-//    +------------------------+
-//    |                        |\
-//    |  glibc guard page      | - usually 1 page
-//    |                        |/
-// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
-//    |                        |\
-//    |      Normal Stack      | -
-//    |                        |/
-// P2 +------------------------+ Thread::stack_base()
-//
-// ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from
-//    pthread_attr_getstack()
-
 static void current_stack_region(address * bottom, size_t * size) {
 #ifdef __APPLE__
   pthread_t self = pthread_self();
diff --git a/src/hotspot/share/prims/jni.cpp b/src/hotspot/share/prims/jni.cpp
index ead6a1f0c37..3e8e10c2092 100644
--- a/src/hotspot/share/prims/jni.cpp
+++ b/src/hotspot/share/prims/jni.cpp
@@ -3926,7 +3926,7 @@ jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
   thread->smr_delete();
 
   // Go to the execute mode, the initial state of the thread on creation.
-  // Use os interface as the thread is not a java one anymore.
+  // Use os interface as the thread is not a JavaThread anymore.
   MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));
 
   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
diff --git a/src/hotspot/share/prims/nativeEntryPoint.cpp b/src/hotspot/share/prims/nativeEntryPoint.cpp
index 4ec84bed355..2ec76da7290 100644
--- a/src/hotspot/share/prims/nativeEntryPoint.cpp
+++ b/src/hotspot/share/prims/nativeEntryPoint.cpp
@@ -41,4 +41,4 @@ JNI_LEAF(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class
   int status = env->RegisterNatives(NEP_class, NEP_methods, sizeof(NEP_methods)/sizeof(JNINativeMethod));
   guarantee(status == JNI_OK && !env->ExceptionOccurred(),
             "register jdk.internal.invoke.NativeEntryPoint natives");
-JNI_END
+JNI_END
\ No newline at end of file
diff --git a/src/hotspot/share/runtime/globals.hpp b/src/hotspot/share/runtime/globals.hpp
index 425328727ce..cfe5fd8116c 100644
--- a/src/hotspot/share/runtime/globals.hpp
+++ b/src/hotspot/share/runtime/globals.hpp
@@ -1852,7 +1852,7 @@ const intx ObjectAlignmentInBytes = 8;
           "Bypass Win32 file system criteria checks (Windows Only)")        \
                                                                             \
   product(intx, UnguardOnExecutionViolation, 0,                             \
-          "Unguard page and retry on no-execute fault "                     \
+          "Unguard page and retry on no-execute fault (Win32 only) "        \
           "0=off, 1=conservative, 2=aggressive")                            \
           range(0, 2)                                                       \
                                                                             \

From e42b82dbc0ef8747641e5d258ff2f9ed6967c618 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Mon, 1 Mar 2021 23:41:06 -0800
Subject: [PATCH 76/94] Update comments

---
 src/hotspot/cpu/aarch64/vm_version_aarch64.hpp    | 3 +++
 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp | 1 +
 2 files changed, 4 insertions(+)

diff --git a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
index 548464d50c0..3b3a21daa54 100644
--- a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
@@ -76,6 +76,9 @@ class VM_Version : public Abstract_VM_Version {
   // The CPU implementer codes can be found in
   // ARM Architecture Reference Manual ARMv8, for ARMv8-A architecture profile
   // https://developer.arm.com/docs/ddi0487/latest
+  // Arm can assign codes that are not published in the manual.
+  // Apple's code is defined in
+  // https://github.com/apple/darwin-xnu/blob/33eb983/osfmk/arm/cpuid.h#L62
   enum Family {
     CPU_AMPERE    = 0xC0,
     CPU_ARM       = 'A',
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index e4389362d10..3a67f34a34f 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -174,6 +174,7 @@ frame os::fetch_compiled_frame_from_context(const void* ucVoid) {
   return frame(sp, fp, pc);
 }
 
+// JVM compiled with -fno-omit-frame-pointer, so RFP is saved on the stack.
 frame os::get_sender_for_C_frame(frame* fr) {
   return frame(fr->link(), fr->link(), fr->sender_pc());
 }

From 097cd890791f3805b1a8bdd98895233e75be1743 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 2 Mar 2021 06:31:21 -0800
Subject: [PATCH 77/94] Cleanup os_bsd_aarch64 signal handling

---
 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp | 10 +---------
 1 file changed, 1 insertion(+), 9 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index 3a67f34a34f..ee750133a1e 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -277,10 +277,7 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
         }
 
         return false;
-      }
-      else
-
-      if (sig == SIGFPE  &&
+      } else if (sig == SIGFPE &&
           (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {
         stub =
           SharedRuntime::
@@ -288,11 +285,6 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
                                               pc,
                                               SharedRuntime::
                                               IMPLICIT_DIVIDE_BY_ZERO);
-#ifdef __APPLE__
-      } else if (sig == SIGFPE && info->si_code == FPE_NOOP) {
-        Unimplemented();
-#endif /* __APPLE__ */
-
       } else if ((sig == SIGSEGV || sig == SIGBUS) &&
                  MacroAssembler::uses_implicit_null_check(info->si_addr)) {
           // Determination of interpreter/vtable stub/compiled code null exception

From e538ae6d94116a67a34cc24057e7a91f469c5b3e Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 2 Mar 2021 06:36:01 -0800
Subject: [PATCH 78/94] JDK-8257828: bsd_aarch64 part

---
 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index ee750133a1e..f53ac9c0103 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -207,11 +207,6 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
   if (info != NULL && uc != NULL && thread != NULL) {
     pc = (address) os::Posix::ucontext_get_pc(uc);
 
-    if (StubRoutines::is_safefetch_fault(pc)) {
-      os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
-      return true;
-    }
-
     // Handle ALL stack overflow variations here
     if (sig == SIGSEGV || sig == SIGBUS) {
       address addr = (address) info->si_addr;

From 74063fa65c380aba1b52742bf6e5457f2ff0ffe9 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 2 Mar 2021 06:40:26 -0800
Subject: [PATCH 79/94] JDK-8259539: bsd_aarch64 part

---
 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index f53ac9c0103..c0fe23b1ed8 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -271,7 +271,14 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
           tty->print_cr("trap: %s: (SIGILL)", msg);
         }
 
-        return false;
+        // End life with a fatal error, message and detail message and the context.
+        // Note: no need to do any post-processing here (e.g. signal chaining)
+        va_list va_dummy;
+        VMError::report_and_die(thread, uc, NULL, 0, msg, detail_msg, va_dummy);
+        va_end(va_dummy);
+
+        ShouldNotReachHere();
+
       } else if (sig == SIGFPE &&
           (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {
         stub =

From 5ba8ba7fef465bc4717ed0d775c08c4cbb619249 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 2 Mar 2021 06:41:07 -0800
Subject: [PATCH 80/94] JDK-8260471: bsd_aarch64 part

---
 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index c0fe23b1ed8..75f809fc3a3 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
@@ -27,7 +27,6 @@
 #include "jvm.h"
 #include "asm/macroAssembler.hpp"
 #include "classfile/classLoader.hpp"
-#include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
 #include "code/codeCache.hpp"
 #include "code/icBuffer.hpp"

From 4c37f0681df81cec03b2499e789299241c91660b Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 2 Mar 2021 12:23:17 -0800
Subject: [PATCH 81/94] Fix after JDK-8259539, partially revert preconditions

---
 .../os_cpu/bsd_aarch64/os_bsd_aarch64.cpp     | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index 75f809fc3a3..84f14efe66f 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -191,6 +191,15 @@ NOINLINE frame os::current_frame() {
   }
 }
 
+ATTRIBUTE_PRINTF(6, 7)
+static void report_and_die(Thread* thread, void* context, const char* filename, int lineno, const char* message,
+                             const char* detail_fmt, ...) {
+  va_list va;
+  va_start(va, detail_fmt);
+  VMError::report_and_die(thread, context, filename, lineno, message, detail_fmt, va);
+  va_end(va);
+}
+
 bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
                                              ucontext_t* uc, JavaThread* thread) {
   // Enable WXWrite: this function is called by the signal handler at arbitrary
@@ -265,6 +274,11 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
           stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
         }
       } else if (sig == SIGILL && nativeInstruction_at(pc)->is_stop()) {
+        // Pull a pointer to the error message out of the instruction
+        // stream.
+        const uint64_t *detail_msg_ptr
+          = (uint64_t*)(pc + NativeInstruction::instruction_size);
+        const char *detail_msg = (const char *)*detail_msg_ptr;
         const char *msg = "stop";
         if (TraceTraps) {
           tty->print_cr("trap: %s: (SIGILL)", msg);
@@ -272,10 +286,7 @@ bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,
 
         // End life with a fatal error, message and detail message and the context.
         // Note: no need to do any post-processing here (e.g. signal chaining)
-        va_list va_dummy;
-        VMError::report_and_die(thread, uc, NULL, 0, msg, detail_msg, va_dummy);
-        va_end(va_dummy);
-
+        report_and_die(thread, uc, NULL, 0, msg, "%s", detail_msg);
         ShouldNotReachHere();
 
       } else if (sig == SIGFPE &&

From d1783762d9a9b29e9fdf6784a911d6dfb31b0479 Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Tue, 9 Mar 2021 15:48:07 +0300
Subject: [PATCH 82/94] workaround JDK-8262895 by disabling subtest

---
 .../runtime/CompressedOops/CompressedClassPointers.java   | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/test/hotspot/jtreg/runtime/CompressedOops/CompressedClassPointers.java b/test/hotspot/jtreg/runtime/CompressedOops/CompressedClassPointers.java
index 762eafa8f6d..e2950b92878 100644
--- a/test/hotspot/jtreg/runtime/CompressedOops/CompressedClassPointers.java
+++ b/test/hotspot/jtreg/runtime/CompressedOops/CompressedClassPointers.java
@@ -125,9 +125,11 @@ public static void largeHeapAbove32GTest() throws Exception {
             "-XX:+VerifyBeforeGC", "-version");
         OutputAnalyzer output = new OutputAnalyzer(pb.start());
         if (testNarrowKlassBase()) {
-            output.shouldContain("Narrow klass base: 0x0000000000000000");
-            if (!Platform.isAArch64() && !Platform.isOSX()) {
-                output.shouldContain("Narrow klass shift: 0");
+            if (!(Platform.isAArch64() && Platform.isOSX())) { // see JDK-8262895
+                output.shouldContain("Narrow klass base: 0x0000000000000000");
+                if (!Platform.isAArch64() && !Platform.isOSX()) {
+                    output.shouldContain("Narrow klass shift: 0");
+                }
             }
         }
         output.shouldHaveExitValue(0);

From 416e433638a3cbac06417f1138f9d5def996d408 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 9 Mar 2021 07:40:23 -0800
Subject: [PATCH 83/94] JDK-8259937: bsd_aarch64 part

---
 src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
index f91fb7dd14b..c10f0da1003 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
@@ -38,10 +38,6 @@
     return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();
   }
 
-  static ByteSize saved_fp_address_offset() {
-    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::saved_fp_address_offset();
-  }
-
   bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,
     bool isInJava);
 

From acda02f27902ea084ca47f841e5dc18d6cdef08b Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 9 Mar 2021 07:46:42 -0800
Subject: [PATCH 84/94] Rename threadWXSetters.hpp ->
 threadWXSetters.inline.hpp

---
 src/hotspot/share/gc/shared/barrierSetNMethod.cpp           | 2 +-
 src/hotspot/share/opto/runtime.cpp                          | 2 +-
 src/hotspot/share/runtime/deoptimization.cpp                | 2 +-
 src/hotspot/share/runtime/interfaceSupport.inline.hpp       | 2 +-
 src/hotspot/share/runtime/safefetch.inline.hpp              | 2 +-
 src/hotspot/share/runtime/safepoint.cpp                     | 2 +-
 src/hotspot/share/runtime/thread.cpp                        | 2 +-
 .../{threadWXSetters.hpp => threadWXSetters.inline.hpp}     | 6 +++---
 8 files changed, 10 insertions(+), 10 deletions(-)
 rename src/hotspot/share/runtime/{threadWXSetters.hpp => threadWXSetters.inline.hpp} (90%)

diff --git a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
index cb844e7b4c2..cf046b35718 100644
--- a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
+++ b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
@@ -29,7 +29,7 @@
 #include "gc/shared/barrierSetNMethod.hpp"
 #include "logging/log.hpp"
 #include "runtime/thread.hpp"
-#include "runtime/threadWXSetters.hpp"
+#include "runtime/threadWXSetters.inline.hpp"
 #include "utilities/debug.hpp"
 
 int BarrierSetNMethod::disarmed_value() const {
diff --git a/src/hotspot/share/opto/runtime.cpp b/src/hotspot/share/opto/runtime.cpp
index 10d918c0a80..191e909e377 100644
--- a/src/hotspot/share/opto/runtime.cpp
+++ b/src/hotspot/share/opto/runtime.cpp
@@ -72,7 +72,7 @@
 #include "runtime/signature.hpp"
 #include "runtime/stackWatermarkSet.hpp"
 #include "runtime/threadCritical.hpp"
-#include "runtime/threadWXSetters.hpp"
+#include "runtime/threadWXSetters.inline.hpp"
 #include "runtime/vframe.hpp"
 #include "runtime/vframeArray.hpp"
 #include "runtime/vframe_hp.hpp"
diff --git a/src/hotspot/share/runtime/deoptimization.cpp b/src/hotspot/share/runtime/deoptimization.cpp
index e71e3072b2c..23202fb4d77 100644
--- a/src/hotspot/share/runtime/deoptimization.cpp
+++ b/src/hotspot/share/runtime/deoptimization.cpp
@@ -75,7 +75,7 @@
 #include "runtime/stubRoutines.hpp"
 #include "runtime/thread.hpp"
 #include "runtime/threadSMR.hpp"
-#include "runtime/threadWXSetters.hpp"
+#include "runtime/threadWXSetters.inline.hpp"
 #include "runtime/vframe.hpp"
 #include "runtime/vframeArray.hpp"
 #include "runtime/vframe_hp.hpp"
diff --git a/src/hotspot/share/runtime/interfaceSupport.inline.hpp b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
index d39cd1466c2..24fdd81cc88 100644
--- a/src/hotspot/share/runtime/interfaceSupport.inline.hpp
+++ b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
@@ -33,7 +33,7 @@
 #include "runtime/safepointMechanism.inline.hpp"
 #include "runtime/safepointVerifiers.hpp"
 #include "runtime/thread.hpp"
-#include "runtime/threadWXSetters.hpp"
+#include "runtime/threadWXSetters.inline.hpp"
 #include "runtime/vmOperations.hpp"
 #include "utilities/globalDefinitions.hpp"
 #include "utilities/macros.hpp"
diff --git a/src/hotspot/share/runtime/safefetch.inline.hpp b/src/hotspot/share/runtime/safefetch.inline.hpp
index f9b6d7e028b..78d651e2734 100644
--- a/src/hotspot/share/runtime/safefetch.inline.hpp
+++ b/src/hotspot/share/runtime/safefetch.inline.hpp
@@ -26,7 +26,7 @@
 #define SHARE_RUNTIME_SAFEFETCH_INLINE_HPP
 
 #include "runtime/stubRoutines.hpp"
-#include "runtime/threadWXSetters.hpp"
+#include "runtime/threadWXSetters.inline.hpp"
 
 // Safefetch allows to load a value from a location that's not known
 // to be valid. If the load causes a fault, the error value is returned.
diff --git a/src/hotspot/share/runtime/safepoint.cpp b/src/hotspot/share/runtime/safepoint.cpp
index 1c623d51ce2..666c4db6aac 100644
--- a/src/hotspot/share/runtime/safepoint.cpp
+++ b/src/hotspot/share/runtime/safepoint.cpp
@@ -64,7 +64,7 @@
 #include "runtime/synchronizer.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
-#include "runtime/threadWXSetters.hpp"
+#include "runtime/threadWXSetters.inline.hpp"
 #include "runtime/timerTrace.hpp"
 #include "services/runtimeService.hpp"
 #include "utilities/events.hpp"
diff --git a/src/hotspot/share/runtime/thread.cpp b/src/hotspot/share/runtime/thread.cpp
index caa5d5e4176..c95cb6153b6 100644
--- a/src/hotspot/share/runtime/thread.cpp
+++ b/src/hotspot/share/runtime/thread.cpp
@@ -106,7 +106,7 @@
 #include "runtime/threadCritical.hpp"
 #include "runtime/threadSMR.inline.hpp"
 #include "runtime/threadStatisticalInfo.hpp"
-#include "runtime/threadWXSetters.hpp"
+#include "runtime/threadWXSetters.inline.hpp"
 #include "runtime/timer.hpp"
 #include "runtime/timerTrace.hpp"
 #include "runtime/vframe.inline.hpp"
diff --git a/src/hotspot/share/runtime/threadWXSetters.hpp b/src/hotspot/share/runtime/threadWXSetters.inline.hpp
similarity index 90%
rename from src/hotspot/share/runtime/threadWXSetters.hpp
rename to src/hotspot/share/runtime/threadWXSetters.inline.hpp
index e4d78b52762..063730551ab 100644
--- a/src/hotspot/share/runtime/threadWXSetters.hpp
+++ b/src/hotspot/share/runtime/threadWXSetters.inline.hpp
@@ -22,8 +22,8 @@
  *
  */
 
-#ifndef SHARE_RUNTIME_THREADWXSETTERS_HPP
-#define SHARE_RUNTIME_THREADWXSETTERS_HPP
+#ifndef SHARE_RUNTIME_THREADWXSETTERS_INLINE_HPP
+#define SHARE_RUNTIME_THREADWXSETTERS_INLINE_HPP
 
 #include "runtime/thread.inline.hpp"
 
@@ -42,5 +42,5 @@ class ThreadWXEnable  {
 };
 #endif // __APPLE__ && AARCH64
 
-#endif // SHARE_RUNTIME_THREADWXSETTERS_HPP
+#endif // SHARE_RUNTIME_THREADWXSETTERS_INLINE_HPP
 

From c4947cc7fe03ad52b36208f6d7ae23920d861cf3 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Tue, 9 Mar 2021 07:47:36 -0800
Subject: [PATCH 85/94] Fix typo

---
 src/hotspot/share/gc/shared/barrierSetNMethod.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
index cf046b35718..30dd852a83c 100644
--- a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
+++ b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
@@ -49,7 +49,7 @@ bool BarrierSetNMethod::supports_entry_barrier(nmethod* nm) {
 }
 
 int BarrierSetNMethod::nmethod_stub_entry_barrier(address* return_address_ptr) {
-  // Enable WXWrite: the function is called direclty from nmethod_entry_barrier
+  // Enable WXWrite: the function is called directly from nmethod_entry_barrier
   // stub.
   MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite));
 

From f6fb01b24f525e578692a1c6f2ff0a55b8233576 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Wed, 10 Mar 2021 07:06:31 -0800
Subject: [PATCH 86/94] 8262903: [macos_aarch64] Thread::current() called on
 detached thread

---
 src/hotspot/share/gc/shared/barrierSetNMethod.cpp     |  2 +-
 src/hotspot/share/prims/unsafe.cpp                    |  4 ++--
 src/hotspot/share/runtime/interfaceSupport.inline.hpp |  3 ++-
 src/hotspot/share/runtime/safefetch.inline.hpp        |  4 ++--
 src/hotspot/share/runtime/threadWXSetters.inline.hpp  | 10 ++++++----
 5 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
index 30dd852a83c..31dbce73925 100644
--- a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
+++ b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
@@ -51,7 +51,7 @@ bool BarrierSetNMethod::supports_entry_barrier(nmethod* nm) {
 int BarrierSetNMethod::nmethod_stub_entry_barrier(address* return_address_ptr) {
   // Enable WXWrite: the function is called directly from nmethod_entry_barrier
   // stub.
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite));
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current()));
 
   address return_address = *return_address_ptr;
   CodeBlob* cb = CodeCache::find_blob(return_address);
diff --git a/src/hotspot/share/prims/unsafe.cpp b/src/hotspot/share/prims/unsafe.cpp
index 8c0f82a3e91..8134136035b 100644
--- a/src/hotspot/share/prims/unsafe.cpp
+++ b/src/hotspot/share/prims/unsafe.cpp
@@ -459,14 +459,14 @@ UNSAFE_LEAF (void, Unsafe_WriteBack0(JNIEnv *env, jobject unsafe, jlong line)) {
   }
 #endif
 
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current()));
   assert(StubRoutines::data_cache_writeback() != NULL, "sanity");
   (StubRoutines::DataCacheWriteback_stub())(addr_from_java(line));
 } UNSAFE_END
 
 static void doWriteBackSync0(bool is_pre)
 {
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current()));
   assert(StubRoutines::data_cache_writeback_sync() != NULL, "sanity");
   (StubRoutines::DataCacheWritebackSync_stub())(is_pre);
 }
diff --git a/src/hotspot/share/runtime/interfaceSupport.inline.hpp b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
index 24fdd81cc88..7ffcc081d5b 100644
--- a/src/hotspot/share/runtime/interfaceSupport.inline.hpp
+++ b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
@@ -336,7 +336,8 @@ class VMNativeEntryWrapper {
 
 #define VM_LEAF_BASE(result_type, header)                            \
   debug_only(NoHandleMark __hm;)                                     \
-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite));                  \
+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite,                    \
+                                         Thread::current()));        \
   os::verify_stack_alignment();                                      \
   /* begin of body */
 
diff --git a/src/hotspot/share/runtime/safefetch.inline.hpp b/src/hotspot/share/runtime/safefetch.inline.hpp
index 78d651e2734..0a8c64c9d81 100644
--- a/src/hotspot/share/runtime/safefetch.inline.hpp
+++ b/src/hotspot/share/runtime/safefetch.inline.hpp
@@ -32,13 +32,13 @@
 // to be valid. If the load causes a fault, the error value is returned.
 inline int SafeFetch32(int* adr, int errValue) {
   assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current()));
   return StubRoutines::SafeFetch32_stub()(adr, errValue);
 }
 
 inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
   assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec));
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current()));
   return StubRoutines::SafeFetchN_stub()(adr, errValue);
 }
 
diff --git a/src/hotspot/share/runtime/threadWXSetters.inline.hpp b/src/hotspot/share/runtime/threadWXSetters.inline.hpp
index 063730551ab..4b32f3a18fb 100644
--- a/src/hotspot/share/runtime/threadWXSetters.inline.hpp
+++ b/src/hotspot/share/runtime/threadWXSetters.inline.hpp
@@ -32,12 +32,14 @@ class ThreadWXEnable  {
   Thread* _thread;
   WXMode _old_mode;
 public:
-  ThreadWXEnable(WXMode new_mode, Thread* thread = NULL) :
-    _thread(thread ? thread : Thread::current()),
-    _old_mode(_thread->enable_wx(new_mode))
+  ThreadWXEnable(WXMode new_mode, Thread* thread) :
+    _thread(thread),
+    _old_mode(_thread ? _thread->enable_wx(new_mode) : WXWrite)
   { }
   ~ThreadWXEnable() {
-    _thread->enable_wx(_old_mode);
+    if (_thread) {
+      _thread->enable_wx(_old_mode);
+    }
   }
 };
 #endif // __APPLE__ && AARCH64

From fd4812e585e0528010a8863df50956a3b64a6744 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 12 Mar 2021 01:09:40 -0800
Subject: [PATCH 87/94] Use Thread::current_or_null_safe in SafeFetch

---
 src/hotspot/share/runtime/safefetch.inline.hpp | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/hotspot/share/runtime/safefetch.inline.hpp b/src/hotspot/share/runtime/safefetch.inline.hpp
index 0a8c64c9d81..ff23bd6d816 100644
--- a/src/hotspot/share/runtime/safefetch.inline.hpp
+++ b/src/hotspot/share/runtime/safefetch.inline.hpp
@@ -32,13 +32,17 @@
 // to be valid. If the load causes a fault, the error value is returned.
 inline int SafeFetch32(int* adr, int errValue) {
   assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current()));
+  Thread* thread = Thread::current_or_null_safe();
+  assert(thread != NULL, "required for W^X management");
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));
   return StubRoutines::SafeFetch32_stub()(adr, errValue);
 }
 
 inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
   assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current()));
+  Thread* thread = Thread::current_or_null_safe();
+  assert(thread != NULL, "required for W^X management");
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));
   return StubRoutines::SafeFetchN_stub()(adr, errValue);
 }
 

From 127c60e84f91abc0cc1f0f45dced0182eed1837d Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 12 Mar 2021 01:12:41 -0800
Subject: [PATCH 88/94] Update Oracle copyright years

---
 make/autoconf/build-aux/config.guess                            | 2 +-
 make/autoconf/jvm-features.m4                                   | 2 +-
 make/common/NativeCompilation.gmk                               | 2 +-
 make/hotspot/gensrc/GensrcAdlc.gmk                              | 2 +-
 src/hotspot/cpu/aarch64/globalDefinitions_aarch64.hpp           | 2 +-
 src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp               | 2 +-
 src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp               | 2 +-
 src/hotspot/cpu/aarch64/vm_version_aarch64.hpp                  | 2 +-
 src/hotspot/os/posix/signals_posix.cpp                          | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp           | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp     | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp      | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp          | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp           | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp      | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp               | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp  | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp           | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp           | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp        | 2 +-
 src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp       | 2 +-
 src/hotspot/share/gc/shared/barrierSetNMethod.cpp               | 2 +-
 src/hotspot/share/prims/whitebox.inline.hpp                     | 2 +-
 src/hotspot/share/runtime/signature.hpp                         | 2 +-
 src/java.base/macosx/native/libjli/java_md_macosx.m             | 2 +-
 src/java.security.jgss/share/native/libj2gss/gssapi.h           | 2 +-
 src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h    | 2 +-
 src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c         | 2 +-
 .../share/classes/sun/jvm/hotspot/HotSpotAgent.java             | 2 +-
 .../classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java      | 2 +-
 .../sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java   | 2 +-
 .../sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java  | 2 +-
 .../share/classes/sun/jvm/hotspot/runtime/Threads.java          | 2 +-
 .../runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java       | 2 +-
 src/utils/hsdis/Makefile                                        | 2 +-
 test/hotspot/gtest/gtestMain.cpp                                | 2 +-
 .../jtreg/runtime/CompressedOops/CompressedClassPointers.java   | 2 +-
 .../runtime/jni/codegenAttachThread/TestCodegenAttach.java      | 2 +-
 .../jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c    | 2 +-
 .../hotspot/jtreg/vmTestbase/nsk/share/jdi/ArgumentHandler.java | 2 +-
 40 files changed, 40 insertions(+), 40 deletions(-)

diff --git a/make/autoconf/build-aux/config.guess b/make/autoconf/build-aux/config.guess
index 2da3ce1dc0a..85a3c9caefc 100644
--- a/make/autoconf/build-aux/config.guess
+++ b/make/autoconf/build-aux/config.guess
@@ -1,6 +1,6 @@
 #!/bin/sh
 #
-# Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
diff --git a/make/autoconf/jvm-features.m4 b/make/autoconf/jvm-features.m4
index 51ce6da6cfb..fffcc31213f 100644
--- a/make/autoconf/jvm-features.m4
+++ b/make/autoconf/jvm-features.m4
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2011, 2021, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
diff --git a/make/common/NativeCompilation.gmk b/make/common/NativeCompilation.gmk
index f49f8b0fb2b..794f7f1889d 100644
--- a/make/common/NativeCompilation.gmk
+++ b/make/common/NativeCompilation.gmk
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2011, 2021, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
diff --git a/make/hotspot/gensrc/GensrcAdlc.gmk b/make/hotspot/gensrc/GensrcAdlc.gmk
index fb21b31fccf..ba8165c2ff0 100644
--- a/make/hotspot/gensrc/GensrcAdlc.gmk
+++ b/make/hotspot/gensrc/GensrcAdlc.gmk
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2013, 2021, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/cpu/aarch64/globalDefinitions_aarch64.hpp b/src/hotspot/cpu/aarch64/globalDefinitions_aarch64.hpp
index c85ba66bce1..3c779bb11b1 100644
--- a/src/hotspot/cpu/aarch64/globalDefinitions_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/globalDefinitions_aarch64.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2015, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
index 5203740baf3..cedac38eb39 100644
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp
index bfdabc5002b..50eac2fdd6f 100644
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
index 3b3a21daa54..950c11eaf7e 100644
--- a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os/posix/signals_posix.cpp b/src/hotspot/os/posix/signals_posix.cpp
index 69d097026b3..a2bc9d2d544 100644
--- a/src/hotspot/os/posix/signals_posix.cpp
+++ b/src/hotspot/os/posix/signals_posix.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
index eed1dd0c9e6..b97800fed0c 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp b/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
index 1c46c14f092..b48381e2c6a 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
index e353971ad8d..abf48432699 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
index dbe8ffc51b6..32610aa406e 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp
index 457ef4c6bd2..f3c55709052 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
index 93e5bc2f9f6..123b70a79ff 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
index 56bb1f4e70c..699ac5ff77c 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp b/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp
index 3b5f31b35b8..adc878f24ff 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
index e791d7f6746..14e5694b63a 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
index c10f0da1003..7dc48133f8d 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
index 1abe32cf165..4d55f90ed72 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
index 68037726990..18af8511b44 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
index 31dbce73925..f98675d0b23 100644
--- a/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
+++ b/src/hotspot/share/gc/shared/barrierSetNMethod.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/prims/whitebox.inline.hpp b/src/hotspot/share/prims/whitebox.inline.hpp
index 515cad65779..9d391fd14b5 100644
--- a/src/hotspot/share/prims/whitebox.inline.hpp
+++ b/src/hotspot/share/prims/whitebox.inline.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/runtime/signature.hpp b/src/hotspot/share/runtime/signature.hpp
index 0ed57e424a6..a38d74bf77c 100644
--- a/src/hotspot/share/runtime/signature.hpp
+++ b/src/hotspot/share/runtime/signature.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/java.base/macosx/native/libjli/java_md_macosx.m b/src/java.base/macosx/native/libjli/java_md_macosx.m
index d6b13c4afdb..23849bca67a 100644
--- a/src/java.base/macosx/native/libjli/java_md_macosx.m
+++ b/src/java.base/macosx/native/libjli/java_md_macosx.m
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/java.security.jgss/share/native/libj2gss/gssapi.h b/src/java.security.jgss/share/native/libj2gss/gssapi.h
index 467a0b85a6e..44ea62dd085 100644
--- a/src/java.security.jgss/share/native/libj2gss/gssapi.h
+++ b/src/java.security.jgss/share/native/libj2gss/gssapi.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
index f5bdbc2cdd0..7555d098e38 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c b/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
index 4745ec8d53a..c7816b412cf 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java
index 94676356ffe..4de731c3e1a 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
index d5a444a82d9..568c38a4984 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java
index d9c203e16bf..48126ec6695 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
index 4a8927a0194..bb788518158 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2015, Red Hat Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java
index fc2cc3fad19..4a2fa691d3f 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
index ed438b044dc..a4b5a6b8310 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/utils/hsdis/Makefile b/src/utils/hsdis/Makefile
index e585df19a54..1a9c3cd7df2 100644
--- a/src/utils/hsdis/Makefile
+++ b/src/utils/hsdis/Makefile
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2008, 2021, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # The Universal Permissive License (UPL), Version 1.0
diff --git a/test/hotspot/gtest/gtestMain.cpp b/test/hotspot/gtest/gtestMain.cpp
index 33ae9077222..9165a43d3bd 100644
--- a/test/hotspot/gtest/gtestMain.cpp
+++ b/test/hotspot/gtest/gtestMain.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/test/hotspot/jtreg/runtime/CompressedOops/CompressedClassPointers.java b/test/hotspot/jtreg/runtime/CompressedOops/CompressedClassPointers.java
index e2950b92878..c450dd0b268 100644
--- a/test/hotspot/jtreg/runtime/CompressedOops/CompressedClassPointers.java
+++ b/test/hotspot/jtreg/runtime/CompressedOops/CompressedClassPointers.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java
index 333608470b4..9b6ccd67dce 100644
--- a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java
+++ b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c
index 7ea0623def1..1c29ad685a9 100644
--- a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c
+++ b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/ArgumentHandler.java b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/ArgumentHandler.java
index c1c5ff6e740..ac0491cbb0c 100644
--- a/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/ArgumentHandler.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/share/jdi/ArgumentHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it

From 29991c922a83cdf11bc8717b4c8a6723a254f367 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Fri, 12 Mar 2021 01:47:29 -0800
Subject: [PATCH 89/94] Add Azul copyright

---
 make/autoconf/build-aux/config.guess                             | 1 +
 src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp                | 1 +
 src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp                | 1 +
 src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp                | 1 +
 src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp            | 1 +
 src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp      | 1 +
 src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp       | 1 +
 src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s                | 1 +
 src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp           | 1 +
 src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp            | 1 +
 src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp       | 1 +
 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp                | 1 +
 src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp                | 1 +
 src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp   | 1 +
 src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp            | 1 +
 src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp            | 1 +
 src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp         | 1 +
 src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp        | 1 +
 src/hotspot/share/prims/jni.cpp                                  | 1 +
 src/hotspot/share/runtime/interfaceSupport.inline.hpp            | 1 +
 src/hotspot/share/runtime/javaCalls.cpp                          | 1 +
 src/hotspot/share/runtime/signature.hpp                          | 1 +
 src/hotspot/share/runtime/thread.cpp                             | 1 +
 src/hotspot/share/runtime/thread.hpp                             | 1 +
 src/hotspot/share/runtime/thread.inline.hpp                      | 1 +
 src/hotspot/share/runtime/threadWXSetters.inline.hpp             | 1 +
 .../macosx/native/libsaproc/MacosxDebuggerLocal.m                | 1 +
 src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h     | 1 +
 src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c          | 1 +
 .../share/classes/sun/jvm/hotspot/HotSpotAgent.java              | 1 +
 .../share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java | 1 +
 .../sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java   | 1 +
 .../hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java    | 1 +
 .../runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java        | 1 +
 src/utils/hsdis/Makefile                                         | 1 +
 .../jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java | 1 +
 .../jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c     | 1 +
 37 files changed, 37 insertions(+)

diff --git a/make/autoconf/build-aux/config.guess b/make/autoconf/build-aux/config.guess
index 85a3c9caefc..175d445c82f 100644
--- a/make/autoconf/build-aux/config.guess
+++ b/make/autoconf/build-aux/config.guess
@@ -1,6 +1,7 @@
 #!/bin/sh
 #
 # Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
index cedac38eb39..bdb07d17a3a 100644
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp
index 50eac2fdd6f..8f84ebbe114 100644
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 1998, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
index 9494d36aa06..d18056017d0 100644
--- a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
index b97800fed0c..e0c2961e484 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp b/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
index b48381e2c6a..2ea41ef20ec 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
index abf48432699..078a16149b1 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s
index 70b0c24660e..7b286820a9a 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s
+++ b/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2016, Linaro Ltd. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
index 32610aa406e..c18c4506ac9 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp
index f3c55709052..7e9ca43efcf 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/icache_bsd_aarch64.hpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
index 123b70a79ff..ee361aeba4d 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
index 84f14efe66f..d9a54bf695d 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
index 699ac5ff77c..14638bc68d6 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp b/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp
index adc878f24ff..e24d0328e6d 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
index 14e5694b63a..6a6e0d56be4 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
index 7dc48133f8d..82138d35847 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp b/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
index 4d55f90ed72..07b878106cf 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
index 18af8511b44..0133bd75c13 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2006, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/prims/jni.cpp b/src/hotspot/share/prims/jni.cpp
index 3e8e10c2092..66cb8e8740c 100644
--- a/src/hotspot/share/prims/jni.cpp
+++ b/src/hotspot/share/prims/jni.cpp
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2012 Red Hat, Inc.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/runtime/interfaceSupport.inline.hpp b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
index 7ffcc081d5b..25285ae8b7b 100644
--- a/src/hotspot/share/runtime/interfaceSupport.inline.hpp
+++ b/src/hotspot/share/runtime/interfaceSupport.inline.hpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/runtime/javaCalls.cpp b/src/hotspot/share/runtime/javaCalls.cpp
index 2fa8d590cc5..e675c3d9caa 100644
--- a/src/hotspot/share/runtime/javaCalls.cpp
+++ b/src/hotspot/share/runtime/javaCalls.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/runtime/signature.hpp b/src/hotspot/share/runtime/signature.hpp
index a38d74bf77c..2df42dacea4 100644
--- a/src/hotspot/share/runtime/signature.hpp
+++ b/src/hotspot/share/runtime/signature.hpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/runtime/thread.cpp b/src/hotspot/share/runtime/thread.cpp
index c95cb6153b6..231bfe3b3cf 100644
--- a/src/hotspot/share/runtime/thread.cpp
+++ b/src/hotspot/share/runtime/thread.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/runtime/thread.hpp b/src/hotspot/share/runtime/thread.hpp
index 0d5637ef986..34328c27ea1 100644
--- a/src/hotspot/share/runtime/thread.hpp
+++ b/src/hotspot/share/runtime/thread.hpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/runtime/thread.inline.hpp b/src/hotspot/share/runtime/thread.inline.hpp
index 658f67dd735..7d294f02ac3 100644
--- a/src/hotspot/share/runtime/thread.inline.hpp
+++ b/src/hotspot/share/runtime/thread.inline.hpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/hotspot/share/runtime/threadWXSetters.inline.hpp b/src/hotspot/share/runtime/threadWXSetters.inline.hpp
index 4b32f3a18fb..02e200072a6 100644
--- a/src/hotspot/share/runtime/threadWXSetters.inline.hpp
+++ b/src/hotspot/share/runtime/threadWXSetters.inline.hpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
index e6af2a65b88..f229f754a1c 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2002, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
index 7555d098e38..edd3d666f7f 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c b/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
index c7816b412cf..992df0eacaf 100644
--- a/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
+++ b/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java
index 4de731c3e1a..766ee47fed4 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
index 568c38a4984..d8fb562bfcc 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
index bb788518158..845e1b5ea70 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2015, Red Hat Inc.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
index c1effb4598f..a8c1442c80a 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
index a4b5a6b8310..4ab4e11f85a 100644
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/src/utils/hsdis/Makefile b/src/utils/hsdis/Makefile
index 1a9c3cd7df2..66dac7130bd 100644
--- a/src/utils/hsdis/Makefile
+++ b/src/utils/hsdis/Makefile
@@ -1,5 +1,6 @@
 #
 # Copyright (c) 2008, 2021, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # The Universal Permissive License (UPL), Version 1.0
diff --git a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java
index 9b6ccd67dce..9c63da160c0 100644
--- a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java
+++ b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/TestCodegenAttach.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
diff --git a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c
index 1c29ad685a9..c516618b1ca 100644
--- a/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c
+++ b/test/hotspot/jtreg/runtime/jni/codegenAttachThread/libcodegenAttach.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it

From 5bfe0f087b52551badf99f480aaae6b27b90544e Mon Sep 17 00:00:00 2001
From: Vladimir Kempik <vkempik@azul.com>
Date: Fri, 12 Mar 2021 08:07:57 -0800
Subject: [PATCH 90/94] Fix most of issues in java/foreign/ tests

Failures related to va_args are tracked in JDK-8263512.
---
 src/hotspot/share/prims/universalNativeInvoker.cpp | 1 +
 src/hotspot/share/prims/universalUpcallHandler.cpp | 5 ++++-
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/hotspot/share/prims/universalNativeInvoker.cpp b/src/hotspot/share/prims/universalNativeInvoker.cpp
index bb1bbcd4eca..e2b1f542928 100644
--- a/src/hotspot/share/prims/universalNativeInvoker.cpp
+++ b/src/hotspot/share/prims/universalNativeInvoker.cpp
@@ -31,6 +31,7 @@ ProgrammableInvoker::Generator::Generator(CodeBuffer* code, const ABIDescriptor*
     _layout(layout) {}
 
 void ProgrammableInvoker::invoke_native(Stub stub, address buff, JavaThread* thread) {
+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));
   ThreadToNativeFromVM ttnfvm(thread);
   stub(buff);
 }
diff --git a/src/hotspot/share/prims/universalUpcallHandler.cpp b/src/hotspot/share/prims/universalUpcallHandler.cpp
index 66cd4dbfb29..fac781048d4 100644
--- a/src/hotspot/share/prims/universalUpcallHandler.cpp
+++ b/src/hotspot/share/prims/universalUpcallHandler.cpp
@@ -61,7 +61,10 @@ void ProgrammableUpcallHandler::attach_thread_and_do_upcall(jobject rec, address
     thread = Thread::current();
   }
 
-  upcall_helper(thread->as_Java_thread(), rec, buff);
+  {
+    MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));
+    upcall_helper(thread->as_Java_thread(), rec, buff);
+  }
 
   if (should_detach) {
     JavaVM_ *vm = (JavaVM *)(&main_vm);

From 3d0f4d2342adc867eaf762fa83a9c3035d6439bd Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Mon, 15 Mar 2021 10:12:40 -0700
Subject: [PATCH 91/94] Wider #ifdef block

---
 src/hotspot/share/runtime/safefetch.inline.hpp | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/hotspot/share/runtime/safefetch.inline.hpp b/src/hotspot/share/runtime/safefetch.inline.hpp
index ff23bd6d816..ed4070810b9 100644
--- a/src/hotspot/share/runtime/safefetch.inline.hpp
+++ b/src/hotspot/share/runtime/safefetch.inline.hpp
@@ -32,17 +32,21 @@
 // to be valid. If the load causes a fault, the error value is returned.
 inline int SafeFetch32(int* adr, int errValue) {
   assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
+#if defined(__APPLE__) && defined(AARCH64)
   Thread* thread = Thread::current_or_null_safe();
   assert(thread != NULL, "required for W^X management");
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));
+  ThreadWXEnable wx(WXExec, thread);
+#endif // __APPLE__ && AARCH64
   return StubRoutines::SafeFetch32_stub()(adr, errValue);
 }
 
 inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
   assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
+#if defined(__APPLE__) && defined(AARCH64)
   Thread* thread = Thread::current_or_null_safe();
   assert(thread != NULL, "required for W^X management");
-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));
+  ThreadWXEnable wx(WXExec, thread);
+#endif // __APPLE__ && AARCH64
   return StubRoutines::SafeFetchN_stub()(adr, errValue);
 }
 

From 6e39762ed0b874430c030f8e371001518143de83 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Mon, 15 Mar 2021 11:04:58 -0700
Subject: [PATCH 92/94] JDK-8263002: bsd_aarch64 part

---
 src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
index 6a6e0d56be4..054f07f9f6d 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
@@ -72,12 +72,6 @@ bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava)
       return false;
     }
 
-    if (MetaspaceShared::is_in_trampoline_frame(addr)) {
-      // In the middle of a trampoline call. Bail out for safety.
-      // This happens rarely so shouldn't affect profiling.
-      return false;
-    }
-
     frame ret_frame(ret_sp, ret_fp, addr);
     if (!ret_frame.safe_for_sender(jt)) {
 #if COMPILER2_OR_JVMCI

From 806fc618beb21dd6ddb8d5cddeaafb5b51226070 Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Mon, 15 Mar 2021 11:16:04 -0700
Subject: [PATCH 93/94] JDK-8262491: bsd_aarch64 part

---
 src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
index 0133bd75c13..3ad2f721e43 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
@@ -91,3 +91,9 @@ void VM_Version::get_os_cpu_info() {
   _model = family;
   _cpu = CPU_APPLE;
 }
+
+void VM_Version::get_compatible_board(char *buf, int buflen) {
+  assert(buf != NULL, "invalid argument");
+  assert(buflen >= 1, "invalid argument");
+  *buf = '\0';
+}

From d3629967c7f4438c3343e9e0afa7e34ebd09078e Mon Sep 17 00:00:00 2001
From: Anton Kozlov <akozlov@azul.com>
Date: Thu, 25 Mar 2021 09:10:25 -0700
Subject: [PATCH 94/94] JDK-8261397: bsd_aarch64 part

---
 src/hotspot/cpu/aarch64/vm_version_aarch64.hpp            | 5 +++++
 src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp | 8 ++++++++
 2 files changed, 13 insertions(+)

diff --git a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
index 1cbcfd479ea..37ea7549a11 100644
--- a/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
@@ -136,6 +136,11 @@ class VM_Version : public Abstract_VM_Version {
   constexpr static bool supports_stack_watermark_barrier() { return true; }
 
   static void get_compatible_board(char *buf, int buflen);
+
+#ifdef __APPLE__
+  // Is the CPU running emulated (for example macOS Rosetta running x86_64 code on M1 ARM (aarch64)
+  static bool is_cpu_emulated();
+#endif
 };
 
 #endif // CPU_AARCH64_VM_VERSION_AARCH64_HPP
diff --git a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
index 3ad2f721e43..3d49ecf54ff 100644
--- a/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
+++ b/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
@@ -97,3 +97,11 @@ void VM_Version::get_compatible_board(char *buf, int buflen) {
   assert(buflen >= 1, "invalid argument");
   *buf = '\0';
 }
+
+#ifdef __APPLE__
+
+bool VM_Version::is_cpu_emulated() {
+  return false;
+}
+
+#endif
