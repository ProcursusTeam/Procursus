--- src/exec.cpp	2021-04-07 07:31:43.000000000 -0500
+++ src/exec.cpp	2021-04-30 16:56:56.000000000 -0500
@@ -65,6 +65,93 @@
 /// This function is executed by the child process created by a call to fork(). It should be called
 /// after \c child_setup_process. It calls execve to replace the fish process image with the command
 /// specified in \c p. It never returns. Called in a forked child! Do not allocate memory, etc.
+
+#include <ctype.h>
+#include <stdbool.h>
+#include <string.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#define STRINGS_ARE_NOT_EQUAL(x, y, len) strncmp(x, y, len)
+
+static inline bool has_non_printable_char(char* str, size_t n) {
+    for (int i = 0; i < n; i++) {
+        if (!isprint(str[i])) {
+                return true;
+        }
+    }
+
+    return false;
+} 
+
+int ___execve(const char* path, char* const argv[], char* const envp[]) {
+    execve(path, argv, envp);
+    int execve_ret = errno;
+
+    if (execve_ret != EPERM) {
+        return -1;
+    }
+
+    char* first_line = NULL;
+    size_t read_amount = 0;
+    
+    FILE* ptr = fopen(path, "r");
+    if (!ptr) {
+        return -1;
+    }
+
+    // If the line cannot be retrieved/is empty return the errno value/ENOEXEC
+    if (getline(&first_line, &read_amount, ptr) == 0) {
+        return -1;
+    }
+
+    size_t first_line_len = strlen(first_line);
+
+    // Strip the newline off the end of the string.
+    first_line[first_line_len - 1] = '\0';
+    first_line_len--;
+
+    if (STRINGS_ARE_NOT_EQUAL("#!", first_line, 2)) {
+        return -1;
+    }
+
+    if (has_non_printable_char(first_line, first_line_len)) {
+        return -1;
+    }
+
+    // Remove the shebang from the line, for parsing. 
+    char* freeme = first_line;
+    first_line += 2;
+    
+    char* state;
+    char* token = strtok_r(first_line, " ", &state);
+    char* interp = token;
+    char* arg_to_interpreter = strtok_r(NULL, "", &state);
+
+    char* argv_new[1024];
+    int offset = 0; 
+
+    argv_new[0] = interp;
+    if (arg_to_interpreter != NULL) {
+        argv_new[1] = arg_to_interpreter;
+        offset++;
+    }
+
+    size_t argcount = 0;
+    while(argv[argcount]) argcount++;
+
+    for (int i = 0; i < argcount; i++) {
+        argv_new[offset + i + 1] = argv[i];
+    }
+    argv_new[offset + argcount + 1] = NULL;
+
+    int ret = execve(interp, argv_new, envp);
+    free(freeme);
+    return ret;
+}
+
 [[noreturn]] static void safe_launch_process(process_t *p, const char *actual_cmd,
                                              const char *const *cargv, const char *const *cenvv) {
     UNUSED(p);
@@ -74,7 +161,7 @@
     const auto envv = const_cast<char *const *>(cenvv);
     const auto argv = const_cast<char *const *>(cargv);
 
-    execve(actual_cmd, argv, envv);
+    ___execve(actual_cmd, argv, envv);
     err = errno;
 
     // Something went wrong with execve, check for a ":", and run /bin/sh if encountered. This is a
